
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model MediaSource
 * 
 */
export type MediaSource = $Result.DefaultSelection<Prisma.$MediaSourcePayload>
/**
 * Model Tweet
 * 
 */
export type Tweet = $Result.DefaultSelection<Prisma.$TweetPayload>
/**
 * Model TweetMedia
 * 
 */
export type TweetMedia = $Result.DefaultSelection<Prisma.$TweetMediaPayload>
/**
 * Model News
 * 
 */
export type News = $Result.DefaultSelection<Prisma.$NewsPayload>
/**
 * Model AiAnalysis
 * 
 */
export type AiAnalysis = $Result.DefaultSelection<Prisma.$AiAnalysisPayload>
/**
 * Model AiProcessingQueue
 * 
 */
export type AiProcessingQueue = $Result.DefaultSelection<Prisma.$AiProcessingQueuePayload>
/**
 * Model Alert
 * 
 */
export type Alert = $Result.DefaultSelection<Prisma.$AlertPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TenantType: {
  GOVERNMENT_STATE: 'GOVERNMENT_STATE',
  GOVERNMENT_MUNICIPAL: 'GOVERNMENT_MUNICIPAL',
  HIGH_PROFILE: 'HIGH_PROFILE'
};

export type TenantType = (typeof TenantType)[keyof typeof TenantType]


export const TenantStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type TenantStatus = (typeof TenantStatus)[keyof typeof TenantStatus]


export const UserRole: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  DIRECTOR_COMUNICACION: 'DIRECTOR_COMUNICACION',
  LIDER: 'LIDER',
  DIRECTOR_AREA: 'DIRECTOR_AREA',
  ASISTENTE: 'ASISTENTE'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const MediaType: {
  TWITTER: 'TWITTER',
  NEWS_WEBSITE: 'NEWS_WEBSITE',
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO',
  AUDIO: 'AUDIO'
};

export type MediaType = (typeof MediaType)[keyof typeof MediaType]


export const AnalysisType: {
  TWEET_ANALYSIS: 'TWEET_ANALYSIS',
  NEWS_ANALYSIS: 'NEWS_ANALYSIS',
  CLUSTER_ANALYSIS: 'CLUSTER_ANALYSIS',
  THREAT_DETECTION: 'THREAT_DETECTION'
};

export type AnalysisType = (typeof AnalysisType)[keyof typeof AnalysisType]


export const ThreatLevel: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type ThreatLevel = (typeof ThreatLevel)[keyof typeof ThreatLevel]


export const QueueType: {
  TWEET_ANALYSIS: 'TWEET_ANALYSIS',
  NEWS_ANALYSIS: 'NEWS_ANALYSIS',
  CLUSTER_ANALYSIS: 'CLUSTER_ANALYSIS',
  REACTIVATION_CHECK: 'REACTIVATION_CHECK'
};

export type QueueType = (typeof QueueType)[keyof typeof QueueType]


export const QueueStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type QueueStatus = (typeof QueueStatus)[keyof typeof QueueStatus]


export const AlertType: {
  THREAT_DETECTED: 'THREAT_DETECTED',
  NEWS_MENTION: 'NEWS_MENTION',
  SENTIMENT_CHANGE: 'SENTIMENT_CHANGE',
  SYSTEM_ERROR: 'SYSTEM_ERROR',
  MANUAL_ALERT: 'MANUAL_ALERT'
};

export type AlertType = (typeof AlertType)[keyof typeof AlertType]


export const AlertSeverity: {
  INFO: 'INFO',
  WARNING: 'WARNING',
  ERROR: 'ERROR',
  CRITICAL: 'CRITICAL'
};

export type AlertSeverity = (typeof AlertSeverity)[keyof typeof AlertSeverity]


export const AlertStatus: {
  UNREAD: 'UNREAD',
  READ: 'READ',
  ARCHIVED: 'ARCHIVED'
};

export type AlertStatus = (typeof AlertStatus)[keyof typeof AlertStatus]


export const AuditAction: {
  LOGIN: 'LOGIN',
  LOGOUT: 'LOGOUT',
  LOGIN_FAILED: 'LOGIN_FAILED',
  TOKEN_REFRESH: 'TOKEN_REFRESH',
  USER_CREATED: 'USER_CREATED',
  USER_UPDATED: 'USER_UPDATED',
  USER_SUSPENDED: 'USER_SUSPENDED',
  USER_REACTIVATED: 'USER_REACTIVATED',
  USER_DELETED: 'USER_DELETED',
  PASSWORD_CHANGED: 'PASSWORD_CHANGED',
  PASSWORD_RESET: 'PASSWORD_RESET',
  TENANT_CREATED: 'TENANT_CREATED',
  TENANT_UPDATED: 'TENANT_UPDATED',
  TENANT_SUSPENDED: 'TENANT_SUSPENDED',
  TENANT_REACTIVATED: 'TENANT_REACTIVATED',
  TENANT_DELETED: 'TENANT_DELETED',
  SYSTEM_STARTUP: 'SYSTEM_STARTUP',
  SYSTEM_SHUTDOWN: 'SYSTEM_SHUTDOWN',
  CONFIGURATION_CHANGED: 'CONFIGURATION_CHANGED',
  DATA_ACCESSED: 'DATA_ACCESSED',
  DATA_EXPORTED: 'DATA_EXPORTED',
  REPORT_GENERATED: 'REPORT_GENERATED'
};

export type AuditAction = (typeof AuditAction)[keyof typeof AuditAction]


export const AuditEntityType: {
  USER: 'USER',
  TENANT: 'TENANT',
  TWEET: 'TWEET',
  NEWS: 'NEWS',
  ALERT: 'ALERT',
  AI_ANALYSIS: 'AI_ANALYSIS',
  MEDIA_SOURCE: 'MEDIA_SOURCE',
  SYSTEM: 'SYSTEM'
};

export type AuditEntityType = (typeof AuditEntityType)[keyof typeof AuditEntityType]


export const SecurityLevel: {
  PUBLIC: 'PUBLIC',
  INTERNAL: 'INTERNAL',
  CONFIDENTIAL: 'CONFIDENTIAL',
  SECRET: 'SECRET'
};

export type SecurityLevel = (typeof SecurityLevel)[keyof typeof SecurityLevel]

}

export type TenantType = $Enums.TenantType

export const TenantType: typeof $Enums.TenantType

export type TenantStatus = $Enums.TenantStatus

export const TenantStatus: typeof $Enums.TenantStatus

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type MediaType = $Enums.MediaType

export const MediaType: typeof $Enums.MediaType

export type AnalysisType = $Enums.AnalysisType

export const AnalysisType: typeof $Enums.AnalysisType

export type ThreatLevel = $Enums.ThreatLevel

export const ThreatLevel: typeof $Enums.ThreatLevel

export type QueueType = $Enums.QueueType

export const QueueType: typeof $Enums.QueueType

export type QueueStatus = $Enums.QueueStatus

export const QueueStatus: typeof $Enums.QueueStatus

export type AlertType = $Enums.AlertType

export const AlertType: typeof $Enums.AlertType

export type AlertSeverity = $Enums.AlertSeverity

export const AlertSeverity: typeof $Enums.AlertSeverity

export type AlertStatus = $Enums.AlertStatus

export const AlertStatus: typeof $Enums.AlertStatus

export type AuditAction = $Enums.AuditAction

export const AuditAction: typeof $Enums.AuditAction

export type AuditEntityType = $Enums.AuditEntityType

export const AuditEntityType: typeof $Enums.AuditEntityType

export type SecurityLevel = $Enums.SecurityLevel

export const SecurityLevel: typeof $Enums.SecurityLevel

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mediaSource`: Exposes CRUD operations for the **MediaSource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MediaSources
    * const mediaSources = await prisma.mediaSource.findMany()
    * ```
    */
  get mediaSource(): Prisma.MediaSourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tweet`: Exposes CRUD operations for the **Tweet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tweets
    * const tweets = await prisma.tweet.findMany()
    * ```
    */
  get tweet(): Prisma.TweetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tweetMedia`: Exposes CRUD operations for the **TweetMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TweetMedias
    * const tweetMedias = await prisma.tweetMedia.findMany()
    * ```
    */
  get tweetMedia(): Prisma.TweetMediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.news`: Exposes CRUD operations for the **News** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more News
    * const news = await prisma.news.findMany()
    * ```
    */
  get news(): Prisma.NewsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiAnalysis`: Exposes CRUD operations for the **AiAnalysis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiAnalyses
    * const aiAnalyses = await prisma.aiAnalysis.findMany()
    * ```
    */
  get aiAnalysis(): Prisma.AiAnalysisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiProcessingQueue`: Exposes CRUD operations for the **AiProcessingQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiProcessingQueues
    * const aiProcessingQueues = await prisma.aiProcessingQueue.findMany()
    * ```
    */
  get aiProcessingQueue(): Prisma.AiProcessingQueueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alert`: Exposes CRUD operations for the **Alert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alerts
    * const alerts = await prisma.alert.findMany()
    * ```
    */
  get alert(): Prisma.AlertDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    User: 'User',
    MediaSource: 'MediaSource',
    Tweet: 'Tweet',
    TweetMedia: 'TweetMedia',
    News: 'News',
    AiAnalysis: 'AiAnalysis',
    AiProcessingQueue: 'AiProcessingQueue',
    Alert: 'Alert',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "tenant" | "user" | "mediaSource" | "tweet" | "tweetMedia" | "news" | "aiAnalysis" | "aiProcessingQueue" | "alert" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      MediaSource: {
        payload: Prisma.$MediaSourcePayload<ExtArgs>
        fields: Prisma.MediaSourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaSourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaSourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaSourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaSourcePayload>
          }
          findFirst: {
            args: Prisma.MediaSourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaSourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaSourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaSourcePayload>
          }
          findMany: {
            args: Prisma.MediaSourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaSourcePayload>[]
          }
          create: {
            args: Prisma.MediaSourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaSourcePayload>
          }
          createMany: {
            args: Prisma.MediaSourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaSourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaSourcePayload>[]
          }
          delete: {
            args: Prisma.MediaSourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaSourcePayload>
          }
          update: {
            args: Prisma.MediaSourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaSourcePayload>
          }
          deleteMany: {
            args: Prisma.MediaSourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaSourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MediaSourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaSourcePayload>[]
          }
          upsert: {
            args: Prisma.MediaSourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaSourcePayload>
          }
          aggregate: {
            args: Prisma.MediaSourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMediaSource>
          }
          groupBy: {
            args: Prisma.MediaSourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaSourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaSourceCountArgs<ExtArgs>
            result: $Utils.Optional<MediaSourceCountAggregateOutputType> | number
          }
        }
      }
      Tweet: {
        payload: Prisma.$TweetPayload<ExtArgs>
        fields: Prisma.TweetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TweetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TweetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetPayload>
          }
          findFirst: {
            args: Prisma.TweetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TweetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetPayload>
          }
          findMany: {
            args: Prisma.TweetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetPayload>[]
          }
          create: {
            args: Prisma.TweetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetPayload>
          }
          createMany: {
            args: Prisma.TweetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TweetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetPayload>[]
          }
          delete: {
            args: Prisma.TweetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetPayload>
          }
          update: {
            args: Prisma.TweetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetPayload>
          }
          deleteMany: {
            args: Prisma.TweetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TweetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TweetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetPayload>[]
          }
          upsert: {
            args: Prisma.TweetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetPayload>
          }
          aggregate: {
            args: Prisma.TweetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTweet>
          }
          groupBy: {
            args: Prisma.TweetGroupByArgs<ExtArgs>
            result: $Utils.Optional<TweetGroupByOutputType>[]
          }
          count: {
            args: Prisma.TweetCountArgs<ExtArgs>
            result: $Utils.Optional<TweetCountAggregateOutputType> | number
          }
        }
      }
      TweetMedia: {
        payload: Prisma.$TweetMediaPayload<ExtArgs>
        fields: Prisma.TweetMediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TweetMediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetMediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TweetMediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetMediaPayload>
          }
          findFirst: {
            args: Prisma.TweetMediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetMediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TweetMediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetMediaPayload>
          }
          findMany: {
            args: Prisma.TweetMediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetMediaPayload>[]
          }
          create: {
            args: Prisma.TweetMediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetMediaPayload>
          }
          createMany: {
            args: Prisma.TweetMediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TweetMediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetMediaPayload>[]
          }
          delete: {
            args: Prisma.TweetMediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetMediaPayload>
          }
          update: {
            args: Prisma.TweetMediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetMediaPayload>
          }
          deleteMany: {
            args: Prisma.TweetMediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TweetMediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TweetMediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetMediaPayload>[]
          }
          upsert: {
            args: Prisma.TweetMediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TweetMediaPayload>
          }
          aggregate: {
            args: Prisma.TweetMediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTweetMedia>
          }
          groupBy: {
            args: Prisma.TweetMediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TweetMediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.TweetMediaCountArgs<ExtArgs>
            result: $Utils.Optional<TweetMediaCountAggregateOutputType> | number
          }
        }
      }
      News: {
        payload: Prisma.$NewsPayload<ExtArgs>
        fields: Prisma.NewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          findFirst: {
            args: Prisma.NewsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          findMany: {
            args: Prisma.NewsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>[]
          }
          create: {
            args: Prisma.NewsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          createMany: {
            args: Prisma.NewsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>[]
          }
          delete: {
            args: Prisma.NewsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          update: {
            args: Prisma.NewsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          deleteMany: {
            args: Prisma.NewsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NewsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>[]
          }
          upsert: {
            args: Prisma.NewsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          aggregate: {
            args: Prisma.NewsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNews>
          }
          groupBy: {
            args: Prisma.NewsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsCountArgs<ExtArgs>
            result: $Utils.Optional<NewsCountAggregateOutputType> | number
          }
        }
      }
      AiAnalysis: {
        payload: Prisma.$AiAnalysisPayload<ExtArgs>
        fields: Prisma.AiAnalysisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiAnalysisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAnalysisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiAnalysisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAnalysisPayload>
          }
          findFirst: {
            args: Prisma.AiAnalysisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAnalysisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiAnalysisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAnalysisPayload>
          }
          findMany: {
            args: Prisma.AiAnalysisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAnalysisPayload>[]
          }
          create: {
            args: Prisma.AiAnalysisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAnalysisPayload>
          }
          createMany: {
            args: Prisma.AiAnalysisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiAnalysisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAnalysisPayload>[]
          }
          delete: {
            args: Prisma.AiAnalysisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAnalysisPayload>
          }
          update: {
            args: Prisma.AiAnalysisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAnalysisPayload>
          }
          deleteMany: {
            args: Prisma.AiAnalysisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiAnalysisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiAnalysisUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAnalysisPayload>[]
          }
          upsert: {
            args: Prisma.AiAnalysisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAnalysisPayload>
          }
          aggregate: {
            args: Prisma.AiAnalysisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiAnalysis>
          }
          groupBy: {
            args: Prisma.AiAnalysisGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiAnalysisGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiAnalysisCountArgs<ExtArgs>
            result: $Utils.Optional<AiAnalysisCountAggregateOutputType> | number
          }
        }
      }
      AiProcessingQueue: {
        payload: Prisma.$AiProcessingQueuePayload<ExtArgs>
        fields: Prisma.AiProcessingQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiProcessingQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiProcessingQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiProcessingQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiProcessingQueuePayload>
          }
          findFirst: {
            args: Prisma.AiProcessingQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiProcessingQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiProcessingQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiProcessingQueuePayload>
          }
          findMany: {
            args: Prisma.AiProcessingQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiProcessingQueuePayload>[]
          }
          create: {
            args: Prisma.AiProcessingQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiProcessingQueuePayload>
          }
          createMany: {
            args: Prisma.AiProcessingQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiProcessingQueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiProcessingQueuePayload>[]
          }
          delete: {
            args: Prisma.AiProcessingQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiProcessingQueuePayload>
          }
          update: {
            args: Prisma.AiProcessingQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiProcessingQueuePayload>
          }
          deleteMany: {
            args: Prisma.AiProcessingQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiProcessingQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiProcessingQueueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiProcessingQueuePayload>[]
          }
          upsert: {
            args: Prisma.AiProcessingQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiProcessingQueuePayload>
          }
          aggregate: {
            args: Prisma.AiProcessingQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiProcessingQueue>
          }
          groupBy: {
            args: Prisma.AiProcessingQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiProcessingQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiProcessingQueueCountArgs<ExtArgs>
            result: $Utils.Optional<AiProcessingQueueCountAggregateOutputType> | number
          }
        }
      }
      Alert: {
        payload: Prisma.$AlertPayload<ExtArgs>
        fields: Prisma.AlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findFirst: {
            args: Prisma.AlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findMany: {
            args: Prisma.AlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          create: {
            args: Prisma.AlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          createMany: {
            args: Prisma.AlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          delete: {
            args: Prisma.AlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          update: {
            args: Prisma.AlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          deleteMany: {
            args: Prisma.AlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlertUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          upsert: {
            args: Prisma.AlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          aggregate: {
            args: Prisma.AlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlert>
          }
          groupBy: {
            args: Prisma.AlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertCountArgs<ExtArgs>
            result: $Utils.Optional<AlertCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    tenant?: TenantOmit
    user?: UserOmit
    mediaSource?: MediaSourceOmit
    tweet?: TweetOmit
    tweetMedia?: TweetMediaOmit
    news?: NewsOmit
    aiAnalysis?: AiAnalysisOmit
    aiProcessingQueue?: AiProcessingQueueOmit
    alert?: AlertOmit
    auditLog?: AuditLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    users: number
    tweets: number
    news: number
    aiAnalysis: number
    alerts: number
    aiProcessingQueue: number
    auditLogs: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    tweets?: boolean | TenantCountOutputTypeCountTweetsArgs
    news?: boolean | TenantCountOutputTypeCountNewsArgs
    aiAnalysis?: boolean | TenantCountOutputTypeCountAiAnalysisArgs
    alerts?: boolean | TenantCountOutputTypeCountAlertsArgs
    aiProcessingQueue?: boolean | TenantCountOutputTypeCountAiProcessingQueueArgs
    auditLogs?: boolean | TenantCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountTweetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TweetWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountNewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAiAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiAnalysisWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAiProcessingQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiProcessingQueueWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    alerts: number
    auditLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alerts?: boolean | UserCountOutputTypeCountAlertsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type MediaSourceCountOutputType
   */

  export type MediaSourceCountOutputType = {
    tweets: number
    news: number
  }

  export type MediaSourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweets?: boolean | MediaSourceCountOutputTypeCountTweetsArgs
    news?: boolean | MediaSourceCountOutputTypeCountNewsArgs
  }

  // Custom InputTypes
  /**
   * MediaSourceCountOutputType without action
   */
  export type MediaSourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaSourceCountOutputType
     */
    select?: MediaSourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MediaSourceCountOutputType without action
   */
  export type MediaSourceCountOutputTypeCountTweetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TweetWhereInput
  }

  /**
   * MediaSourceCountOutputType without action
   */
  export type MediaSourceCountOutputTypeCountNewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsWhereInput
  }


  /**
   * Count Type TweetCountOutputType
   */

  export type TweetCountOutputType = {
    news: number
    aiAnalysis: number
    tweetMedia: number
  }

  export type TweetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    news?: boolean | TweetCountOutputTypeCountNewsArgs
    aiAnalysis?: boolean | TweetCountOutputTypeCountAiAnalysisArgs
    tweetMedia?: boolean | TweetCountOutputTypeCountTweetMediaArgs
  }

  // Custom InputTypes
  /**
   * TweetCountOutputType without action
   */
  export type TweetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetCountOutputType
     */
    select?: TweetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TweetCountOutputType without action
   */
  export type TweetCountOutputTypeCountNewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsWhereInput
  }

  /**
   * TweetCountOutputType without action
   */
  export type TweetCountOutputTypeCountAiAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiAnalysisWhereInput
  }

  /**
   * TweetCountOutputType without action
   */
  export type TweetCountOutputTypeCountTweetMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TweetMediaWhereInput
  }


  /**
   * Count Type NewsCountOutputType
   */

  export type NewsCountOutputType = {
    aiAnalysis: number
  }

  export type NewsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aiAnalysis?: boolean | NewsCountOutputTypeCountAiAnalysisArgs
  }

  // Custom InputTypes
  /**
   * NewsCountOutputType without action
   */
  export type NewsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsCountOutputType
     */
    select?: NewsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NewsCountOutputType without action
   */
  export type NewsCountOutputTypeCountAiAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiAnalysisWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.TenantType | null
    status: $Enums.TenantStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.TenantType | null
    status: $Enums.TenantStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    type: number
    status: number
    settings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    type: $Enums.TenantType
    status: $Enums.TenantStatus
    settings: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Tenant$usersArgs<ExtArgs>
    tweets?: boolean | Tenant$tweetsArgs<ExtArgs>
    news?: boolean | Tenant$newsArgs<ExtArgs>
    aiAnalysis?: boolean | Tenant$aiAnalysisArgs<ExtArgs>
    alerts?: boolean | Tenant$alertsArgs<ExtArgs>
    aiProcessingQueue?: boolean | Tenant$aiProcessingQueueArgs<ExtArgs>
    auditLogs?: boolean | Tenant$auditLogsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "status" | "settings" | "createdAt" | "updatedAt", ExtArgs["result"]["tenant"]>
  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Tenant$usersArgs<ExtArgs>
    tweets?: boolean | Tenant$tweetsArgs<ExtArgs>
    news?: boolean | Tenant$newsArgs<ExtArgs>
    aiAnalysis?: boolean | Tenant$aiAnalysisArgs<ExtArgs>
    alerts?: boolean | Tenant$alertsArgs<ExtArgs>
    aiProcessingQueue?: boolean | Tenant$aiProcessingQueueArgs<ExtArgs>
    auditLogs?: boolean | Tenant$auditLogsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TenantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      tweets: Prisma.$TweetPayload<ExtArgs>[]
      news: Prisma.$NewsPayload<ExtArgs>[]
      aiAnalysis: Prisma.$AiAnalysisPayload<ExtArgs>[]
      alerts: Prisma.$AlertPayload<ExtArgs>[]
      aiProcessingQueue: Prisma.$AiProcessingQueuePayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.TenantType
      status: $Enums.TenantStatus
      settings: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants and returns the data updated in the database.
     * @param {TenantUpdateManyAndReturnArgs} args - Arguments to update many Tenants.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tweets<T extends Tenant$tweetsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$tweetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    news<T extends Tenant$newsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$newsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiAnalysis<T extends Tenant$aiAnalysisArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$aiAnalysisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    alerts<T extends Tenant$alertsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiProcessingQueue<T extends Tenant$aiProcessingQueueArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$aiProcessingQueueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiProcessingQueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends Tenant$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly type: FieldRef<"Tenant", 'TenantType'>
    readonly status: FieldRef<"Tenant", 'TenantStatus'>
    readonly settings: FieldRef<"Tenant", 'Json'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant updateManyAndReturn
   */
  export type TenantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to delete.
     */
    limit?: number
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant.tweets
   */
  export type Tenant$tweetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetInclude<ExtArgs> | null
    where?: TweetWhereInput
    orderBy?: TweetOrderByWithRelationInput | TweetOrderByWithRelationInput[]
    cursor?: TweetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TweetScalarFieldEnum | TweetScalarFieldEnum[]
  }

  /**
   * Tenant.news
   */
  export type Tenant$newsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    where?: NewsWhereInput
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    cursor?: NewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * Tenant.aiAnalysis
   */
  export type Tenant$aiAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAnalysis
     */
    select?: AiAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAnalysis
     */
    omit?: AiAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAnalysisInclude<ExtArgs> | null
    where?: AiAnalysisWhereInput
    orderBy?: AiAnalysisOrderByWithRelationInput | AiAnalysisOrderByWithRelationInput[]
    cursor?: AiAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiAnalysisScalarFieldEnum | AiAnalysisScalarFieldEnum[]
  }

  /**
   * Tenant.alerts
   */
  export type Tenant$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Tenant.aiProcessingQueue
   */
  export type Tenant$aiProcessingQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiProcessingQueue
     */
    select?: AiProcessingQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiProcessingQueue
     */
    omit?: AiProcessingQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiProcessingQueueInclude<ExtArgs> | null
    where?: AiProcessingQueueWhereInput
    orderBy?: AiProcessingQueueOrderByWithRelationInput | AiProcessingQueueOrderByWithRelationInput[]
    cursor?: AiProcessingQueueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiProcessingQueueScalarFieldEnum | AiProcessingQueueScalarFieldEnum[]
  }

  /**
   * Tenant.auditLogs
   */
  export type Tenant$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    username: string | null
    password: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    lastLoginAt: Date | null
    isTemporaryPassword: boolean | null
    temporaryPasswordExpiresAt: Date | null
    suspendedAt: Date | null
    suspendedBy: string | null
    suspensionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    username: string | null
    password: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    lastLoginAt: Date | null
    isTemporaryPassword: boolean | null
    temporaryPasswordExpiresAt: Date | null
    suspendedAt: Date | null
    suspendedBy: string | null
    suspensionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    tenantId: number
    email: number
    username: number
    password: number
    role: number
    status: number
    settings: number
    lastLoginAt: number
    isTemporaryPassword: number
    temporaryPasswordExpiresAt: number
    suspendedAt: number
    suspendedBy: number
    suspensionReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    username?: true
    password?: true
    role?: true
    status?: true
    lastLoginAt?: true
    isTemporaryPassword?: true
    temporaryPasswordExpiresAt?: true
    suspendedAt?: true
    suspendedBy?: true
    suspensionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    username?: true
    password?: true
    role?: true
    status?: true
    lastLoginAt?: true
    isTemporaryPassword?: true
    temporaryPasswordExpiresAt?: true
    suspendedAt?: true
    suspendedBy?: true
    suspensionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    username?: true
    password?: true
    role?: true
    status?: true
    settings?: true
    lastLoginAt?: true
    isTemporaryPassword?: true
    temporaryPasswordExpiresAt?: true
    suspendedAt?: true
    suspendedBy?: true
    suspensionReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    tenantId: string | null
    email: string
    username: string
    password: string
    role: $Enums.UserRole
    status: $Enums.UserStatus
    settings: JsonValue | null
    lastLoginAt: Date | null
    isTemporaryPassword: boolean
    temporaryPasswordExpiresAt: Date | null
    suspendedAt: Date | null
    suspendedBy: string | null
    suspensionReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    status?: boolean
    settings?: boolean
    lastLoginAt?: boolean
    isTemporaryPassword?: boolean
    temporaryPasswordExpiresAt?: boolean
    suspendedAt?: boolean
    suspendedBy?: boolean
    suspensionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | User$tenantArgs<ExtArgs>
    alerts?: boolean | User$alertsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    status?: boolean
    settings?: boolean
    lastLoginAt?: boolean
    isTemporaryPassword?: boolean
    temporaryPasswordExpiresAt?: boolean
    suspendedAt?: boolean
    suspendedBy?: boolean
    suspensionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | User$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    status?: boolean
    settings?: boolean
    lastLoginAt?: boolean
    isTemporaryPassword?: boolean
    temporaryPasswordExpiresAt?: boolean
    suspendedAt?: boolean
    suspendedBy?: boolean
    suspensionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | User$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    tenantId?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    status?: boolean
    settings?: boolean
    lastLoginAt?: boolean
    isTemporaryPassword?: boolean
    temporaryPasswordExpiresAt?: boolean
    suspendedAt?: boolean
    suspendedBy?: boolean
    suspensionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "email" | "username" | "password" | "role" | "status" | "settings" | "lastLoginAt" | "isTemporaryPassword" | "temporaryPasswordExpiresAt" | "suspendedAt" | "suspendedBy" | "suspensionReason" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | User$tenantArgs<ExtArgs>
    alerts?: boolean | User$alertsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | User$tenantArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | User$tenantArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs> | null
      alerts: Prisma.$AlertPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string | null
      email: string
      username: string
      password: string
      role: $Enums.UserRole
      status: $Enums.UserStatus
      settings: Prisma.JsonValue | null
      lastLoginAt: Date | null
      isTemporaryPassword: boolean
      temporaryPasswordExpiresAt: Date | null
      suspendedAt: Date | null
      suspendedBy: string | null
      suspensionReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends User$tenantArgs<ExtArgs> = {}>(args?: Subset<T, User$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    alerts<T extends User$alertsArgs<ExtArgs> = {}>(args?: Subset<T, User$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly settings: FieldRef<"User", 'Json'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly isTemporaryPassword: FieldRef<"User", 'Boolean'>
    readonly temporaryPasswordExpiresAt: FieldRef<"User", 'DateTime'>
    readonly suspendedAt: FieldRef<"User", 'DateTime'>
    readonly suspendedBy: FieldRef<"User", 'String'>
    readonly suspensionReason: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.tenant
   */
  export type User$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * User.alerts
   */
  export type User$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model MediaSource
   */

  export type AggregateMediaSource = {
    _count: MediaSourceCountAggregateOutputType | null
    _min: MediaSourceMinAggregateOutputType | null
    _max: MediaSourceMaxAggregateOutputType | null
  }

  export type MediaSourceMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.MediaType | null
    baseUrl: string | null
    twitterHandle: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaSourceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.MediaType | null
    baseUrl: string | null
    twitterHandle: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaSourceCountAggregateOutputType = {
    id: number
    name: number
    type: number
    baseUrl: number
    twitterHandle: number
    selectors: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MediaSourceMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    baseUrl?: true
    twitterHandle?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaSourceMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    baseUrl?: true
    twitterHandle?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaSourceCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    baseUrl?: true
    twitterHandle?: true
    selectors?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MediaSourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaSource to aggregate.
     */
    where?: MediaSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaSources to fetch.
     */
    orderBy?: MediaSourceOrderByWithRelationInput | MediaSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MediaSources
    **/
    _count?: true | MediaSourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaSourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaSourceMaxAggregateInputType
  }

  export type GetMediaSourceAggregateType<T extends MediaSourceAggregateArgs> = {
        [P in keyof T & keyof AggregateMediaSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMediaSource[P]>
      : GetScalarType<T[P], AggregateMediaSource[P]>
  }




  export type MediaSourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaSourceWhereInput
    orderBy?: MediaSourceOrderByWithAggregationInput | MediaSourceOrderByWithAggregationInput[]
    by: MediaSourceScalarFieldEnum[] | MediaSourceScalarFieldEnum
    having?: MediaSourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaSourceCountAggregateInputType | true
    _min?: MediaSourceMinAggregateInputType
    _max?: MediaSourceMaxAggregateInputType
  }

  export type MediaSourceGroupByOutputType = {
    id: string
    name: string
    type: $Enums.MediaType
    baseUrl: string | null
    twitterHandle: string | null
    selectors: JsonValue | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: MediaSourceCountAggregateOutputType | null
    _min: MediaSourceMinAggregateOutputType | null
    _max: MediaSourceMaxAggregateOutputType | null
  }

  type GetMediaSourceGroupByPayload<T extends MediaSourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaSourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaSourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaSourceGroupByOutputType[P]>
            : GetScalarType<T[P], MediaSourceGroupByOutputType[P]>
        }
      >
    >


  export type MediaSourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    baseUrl?: boolean
    twitterHandle?: boolean
    selectors?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tweets?: boolean | MediaSource$tweetsArgs<ExtArgs>
    news?: boolean | MediaSource$newsArgs<ExtArgs>
    _count?: boolean | MediaSourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaSource"]>

  export type MediaSourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    baseUrl?: boolean
    twitterHandle?: boolean
    selectors?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mediaSource"]>

  export type MediaSourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    baseUrl?: boolean
    twitterHandle?: boolean
    selectors?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mediaSource"]>

  export type MediaSourceSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    baseUrl?: boolean
    twitterHandle?: boolean
    selectors?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MediaSourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "baseUrl" | "twitterHandle" | "selectors" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["mediaSource"]>
  export type MediaSourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweets?: boolean | MediaSource$tweetsArgs<ExtArgs>
    news?: boolean | MediaSource$newsArgs<ExtArgs>
    _count?: boolean | MediaSourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MediaSourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MediaSourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MediaSourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MediaSource"
    objects: {
      tweets: Prisma.$TweetPayload<ExtArgs>[]
      news: Prisma.$NewsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.MediaType
      baseUrl: string | null
      twitterHandle: string | null
      selectors: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mediaSource"]>
    composites: {}
  }

  type MediaSourceGetPayload<S extends boolean | null | undefined | MediaSourceDefaultArgs> = $Result.GetResult<Prisma.$MediaSourcePayload, S>

  type MediaSourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaSourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaSourceCountAggregateInputType | true
    }

  export interface MediaSourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MediaSource'], meta: { name: 'MediaSource' } }
    /**
     * Find zero or one MediaSource that matches the filter.
     * @param {MediaSourceFindUniqueArgs} args - Arguments to find a MediaSource
     * @example
     * // Get one MediaSource
     * const mediaSource = await prisma.mediaSource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaSourceFindUniqueArgs>(args: SelectSubset<T, MediaSourceFindUniqueArgs<ExtArgs>>): Prisma__MediaSourceClient<$Result.GetResult<Prisma.$MediaSourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MediaSource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaSourceFindUniqueOrThrowArgs} args - Arguments to find a MediaSource
     * @example
     * // Get one MediaSource
     * const mediaSource = await prisma.mediaSource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaSourceFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaSourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaSourceClient<$Result.GetResult<Prisma.$MediaSourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MediaSource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaSourceFindFirstArgs} args - Arguments to find a MediaSource
     * @example
     * // Get one MediaSource
     * const mediaSource = await prisma.mediaSource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaSourceFindFirstArgs>(args?: SelectSubset<T, MediaSourceFindFirstArgs<ExtArgs>>): Prisma__MediaSourceClient<$Result.GetResult<Prisma.$MediaSourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MediaSource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaSourceFindFirstOrThrowArgs} args - Arguments to find a MediaSource
     * @example
     * // Get one MediaSource
     * const mediaSource = await prisma.mediaSource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaSourceFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaSourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaSourceClient<$Result.GetResult<Prisma.$MediaSourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MediaSources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaSourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MediaSources
     * const mediaSources = await prisma.mediaSource.findMany()
     * 
     * // Get first 10 MediaSources
     * const mediaSources = await prisma.mediaSource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaSourceWithIdOnly = await prisma.mediaSource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaSourceFindManyArgs>(args?: SelectSubset<T, MediaSourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaSourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MediaSource.
     * @param {MediaSourceCreateArgs} args - Arguments to create a MediaSource.
     * @example
     * // Create one MediaSource
     * const MediaSource = await prisma.mediaSource.create({
     *   data: {
     *     // ... data to create a MediaSource
     *   }
     * })
     * 
     */
    create<T extends MediaSourceCreateArgs>(args: SelectSubset<T, MediaSourceCreateArgs<ExtArgs>>): Prisma__MediaSourceClient<$Result.GetResult<Prisma.$MediaSourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MediaSources.
     * @param {MediaSourceCreateManyArgs} args - Arguments to create many MediaSources.
     * @example
     * // Create many MediaSources
     * const mediaSource = await prisma.mediaSource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaSourceCreateManyArgs>(args?: SelectSubset<T, MediaSourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MediaSources and returns the data saved in the database.
     * @param {MediaSourceCreateManyAndReturnArgs} args - Arguments to create many MediaSources.
     * @example
     * // Create many MediaSources
     * const mediaSource = await prisma.mediaSource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MediaSources and only return the `id`
     * const mediaSourceWithIdOnly = await prisma.mediaSource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaSourceCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaSourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaSourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MediaSource.
     * @param {MediaSourceDeleteArgs} args - Arguments to delete one MediaSource.
     * @example
     * // Delete one MediaSource
     * const MediaSource = await prisma.mediaSource.delete({
     *   where: {
     *     // ... filter to delete one MediaSource
     *   }
     * })
     * 
     */
    delete<T extends MediaSourceDeleteArgs>(args: SelectSubset<T, MediaSourceDeleteArgs<ExtArgs>>): Prisma__MediaSourceClient<$Result.GetResult<Prisma.$MediaSourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MediaSource.
     * @param {MediaSourceUpdateArgs} args - Arguments to update one MediaSource.
     * @example
     * // Update one MediaSource
     * const mediaSource = await prisma.mediaSource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaSourceUpdateArgs>(args: SelectSubset<T, MediaSourceUpdateArgs<ExtArgs>>): Prisma__MediaSourceClient<$Result.GetResult<Prisma.$MediaSourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MediaSources.
     * @param {MediaSourceDeleteManyArgs} args - Arguments to filter MediaSources to delete.
     * @example
     * // Delete a few MediaSources
     * const { count } = await prisma.mediaSource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaSourceDeleteManyArgs>(args?: SelectSubset<T, MediaSourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaSourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MediaSources
     * const mediaSource = await prisma.mediaSource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaSourceUpdateManyArgs>(args: SelectSubset<T, MediaSourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaSources and returns the data updated in the database.
     * @param {MediaSourceUpdateManyAndReturnArgs} args - Arguments to update many MediaSources.
     * @example
     * // Update many MediaSources
     * const mediaSource = await prisma.mediaSource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MediaSources and only return the `id`
     * const mediaSourceWithIdOnly = await prisma.mediaSource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MediaSourceUpdateManyAndReturnArgs>(args: SelectSubset<T, MediaSourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaSourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MediaSource.
     * @param {MediaSourceUpsertArgs} args - Arguments to update or create a MediaSource.
     * @example
     * // Update or create a MediaSource
     * const mediaSource = await prisma.mediaSource.upsert({
     *   create: {
     *     // ... data to create a MediaSource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MediaSource we want to update
     *   }
     * })
     */
    upsert<T extends MediaSourceUpsertArgs>(args: SelectSubset<T, MediaSourceUpsertArgs<ExtArgs>>): Prisma__MediaSourceClient<$Result.GetResult<Prisma.$MediaSourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MediaSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaSourceCountArgs} args - Arguments to filter MediaSources to count.
     * @example
     * // Count the number of MediaSources
     * const count = await prisma.mediaSource.count({
     *   where: {
     *     // ... the filter for the MediaSources we want to count
     *   }
     * })
    **/
    count<T extends MediaSourceCountArgs>(
      args?: Subset<T, MediaSourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaSourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MediaSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaSourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaSourceAggregateArgs>(args: Subset<T, MediaSourceAggregateArgs>): Prisma.PrismaPromise<GetMediaSourceAggregateType<T>>

    /**
     * Group by MediaSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaSourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaSourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaSourceGroupByArgs['orderBy'] }
        : { orderBy?: MediaSourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaSourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MediaSource model
   */
  readonly fields: MediaSourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MediaSource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaSourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tweets<T extends MediaSource$tweetsArgs<ExtArgs> = {}>(args?: Subset<T, MediaSource$tweetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    news<T extends MediaSource$newsArgs<ExtArgs> = {}>(args?: Subset<T, MediaSource$newsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MediaSource model
   */
  interface MediaSourceFieldRefs {
    readonly id: FieldRef<"MediaSource", 'String'>
    readonly name: FieldRef<"MediaSource", 'String'>
    readonly type: FieldRef<"MediaSource", 'MediaType'>
    readonly baseUrl: FieldRef<"MediaSource", 'String'>
    readonly twitterHandle: FieldRef<"MediaSource", 'String'>
    readonly selectors: FieldRef<"MediaSource", 'Json'>
    readonly isActive: FieldRef<"MediaSource", 'Boolean'>
    readonly createdAt: FieldRef<"MediaSource", 'DateTime'>
    readonly updatedAt: FieldRef<"MediaSource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MediaSource findUnique
   */
  export type MediaSourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaSource
     */
    select?: MediaSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaSource
     */
    omit?: MediaSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaSourceInclude<ExtArgs> | null
    /**
     * Filter, which MediaSource to fetch.
     */
    where: MediaSourceWhereUniqueInput
  }

  /**
   * MediaSource findUniqueOrThrow
   */
  export type MediaSourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaSource
     */
    select?: MediaSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaSource
     */
    omit?: MediaSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaSourceInclude<ExtArgs> | null
    /**
     * Filter, which MediaSource to fetch.
     */
    where: MediaSourceWhereUniqueInput
  }

  /**
   * MediaSource findFirst
   */
  export type MediaSourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaSource
     */
    select?: MediaSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaSource
     */
    omit?: MediaSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaSourceInclude<ExtArgs> | null
    /**
     * Filter, which MediaSource to fetch.
     */
    where?: MediaSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaSources to fetch.
     */
    orderBy?: MediaSourceOrderByWithRelationInput | MediaSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaSources.
     */
    cursor?: MediaSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaSources.
     */
    distinct?: MediaSourceScalarFieldEnum | MediaSourceScalarFieldEnum[]
  }

  /**
   * MediaSource findFirstOrThrow
   */
  export type MediaSourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaSource
     */
    select?: MediaSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaSource
     */
    omit?: MediaSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaSourceInclude<ExtArgs> | null
    /**
     * Filter, which MediaSource to fetch.
     */
    where?: MediaSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaSources to fetch.
     */
    orderBy?: MediaSourceOrderByWithRelationInput | MediaSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaSources.
     */
    cursor?: MediaSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaSources.
     */
    distinct?: MediaSourceScalarFieldEnum | MediaSourceScalarFieldEnum[]
  }

  /**
   * MediaSource findMany
   */
  export type MediaSourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaSource
     */
    select?: MediaSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaSource
     */
    omit?: MediaSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaSourceInclude<ExtArgs> | null
    /**
     * Filter, which MediaSources to fetch.
     */
    where?: MediaSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaSources to fetch.
     */
    orderBy?: MediaSourceOrderByWithRelationInput | MediaSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MediaSources.
     */
    cursor?: MediaSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaSources.
     */
    skip?: number
    distinct?: MediaSourceScalarFieldEnum | MediaSourceScalarFieldEnum[]
  }

  /**
   * MediaSource create
   */
  export type MediaSourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaSource
     */
    select?: MediaSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaSource
     */
    omit?: MediaSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaSourceInclude<ExtArgs> | null
    /**
     * The data needed to create a MediaSource.
     */
    data: XOR<MediaSourceCreateInput, MediaSourceUncheckedCreateInput>
  }

  /**
   * MediaSource createMany
   */
  export type MediaSourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MediaSources.
     */
    data: MediaSourceCreateManyInput | MediaSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MediaSource createManyAndReturn
   */
  export type MediaSourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaSource
     */
    select?: MediaSourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MediaSource
     */
    omit?: MediaSourceOmit<ExtArgs> | null
    /**
     * The data used to create many MediaSources.
     */
    data: MediaSourceCreateManyInput | MediaSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MediaSource update
   */
  export type MediaSourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaSource
     */
    select?: MediaSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaSource
     */
    omit?: MediaSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaSourceInclude<ExtArgs> | null
    /**
     * The data needed to update a MediaSource.
     */
    data: XOR<MediaSourceUpdateInput, MediaSourceUncheckedUpdateInput>
    /**
     * Choose, which MediaSource to update.
     */
    where: MediaSourceWhereUniqueInput
  }

  /**
   * MediaSource updateMany
   */
  export type MediaSourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MediaSources.
     */
    data: XOR<MediaSourceUpdateManyMutationInput, MediaSourceUncheckedUpdateManyInput>
    /**
     * Filter which MediaSources to update
     */
    where?: MediaSourceWhereInput
    /**
     * Limit how many MediaSources to update.
     */
    limit?: number
  }

  /**
   * MediaSource updateManyAndReturn
   */
  export type MediaSourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaSource
     */
    select?: MediaSourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MediaSource
     */
    omit?: MediaSourceOmit<ExtArgs> | null
    /**
     * The data used to update MediaSources.
     */
    data: XOR<MediaSourceUpdateManyMutationInput, MediaSourceUncheckedUpdateManyInput>
    /**
     * Filter which MediaSources to update
     */
    where?: MediaSourceWhereInput
    /**
     * Limit how many MediaSources to update.
     */
    limit?: number
  }

  /**
   * MediaSource upsert
   */
  export type MediaSourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaSource
     */
    select?: MediaSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaSource
     */
    omit?: MediaSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaSourceInclude<ExtArgs> | null
    /**
     * The filter to search for the MediaSource to update in case it exists.
     */
    where: MediaSourceWhereUniqueInput
    /**
     * In case the MediaSource found by the `where` argument doesn't exist, create a new MediaSource with this data.
     */
    create: XOR<MediaSourceCreateInput, MediaSourceUncheckedCreateInput>
    /**
     * In case the MediaSource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaSourceUpdateInput, MediaSourceUncheckedUpdateInput>
  }

  /**
   * MediaSource delete
   */
  export type MediaSourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaSource
     */
    select?: MediaSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaSource
     */
    omit?: MediaSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaSourceInclude<ExtArgs> | null
    /**
     * Filter which MediaSource to delete.
     */
    where: MediaSourceWhereUniqueInput
  }

  /**
   * MediaSource deleteMany
   */
  export type MediaSourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaSources to delete
     */
    where?: MediaSourceWhereInput
    /**
     * Limit how many MediaSources to delete.
     */
    limit?: number
  }

  /**
   * MediaSource.tweets
   */
  export type MediaSource$tweetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetInclude<ExtArgs> | null
    where?: TweetWhereInput
    orderBy?: TweetOrderByWithRelationInput | TweetOrderByWithRelationInput[]
    cursor?: TweetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TweetScalarFieldEnum | TweetScalarFieldEnum[]
  }

  /**
   * MediaSource.news
   */
  export type MediaSource$newsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    where?: NewsWhereInput
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    cursor?: NewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * MediaSource without action
   */
  export type MediaSourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaSource
     */
    select?: MediaSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaSource
     */
    omit?: MediaSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaSourceInclude<ExtArgs> | null
  }


  /**
   * Model Tweet
   */

  export type AggregateTweet = {
    _count: TweetCountAggregateOutputType | null
    _min: TweetMinAggregateOutputType | null
    _max: TweetMaxAggregateOutputType | null
  }

  export type TweetMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    tweetId: string | null
    mediaSourceId: string | null
    authorName: string | null
    authorHandle: string | null
    content: string | null
    publishedAt: Date | null
    contentHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TweetMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    tweetId: string | null
    mediaSourceId: string | null
    authorName: string | null
    authorHandle: string | null
    content: string | null
    publishedAt: Date | null
    contentHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TweetCountAggregateOutputType = {
    id: number
    tenantId: number
    tweetId: number
    mediaSourceId: number
    authorName: number
    authorHandle: number
    content: number
    publishedAt: number
    hashtags: number
    mentions: number
    mediaUrls: number
    engagement: number
    contentHash: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TweetMinAggregateInputType = {
    id?: true
    tenantId?: true
    tweetId?: true
    mediaSourceId?: true
    authorName?: true
    authorHandle?: true
    content?: true
    publishedAt?: true
    contentHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TweetMaxAggregateInputType = {
    id?: true
    tenantId?: true
    tweetId?: true
    mediaSourceId?: true
    authorName?: true
    authorHandle?: true
    content?: true
    publishedAt?: true
    contentHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TweetCountAggregateInputType = {
    id?: true
    tenantId?: true
    tweetId?: true
    mediaSourceId?: true
    authorName?: true
    authorHandle?: true
    content?: true
    publishedAt?: true
    hashtags?: true
    mentions?: true
    mediaUrls?: true
    engagement?: true
    contentHash?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TweetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tweet to aggregate.
     */
    where?: TweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tweets to fetch.
     */
    orderBy?: TweetOrderByWithRelationInput | TweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tweets
    **/
    _count?: true | TweetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TweetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TweetMaxAggregateInputType
  }

  export type GetTweetAggregateType<T extends TweetAggregateArgs> = {
        [P in keyof T & keyof AggregateTweet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTweet[P]>
      : GetScalarType<T[P], AggregateTweet[P]>
  }




  export type TweetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TweetWhereInput
    orderBy?: TweetOrderByWithAggregationInput | TweetOrderByWithAggregationInput[]
    by: TweetScalarFieldEnum[] | TweetScalarFieldEnum
    having?: TweetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TweetCountAggregateInputType | true
    _min?: TweetMinAggregateInputType
    _max?: TweetMaxAggregateInputType
  }

  export type TweetGroupByOutputType = {
    id: string
    tenantId: string
    tweetId: string
    mediaSourceId: string
    authorName: string
    authorHandle: string
    content: string
    publishedAt: Date
    hashtags: string[]
    mentions: string[]
    mediaUrls: JsonValue | null
    engagement: JsonValue | null
    contentHash: string
    createdAt: Date
    updatedAt: Date
    _count: TweetCountAggregateOutputType | null
    _min: TweetMinAggregateOutputType | null
    _max: TweetMaxAggregateOutputType | null
  }

  type GetTweetGroupByPayload<T extends TweetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TweetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TweetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TweetGroupByOutputType[P]>
            : GetScalarType<T[P], TweetGroupByOutputType[P]>
        }
      >
    >


  export type TweetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    tweetId?: boolean
    mediaSourceId?: boolean
    authorName?: boolean
    authorHandle?: boolean
    content?: boolean
    publishedAt?: boolean
    hashtags?: boolean
    mentions?: boolean
    mediaUrls?: boolean
    engagement?: boolean
    contentHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    mediaSource?: boolean | MediaSourceDefaultArgs<ExtArgs>
    news?: boolean | Tweet$newsArgs<ExtArgs>
    aiAnalysis?: boolean | Tweet$aiAnalysisArgs<ExtArgs>
    tweetMedia?: boolean | Tweet$tweetMediaArgs<ExtArgs>
    _count?: boolean | TweetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweet"]>

  export type TweetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    tweetId?: boolean
    mediaSourceId?: boolean
    authorName?: boolean
    authorHandle?: boolean
    content?: boolean
    publishedAt?: boolean
    hashtags?: boolean
    mentions?: boolean
    mediaUrls?: boolean
    engagement?: boolean
    contentHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    mediaSource?: boolean | MediaSourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweet"]>

  export type TweetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    tweetId?: boolean
    mediaSourceId?: boolean
    authorName?: boolean
    authorHandle?: boolean
    content?: boolean
    publishedAt?: boolean
    hashtags?: boolean
    mentions?: boolean
    mediaUrls?: boolean
    engagement?: boolean
    contentHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    mediaSource?: boolean | MediaSourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweet"]>

  export type TweetSelectScalar = {
    id?: boolean
    tenantId?: boolean
    tweetId?: boolean
    mediaSourceId?: boolean
    authorName?: boolean
    authorHandle?: boolean
    content?: boolean
    publishedAt?: boolean
    hashtags?: boolean
    mentions?: boolean
    mediaUrls?: boolean
    engagement?: boolean
    contentHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TweetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "tweetId" | "mediaSourceId" | "authorName" | "authorHandle" | "content" | "publishedAt" | "hashtags" | "mentions" | "mediaUrls" | "engagement" | "contentHash" | "createdAt" | "updatedAt", ExtArgs["result"]["tweet"]>
  export type TweetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    mediaSource?: boolean | MediaSourceDefaultArgs<ExtArgs>
    news?: boolean | Tweet$newsArgs<ExtArgs>
    aiAnalysis?: boolean | Tweet$aiAnalysisArgs<ExtArgs>
    tweetMedia?: boolean | Tweet$tweetMediaArgs<ExtArgs>
    _count?: boolean | TweetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TweetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    mediaSource?: boolean | MediaSourceDefaultArgs<ExtArgs>
  }
  export type TweetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    mediaSource?: boolean | MediaSourceDefaultArgs<ExtArgs>
  }

  export type $TweetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tweet"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      mediaSource: Prisma.$MediaSourcePayload<ExtArgs>
      news: Prisma.$NewsPayload<ExtArgs>[]
      aiAnalysis: Prisma.$AiAnalysisPayload<ExtArgs>[]
      tweetMedia: Prisma.$TweetMediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      tweetId: string
      mediaSourceId: string
      authorName: string
      authorHandle: string
      content: string
      publishedAt: Date
      hashtags: string[]
      mentions: string[]
      mediaUrls: Prisma.JsonValue | null
      engagement: Prisma.JsonValue | null
      contentHash: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tweet"]>
    composites: {}
  }

  type TweetGetPayload<S extends boolean | null | undefined | TweetDefaultArgs> = $Result.GetResult<Prisma.$TweetPayload, S>

  type TweetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TweetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TweetCountAggregateInputType | true
    }

  export interface TweetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tweet'], meta: { name: 'Tweet' } }
    /**
     * Find zero or one Tweet that matches the filter.
     * @param {TweetFindUniqueArgs} args - Arguments to find a Tweet
     * @example
     * // Get one Tweet
     * const tweet = await prisma.tweet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TweetFindUniqueArgs>(args: SelectSubset<T, TweetFindUniqueArgs<ExtArgs>>): Prisma__TweetClient<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tweet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TweetFindUniqueOrThrowArgs} args - Arguments to find a Tweet
     * @example
     * // Get one Tweet
     * const tweet = await prisma.tweet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TweetFindUniqueOrThrowArgs>(args: SelectSubset<T, TweetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TweetClient<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tweet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetFindFirstArgs} args - Arguments to find a Tweet
     * @example
     * // Get one Tweet
     * const tweet = await prisma.tweet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TweetFindFirstArgs>(args?: SelectSubset<T, TweetFindFirstArgs<ExtArgs>>): Prisma__TweetClient<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tweet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetFindFirstOrThrowArgs} args - Arguments to find a Tweet
     * @example
     * // Get one Tweet
     * const tweet = await prisma.tweet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TweetFindFirstOrThrowArgs>(args?: SelectSubset<T, TweetFindFirstOrThrowArgs<ExtArgs>>): Prisma__TweetClient<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tweets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tweets
     * const tweets = await prisma.tweet.findMany()
     * 
     * // Get first 10 Tweets
     * const tweets = await prisma.tweet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tweetWithIdOnly = await prisma.tweet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TweetFindManyArgs>(args?: SelectSubset<T, TweetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tweet.
     * @param {TweetCreateArgs} args - Arguments to create a Tweet.
     * @example
     * // Create one Tweet
     * const Tweet = await prisma.tweet.create({
     *   data: {
     *     // ... data to create a Tweet
     *   }
     * })
     * 
     */
    create<T extends TweetCreateArgs>(args: SelectSubset<T, TweetCreateArgs<ExtArgs>>): Prisma__TweetClient<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tweets.
     * @param {TweetCreateManyArgs} args - Arguments to create many Tweets.
     * @example
     * // Create many Tweets
     * const tweet = await prisma.tweet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TweetCreateManyArgs>(args?: SelectSubset<T, TweetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tweets and returns the data saved in the database.
     * @param {TweetCreateManyAndReturnArgs} args - Arguments to create many Tweets.
     * @example
     * // Create many Tweets
     * const tweet = await prisma.tweet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tweets and only return the `id`
     * const tweetWithIdOnly = await prisma.tweet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TweetCreateManyAndReturnArgs>(args?: SelectSubset<T, TweetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tweet.
     * @param {TweetDeleteArgs} args - Arguments to delete one Tweet.
     * @example
     * // Delete one Tweet
     * const Tweet = await prisma.tweet.delete({
     *   where: {
     *     // ... filter to delete one Tweet
     *   }
     * })
     * 
     */
    delete<T extends TweetDeleteArgs>(args: SelectSubset<T, TweetDeleteArgs<ExtArgs>>): Prisma__TweetClient<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tweet.
     * @param {TweetUpdateArgs} args - Arguments to update one Tweet.
     * @example
     * // Update one Tweet
     * const tweet = await prisma.tweet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TweetUpdateArgs>(args: SelectSubset<T, TweetUpdateArgs<ExtArgs>>): Prisma__TweetClient<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tweets.
     * @param {TweetDeleteManyArgs} args - Arguments to filter Tweets to delete.
     * @example
     * // Delete a few Tweets
     * const { count } = await prisma.tweet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TweetDeleteManyArgs>(args?: SelectSubset<T, TweetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tweets
     * const tweet = await prisma.tweet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TweetUpdateManyArgs>(args: SelectSubset<T, TweetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tweets and returns the data updated in the database.
     * @param {TweetUpdateManyAndReturnArgs} args - Arguments to update many Tweets.
     * @example
     * // Update many Tweets
     * const tweet = await prisma.tweet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tweets and only return the `id`
     * const tweetWithIdOnly = await prisma.tweet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TweetUpdateManyAndReturnArgs>(args: SelectSubset<T, TweetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tweet.
     * @param {TweetUpsertArgs} args - Arguments to update or create a Tweet.
     * @example
     * // Update or create a Tweet
     * const tweet = await prisma.tweet.upsert({
     *   create: {
     *     // ... data to create a Tweet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tweet we want to update
     *   }
     * })
     */
    upsert<T extends TweetUpsertArgs>(args: SelectSubset<T, TweetUpsertArgs<ExtArgs>>): Prisma__TweetClient<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetCountArgs} args - Arguments to filter Tweets to count.
     * @example
     * // Count the number of Tweets
     * const count = await prisma.tweet.count({
     *   where: {
     *     // ... the filter for the Tweets we want to count
     *   }
     * })
    **/
    count<T extends TweetCountArgs>(
      args?: Subset<T, TweetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TweetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tweet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TweetAggregateArgs>(args: Subset<T, TweetAggregateArgs>): Prisma.PrismaPromise<GetTweetAggregateType<T>>

    /**
     * Group by Tweet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TweetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TweetGroupByArgs['orderBy'] }
        : { orderBy?: TweetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TweetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTweetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tweet model
   */
  readonly fields: TweetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tweet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TweetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mediaSource<T extends MediaSourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MediaSourceDefaultArgs<ExtArgs>>): Prisma__MediaSourceClient<$Result.GetResult<Prisma.$MediaSourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    news<T extends Tweet$newsArgs<ExtArgs> = {}>(args?: Subset<T, Tweet$newsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiAnalysis<T extends Tweet$aiAnalysisArgs<ExtArgs> = {}>(args?: Subset<T, Tweet$aiAnalysisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tweetMedia<T extends Tweet$tweetMediaArgs<ExtArgs> = {}>(args?: Subset<T, Tweet$tweetMediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tweet model
   */
  interface TweetFieldRefs {
    readonly id: FieldRef<"Tweet", 'String'>
    readonly tenantId: FieldRef<"Tweet", 'String'>
    readonly tweetId: FieldRef<"Tweet", 'String'>
    readonly mediaSourceId: FieldRef<"Tweet", 'String'>
    readonly authorName: FieldRef<"Tweet", 'String'>
    readonly authorHandle: FieldRef<"Tweet", 'String'>
    readonly content: FieldRef<"Tweet", 'String'>
    readonly publishedAt: FieldRef<"Tweet", 'DateTime'>
    readonly hashtags: FieldRef<"Tweet", 'String[]'>
    readonly mentions: FieldRef<"Tweet", 'String[]'>
    readonly mediaUrls: FieldRef<"Tweet", 'Json'>
    readonly engagement: FieldRef<"Tweet", 'Json'>
    readonly contentHash: FieldRef<"Tweet", 'String'>
    readonly createdAt: FieldRef<"Tweet", 'DateTime'>
    readonly updatedAt: FieldRef<"Tweet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tweet findUnique
   */
  export type TweetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetInclude<ExtArgs> | null
    /**
     * Filter, which Tweet to fetch.
     */
    where: TweetWhereUniqueInput
  }

  /**
   * Tweet findUniqueOrThrow
   */
  export type TweetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetInclude<ExtArgs> | null
    /**
     * Filter, which Tweet to fetch.
     */
    where: TweetWhereUniqueInput
  }

  /**
   * Tweet findFirst
   */
  export type TweetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetInclude<ExtArgs> | null
    /**
     * Filter, which Tweet to fetch.
     */
    where?: TweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tweets to fetch.
     */
    orderBy?: TweetOrderByWithRelationInput | TweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tweets.
     */
    cursor?: TweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tweets.
     */
    distinct?: TweetScalarFieldEnum | TweetScalarFieldEnum[]
  }

  /**
   * Tweet findFirstOrThrow
   */
  export type TweetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetInclude<ExtArgs> | null
    /**
     * Filter, which Tweet to fetch.
     */
    where?: TweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tweets to fetch.
     */
    orderBy?: TweetOrderByWithRelationInput | TweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tweets.
     */
    cursor?: TweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tweets.
     */
    distinct?: TweetScalarFieldEnum | TweetScalarFieldEnum[]
  }

  /**
   * Tweet findMany
   */
  export type TweetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetInclude<ExtArgs> | null
    /**
     * Filter, which Tweets to fetch.
     */
    where?: TweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tweets to fetch.
     */
    orderBy?: TweetOrderByWithRelationInput | TweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tweets.
     */
    cursor?: TweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tweets.
     */
    skip?: number
    distinct?: TweetScalarFieldEnum | TweetScalarFieldEnum[]
  }

  /**
   * Tweet create
   */
  export type TweetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetInclude<ExtArgs> | null
    /**
     * The data needed to create a Tweet.
     */
    data: XOR<TweetCreateInput, TweetUncheckedCreateInput>
  }

  /**
   * Tweet createMany
   */
  export type TweetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tweets.
     */
    data: TweetCreateManyInput | TweetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tweet createManyAndReturn
   */
  export type TweetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * The data used to create many Tweets.
     */
    data: TweetCreateManyInput | TweetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tweet update
   */
  export type TweetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetInclude<ExtArgs> | null
    /**
     * The data needed to update a Tweet.
     */
    data: XOR<TweetUpdateInput, TweetUncheckedUpdateInput>
    /**
     * Choose, which Tweet to update.
     */
    where: TweetWhereUniqueInput
  }

  /**
   * Tweet updateMany
   */
  export type TweetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tweets.
     */
    data: XOR<TweetUpdateManyMutationInput, TweetUncheckedUpdateManyInput>
    /**
     * Filter which Tweets to update
     */
    where?: TweetWhereInput
    /**
     * Limit how many Tweets to update.
     */
    limit?: number
  }

  /**
   * Tweet updateManyAndReturn
   */
  export type TweetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * The data used to update Tweets.
     */
    data: XOR<TweetUpdateManyMutationInput, TweetUncheckedUpdateManyInput>
    /**
     * Filter which Tweets to update
     */
    where?: TweetWhereInput
    /**
     * Limit how many Tweets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tweet upsert
   */
  export type TweetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetInclude<ExtArgs> | null
    /**
     * The filter to search for the Tweet to update in case it exists.
     */
    where: TweetWhereUniqueInput
    /**
     * In case the Tweet found by the `where` argument doesn't exist, create a new Tweet with this data.
     */
    create: XOR<TweetCreateInput, TweetUncheckedCreateInput>
    /**
     * In case the Tweet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TweetUpdateInput, TweetUncheckedUpdateInput>
  }

  /**
   * Tweet delete
   */
  export type TweetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetInclude<ExtArgs> | null
    /**
     * Filter which Tweet to delete.
     */
    where: TweetWhereUniqueInput
  }

  /**
   * Tweet deleteMany
   */
  export type TweetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tweets to delete
     */
    where?: TweetWhereInput
    /**
     * Limit how many Tweets to delete.
     */
    limit?: number
  }

  /**
   * Tweet.news
   */
  export type Tweet$newsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    where?: NewsWhereInput
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    cursor?: NewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * Tweet.aiAnalysis
   */
  export type Tweet$aiAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAnalysis
     */
    select?: AiAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAnalysis
     */
    omit?: AiAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAnalysisInclude<ExtArgs> | null
    where?: AiAnalysisWhereInput
    orderBy?: AiAnalysisOrderByWithRelationInput | AiAnalysisOrderByWithRelationInput[]
    cursor?: AiAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiAnalysisScalarFieldEnum | AiAnalysisScalarFieldEnum[]
  }

  /**
   * Tweet.tweetMedia
   */
  export type Tweet$tweetMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaInclude<ExtArgs> | null
    where?: TweetMediaWhereInput
    orderBy?: TweetMediaOrderByWithRelationInput | TweetMediaOrderByWithRelationInput[]
    cursor?: TweetMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TweetMediaScalarFieldEnum | TweetMediaScalarFieldEnum[]
  }

  /**
   * Tweet without action
   */
  export type TweetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetInclude<ExtArgs> | null
  }


  /**
   * Model TweetMedia
   */

  export type AggregateTweetMedia = {
    _count: TweetMediaCountAggregateOutputType | null
    _min: TweetMediaMinAggregateOutputType | null
    _max: TweetMediaMaxAggregateOutputType | null
  }

  export type TweetMediaMinAggregateOutputType = {
    id: string | null
    tweetId: string | null
    type: $Enums.MediaType | null
    url: string | null
  }

  export type TweetMediaMaxAggregateOutputType = {
    id: string | null
    tweetId: string | null
    type: $Enums.MediaType | null
    url: string | null
  }

  export type TweetMediaCountAggregateOutputType = {
    id: number
    tweetId: number
    type: number
    url: number
    metadata: number
    _all: number
  }


  export type TweetMediaMinAggregateInputType = {
    id?: true
    tweetId?: true
    type?: true
    url?: true
  }

  export type TweetMediaMaxAggregateInputType = {
    id?: true
    tweetId?: true
    type?: true
    url?: true
  }

  export type TweetMediaCountAggregateInputType = {
    id?: true
    tweetId?: true
    type?: true
    url?: true
    metadata?: true
    _all?: true
  }

  export type TweetMediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TweetMedia to aggregate.
     */
    where?: TweetMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TweetMedias to fetch.
     */
    orderBy?: TweetMediaOrderByWithRelationInput | TweetMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TweetMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TweetMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TweetMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TweetMedias
    **/
    _count?: true | TweetMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TweetMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TweetMediaMaxAggregateInputType
  }

  export type GetTweetMediaAggregateType<T extends TweetMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateTweetMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTweetMedia[P]>
      : GetScalarType<T[P], AggregateTweetMedia[P]>
  }




  export type TweetMediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TweetMediaWhereInput
    orderBy?: TweetMediaOrderByWithAggregationInput | TweetMediaOrderByWithAggregationInput[]
    by: TweetMediaScalarFieldEnum[] | TweetMediaScalarFieldEnum
    having?: TweetMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TweetMediaCountAggregateInputType | true
    _min?: TweetMediaMinAggregateInputType
    _max?: TweetMediaMaxAggregateInputType
  }

  export type TweetMediaGroupByOutputType = {
    id: string
    tweetId: string
    type: $Enums.MediaType
    url: string
    metadata: JsonValue | null
    _count: TweetMediaCountAggregateOutputType | null
    _min: TweetMediaMinAggregateOutputType | null
    _max: TweetMediaMaxAggregateOutputType | null
  }

  type GetTweetMediaGroupByPayload<T extends TweetMediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TweetMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TweetMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TweetMediaGroupByOutputType[P]>
            : GetScalarType<T[P], TweetMediaGroupByOutputType[P]>
        }
      >
    >


  export type TweetMediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tweetId?: boolean
    type?: boolean
    url?: boolean
    metadata?: boolean
    tweet?: boolean | TweetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweetMedia"]>

  export type TweetMediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tweetId?: boolean
    type?: boolean
    url?: boolean
    metadata?: boolean
    tweet?: boolean | TweetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweetMedia"]>

  export type TweetMediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tweetId?: boolean
    type?: boolean
    url?: boolean
    metadata?: boolean
    tweet?: boolean | TweetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tweetMedia"]>

  export type TweetMediaSelectScalar = {
    id?: boolean
    tweetId?: boolean
    type?: boolean
    url?: boolean
    metadata?: boolean
  }

  export type TweetMediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tweetId" | "type" | "url" | "metadata", ExtArgs["result"]["tweetMedia"]>
  export type TweetMediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweet?: boolean | TweetDefaultArgs<ExtArgs>
  }
  export type TweetMediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweet?: boolean | TweetDefaultArgs<ExtArgs>
  }
  export type TweetMediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tweet?: boolean | TweetDefaultArgs<ExtArgs>
  }

  export type $TweetMediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TweetMedia"
    objects: {
      tweet: Prisma.$TweetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tweetId: string
      type: $Enums.MediaType
      url: string
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["tweetMedia"]>
    composites: {}
  }

  type TweetMediaGetPayload<S extends boolean | null | undefined | TweetMediaDefaultArgs> = $Result.GetResult<Prisma.$TweetMediaPayload, S>

  type TweetMediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TweetMediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TweetMediaCountAggregateInputType | true
    }

  export interface TweetMediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TweetMedia'], meta: { name: 'TweetMedia' } }
    /**
     * Find zero or one TweetMedia that matches the filter.
     * @param {TweetMediaFindUniqueArgs} args - Arguments to find a TweetMedia
     * @example
     * // Get one TweetMedia
     * const tweetMedia = await prisma.tweetMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TweetMediaFindUniqueArgs>(args: SelectSubset<T, TweetMediaFindUniqueArgs<ExtArgs>>): Prisma__TweetMediaClient<$Result.GetResult<Prisma.$TweetMediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TweetMedia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TweetMediaFindUniqueOrThrowArgs} args - Arguments to find a TweetMedia
     * @example
     * // Get one TweetMedia
     * const tweetMedia = await prisma.tweetMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TweetMediaFindUniqueOrThrowArgs>(args: SelectSubset<T, TweetMediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TweetMediaClient<$Result.GetResult<Prisma.$TweetMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TweetMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetMediaFindFirstArgs} args - Arguments to find a TweetMedia
     * @example
     * // Get one TweetMedia
     * const tweetMedia = await prisma.tweetMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TweetMediaFindFirstArgs>(args?: SelectSubset<T, TweetMediaFindFirstArgs<ExtArgs>>): Prisma__TweetMediaClient<$Result.GetResult<Prisma.$TweetMediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TweetMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetMediaFindFirstOrThrowArgs} args - Arguments to find a TweetMedia
     * @example
     * // Get one TweetMedia
     * const tweetMedia = await prisma.tweetMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TweetMediaFindFirstOrThrowArgs>(args?: SelectSubset<T, TweetMediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__TweetMediaClient<$Result.GetResult<Prisma.$TweetMediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TweetMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TweetMedias
     * const tweetMedias = await prisma.tweetMedia.findMany()
     * 
     * // Get first 10 TweetMedias
     * const tweetMedias = await prisma.tweetMedia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tweetMediaWithIdOnly = await prisma.tweetMedia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TweetMediaFindManyArgs>(args?: SelectSubset<T, TweetMediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TweetMedia.
     * @param {TweetMediaCreateArgs} args - Arguments to create a TweetMedia.
     * @example
     * // Create one TweetMedia
     * const TweetMedia = await prisma.tweetMedia.create({
     *   data: {
     *     // ... data to create a TweetMedia
     *   }
     * })
     * 
     */
    create<T extends TweetMediaCreateArgs>(args: SelectSubset<T, TweetMediaCreateArgs<ExtArgs>>): Prisma__TweetMediaClient<$Result.GetResult<Prisma.$TweetMediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TweetMedias.
     * @param {TweetMediaCreateManyArgs} args - Arguments to create many TweetMedias.
     * @example
     * // Create many TweetMedias
     * const tweetMedia = await prisma.tweetMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TweetMediaCreateManyArgs>(args?: SelectSubset<T, TweetMediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TweetMedias and returns the data saved in the database.
     * @param {TweetMediaCreateManyAndReturnArgs} args - Arguments to create many TweetMedias.
     * @example
     * // Create many TweetMedias
     * const tweetMedia = await prisma.tweetMedia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TweetMedias and only return the `id`
     * const tweetMediaWithIdOnly = await prisma.tweetMedia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TweetMediaCreateManyAndReturnArgs>(args?: SelectSubset<T, TweetMediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetMediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TweetMedia.
     * @param {TweetMediaDeleteArgs} args - Arguments to delete one TweetMedia.
     * @example
     * // Delete one TweetMedia
     * const TweetMedia = await prisma.tweetMedia.delete({
     *   where: {
     *     // ... filter to delete one TweetMedia
     *   }
     * })
     * 
     */
    delete<T extends TweetMediaDeleteArgs>(args: SelectSubset<T, TweetMediaDeleteArgs<ExtArgs>>): Prisma__TweetMediaClient<$Result.GetResult<Prisma.$TweetMediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TweetMedia.
     * @param {TweetMediaUpdateArgs} args - Arguments to update one TweetMedia.
     * @example
     * // Update one TweetMedia
     * const tweetMedia = await prisma.tweetMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TweetMediaUpdateArgs>(args: SelectSubset<T, TweetMediaUpdateArgs<ExtArgs>>): Prisma__TweetMediaClient<$Result.GetResult<Prisma.$TweetMediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TweetMedias.
     * @param {TweetMediaDeleteManyArgs} args - Arguments to filter TweetMedias to delete.
     * @example
     * // Delete a few TweetMedias
     * const { count } = await prisma.tweetMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TweetMediaDeleteManyArgs>(args?: SelectSubset<T, TweetMediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TweetMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TweetMedias
     * const tweetMedia = await prisma.tweetMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TweetMediaUpdateManyArgs>(args: SelectSubset<T, TweetMediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TweetMedias and returns the data updated in the database.
     * @param {TweetMediaUpdateManyAndReturnArgs} args - Arguments to update many TweetMedias.
     * @example
     * // Update many TweetMedias
     * const tweetMedia = await prisma.tweetMedia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TweetMedias and only return the `id`
     * const tweetMediaWithIdOnly = await prisma.tweetMedia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TweetMediaUpdateManyAndReturnArgs>(args: SelectSubset<T, TweetMediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TweetMediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TweetMedia.
     * @param {TweetMediaUpsertArgs} args - Arguments to update or create a TweetMedia.
     * @example
     * // Update or create a TweetMedia
     * const tweetMedia = await prisma.tweetMedia.upsert({
     *   create: {
     *     // ... data to create a TweetMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TweetMedia we want to update
     *   }
     * })
     */
    upsert<T extends TweetMediaUpsertArgs>(args: SelectSubset<T, TweetMediaUpsertArgs<ExtArgs>>): Prisma__TweetMediaClient<$Result.GetResult<Prisma.$TweetMediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TweetMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetMediaCountArgs} args - Arguments to filter TweetMedias to count.
     * @example
     * // Count the number of TweetMedias
     * const count = await prisma.tweetMedia.count({
     *   where: {
     *     // ... the filter for the TweetMedias we want to count
     *   }
     * })
    **/
    count<T extends TweetMediaCountArgs>(
      args?: Subset<T, TweetMediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TweetMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TweetMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TweetMediaAggregateArgs>(args: Subset<T, TweetMediaAggregateArgs>): Prisma.PrismaPromise<GetTweetMediaAggregateType<T>>

    /**
     * Group by TweetMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TweetMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TweetMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TweetMediaGroupByArgs['orderBy'] }
        : { orderBy?: TweetMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TweetMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTweetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TweetMedia model
   */
  readonly fields: TweetMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TweetMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TweetMediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tweet<T extends TweetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TweetDefaultArgs<ExtArgs>>): Prisma__TweetClient<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TweetMedia model
   */
  interface TweetMediaFieldRefs {
    readonly id: FieldRef<"TweetMedia", 'String'>
    readonly tweetId: FieldRef<"TweetMedia", 'String'>
    readonly type: FieldRef<"TweetMedia", 'MediaType'>
    readonly url: FieldRef<"TweetMedia", 'String'>
    readonly metadata: FieldRef<"TweetMedia", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * TweetMedia findUnique
   */
  export type TweetMediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaInclude<ExtArgs> | null
    /**
     * Filter, which TweetMedia to fetch.
     */
    where: TweetMediaWhereUniqueInput
  }

  /**
   * TweetMedia findUniqueOrThrow
   */
  export type TweetMediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaInclude<ExtArgs> | null
    /**
     * Filter, which TweetMedia to fetch.
     */
    where: TweetMediaWhereUniqueInput
  }

  /**
   * TweetMedia findFirst
   */
  export type TweetMediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaInclude<ExtArgs> | null
    /**
     * Filter, which TweetMedia to fetch.
     */
    where?: TweetMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TweetMedias to fetch.
     */
    orderBy?: TweetMediaOrderByWithRelationInput | TweetMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TweetMedias.
     */
    cursor?: TweetMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TweetMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TweetMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TweetMedias.
     */
    distinct?: TweetMediaScalarFieldEnum | TweetMediaScalarFieldEnum[]
  }

  /**
   * TweetMedia findFirstOrThrow
   */
  export type TweetMediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaInclude<ExtArgs> | null
    /**
     * Filter, which TweetMedia to fetch.
     */
    where?: TweetMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TweetMedias to fetch.
     */
    orderBy?: TweetMediaOrderByWithRelationInput | TweetMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TweetMedias.
     */
    cursor?: TweetMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TweetMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TweetMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TweetMedias.
     */
    distinct?: TweetMediaScalarFieldEnum | TweetMediaScalarFieldEnum[]
  }

  /**
   * TweetMedia findMany
   */
  export type TweetMediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaInclude<ExtArgs> | null
    /**
     * Filter, which TweetMedias to fetch.
     */
    where?: TweetMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TweetMedias to fetch.
     */
    orderBy?: TweetMediaOrderByWithRelationInput | TweetMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TweetMedias.
     */
    cursor?: TweetMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TweetMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TweetMedias.
     */
    skip?: number
    distinct?: TweetMediaScalarFieldEnum | TweetMediaScalarFieldEnum[]
  }

  /**
   * TweetMedia create
   */
  export type TweetMediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaInclude<ExtArgs> | null
    /**
     * The data needed to create a TweetMedia.
     */
    data: XOR<TweetMediaCreateInput, TweetMediaUncheckedCreateInput>
  }

  /**
   * TweetMedia createMany
   */
  export type TweetMediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TweetMedias.
     */
    data: TweetMediaCreateManyInput | TweetMediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TweetMedia createManyAndReturn
   */
  export type TweetMediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * The data used to create many TweetMedias.
     */
    data: TweetMediaCreateManyInput | TweetMediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TweetMedia update
   */
  export type TweetMediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaInclude<ExtArgs> | null
    /**
     * The data needed to update a TweetMedia.
     */
    data: XOR<TweetMediaUpdateInput, TweetMediaUncheckedUpdateInput>
    /**
     * Choose, which TweetMedia to update.
     */
    where: TweetMediaWhereUniqueInput
  }

  /**
   * TweetMedia updateMany
   */
  export type TweetMediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TweetMedias.
     */
    data: XOR<TweetMediaUpdateManyMutationInput, TweetMediaUncheckedUpdateManyInput>
    /**
     * Filter which TweetMedias to update
     */
    where?: TweetMediaWhereInput
    /**
     * Limit how many TweetMedias to update.
     */
    limit?: number
  }

  /**
   * TweetMedia updateManyAndReturn
   */
  export type TweetMediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * The data used to update TweetMedias.
     */
    data: XOR<TweetMediaUpdateManyMutationInput, TweetMediaUncheckedUpdateManyInput>
    /**
     * Filter which TweetMedias to update
     */
    where?: TweetMediaWhereInput
    /**
     * Limit how many TweetMedias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TweetMedia upsert
   */
  export type TweetMediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaInclude<ExtArgs> | null
    /**
     * The filter to search for the TweetMedia to update in case it exists.
     */
    where: TweetMediaWhereUniqueInput
    /**
     * In case the TweetMedia found by the `where` argument doesn't exist, create a new TweetMedia with this data.
     */
    create: XOR<TweetMediaCreateInput, TweetMediaUncheckedCreateInput>
    /**
     * In case the TweetMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TweetMediaUpdateInput, TweetMediaUncheckedUpdateInput>
  }

  /**
   * TweetMedia delete
   */
  export type TweetMediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaInclude<ExtArgs> | null
    /**
     * Filter which TweetMedia to delete.
     */
    where: TweetMediaWhereUniqueInput
  }

  /**
   * TweetMedia deleteMany
   */
  export type TweetMediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TweetMedias to delete
     */
    where?: TweetMediaWhereInput
    /**
     * Limit how many TweetMedias to delete.
     */
    limit?: number
  }

  /**
   * TweetMedia without action
   */
  export type TweetMediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TweetMedia
     */
    select?: TweetMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TweetMedia
     */
    omit?: TweetMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetMediaInclude<ExtArgs> | null
  }


  /**
   * Model News
   */

  export type AggregateNews = {
    _count: NewsCountAggregateOutputType | null
    _min: NewsMinAggregateOutputType | null
    _max: NewsMaxAggregateOutputType | null
  }

  export type NewsMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    tweetId: string | null
    mediaSourceId: string | null
    title: string | null
    content: string | null
    url: string | null
    extractedAt: Date | null
    contentHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    tweetId: string | null
    mediaSourceId: string | null
    title: string | null
    content: string | null
    url: string | null
    extractedAt: Date | null
    contentHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsCountAggregateOutputType = {
    id: number
    tenantId: number
    tweetId: number
    mediaSourceId: number
    title: number
    content: number
    url: number
    extractedAt: number
    contentHash: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NewsMinAggregateInputType = {
    id?: true
    tenantId?: true
    tweetId?: true
    mediaSourceId?: true
    title?: true
    content?: true
    url?: true
    extractedAt?: true
    contentHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsMaxAggregateInputType = {
    id?: true
    tenantId?: true
    tweetId?: true
    mediaSourceId?: true
    title?: true
    content?: true
    url?: true
    extractedAt?: true
    contentHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsCountAggregateInputType = {
    id?: true
    tenantId?: true
    tweetId?: true
    mediaSourceId?: true
    title?: true
    content?: true
    url?: true
    extractedAt?: true
    contentHash?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which News to aggregate.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned News
    **/
    _count?: true | NewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsMaxAggregateInputType
  }

  export type GetNewsAggregateType<T extends NewsAggregateArgs> = {
        [P in keyof T & keyof AggregateNews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNews[P]>
      : GetScalarType<T[P], AggregateNews[P]>
  }




  export type NewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsWhereInput
    orderBy?: NewsOrderByWithAggregationInput | NewsOrderByWithAggregationInput[]
    by: NewsScalarFieldEnum[] | NewsScalarFieldEnum
    having?: NewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsCountAggregateInputType | true
    _min?: NewsMinAggregateInputType
    _max?: NewsMaxAggregateInputType
  }

  export type NewsGroupByOutputType = {
    id: string
    tenantId: string
    tweetId: string
    mediaSourceId: string
    title: string | null
    content: string | null
    url: string | null
    extractedAt: Date
    contentHash: string
    createdAt: Date
    updatedAt: Date
    _count: NewsCountAggregateOutputType | null
    _min: NewsMinAggregateOutputType | null
    _max: NewsMaxAggregateOutputType | null
  }

  type GetNewsGroupByPayload<T extends NewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsGroupByOutputType[P]>
            : GetScalarType<T[P], NewsGroupByOutputType[P]>
        }
      >
    >


  export type NewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    tweetId?: boolean
    mediaSourceId?: boolean
    title?: boolean
    content?: boolean
    url?: boolean
    extractedAt?: boolean
    contentHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    tweet?: boolean | TweetDefaultArgs<ExtArgs>
    mediaSource?: boolean | MediaSourceDefaultArgs<ExtArgs>
    aiAnalysis?: boolean | News$aiAnalysisArgs<ExtArgs>
    _count?: boolean | NewsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["news"]>

  export type NewsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    tweetId?: boolean
    mediaSourceId?: boolean
    title?: boolean
    content?: boolean
    url?: boolean
    extractedAt?: boolean
    contentHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    tweet?: boolean | TweetDefaultArgs<ExtArgs>
    mediaSource?: boolean | MediaSourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["news"]>

  export type NewsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    tweetId?: boolean
    mediaSourceId?: boolean
    title?: boolean
    content?: boolean
    url?: boolean
    extractedAt?: boolean
    contentHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    tweet?: boolean | TweetDefaultArgs<ExtArgs>
    mediaSource?: boolean | MediaSourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["news"]>

  export type NewsSelectScalar = {
    id?: boolean
    tenantId?: boolean
    tweetId?: boolean
    mediaSourceId?: boolean
    title?: boolean
    content?: boolean
    url?: boolean
    extractedAt?: boolean
    contentHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NewsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "tweetId" | "mediaSourceId" | "title" | "content" | "url" | "extractedAt" | "contentHash" | "createdAt" | "updatedAt", ExtArgs["result"]["news"]>
  export type NewsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    tweet?: boolean | TweetDefaultArgs<ExtArgs>
    mediaSource?: boolean | MediaSourceDefaultArgs<ExtArgs>
    aiAnalysis?: boolean | News$aiAnalysisArgs<ExtArgs>
    _count?: boolean | NewsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NewsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    tweet?: boolean | TweetDefaultArgs<ExtArgs>
    mediaSource?: boolean | MediaSourceDefaultArgs<ExtArgs>
  }
  export type NewsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    tweet?: boolean | TweetDefaultArgs<ExtArgs>
    mediaSource?: boolean | MediaSourceDefaultArgs<ExtArgs>
  }

  export type $NewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "News"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      tweet: Prisma.$TweetPayload<ExtArgs>
      mediaSource: Prisma.$MediaSourcePayload<ExtArgs>
      aiAnalysis: Prisma.$AiAnalysisPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      tweetId: string
      mediaSourceId: string
      title: string | null
      content: string | null
      url: string | null
      extractedAt: Date
      contentHash: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["news"]>
    composites: {}
  }

  type NewsGetPayload<S extends boolean | null | undefined | NewsDefaultArgs> = $Result.GetResult<Prisma.$NewsPayload, S>

  type NewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NewsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NewsCountAggregateInputType | true
    }

  export interface NewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['News'], meta: { name: 'News' } }
    /**
     * Find zero or one News that matches the filter.
     * @param {NewsFindUniqueArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsFindUniqueArgs>(args: SelectSubset<T, NewsFindUniqueArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one News that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NewsFindUniqueOrThrowArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first News that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindFirstArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsFindFirstArgs>(args?: SelectSubset<T, NewsFindFirstArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first News that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindFirstOrThrowArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more News that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all News
     * const news = await prisma.news.findMany()
     * 
     * // Get first 10 News
     * const news = await prisma.news.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsWithIdOnly = await prisma.news.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsFindManyArgs>(args?: SelectSubset<T, NewsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a News.
     * @param {NewsCreateArgs} args - Arguments to create a News.
     * @example
     * // Create one News
     * const News = await prisma.news.create({
     *   data: {
     *     // ... data to create a News
     *   }
     * })
     * 
     */
    create<T extends NewsCreateArgs>(args: SelectSubset<T, NewsCreateArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many News.
     * @param {NewsCreateManyArgs} args - Arguments to create many News.
     * @example
     * // Create many News
     * const news = await prisma.news.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsCreateManyArgs>(args?: SelectSubset<T, NewsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many News and returns the data saved in the database.
     * @param {NewsCreateManyAndReturnArgs} args - Arguments to create many News.
     * @example
     * // Create many News
     * const news = await prisma.news.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many News and only return the `id`
     * const newsWithIdOnly = await prisma.news.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a News.
     * @param {NewsDeleteArgs} args - Arguments to delete one News.
     * @example
     * // Delete one News
     * const News = await prisma.news.delete({
     *   where: {
     *     // ... filter to delete one News
     *   }
     * })
     * 
     */
    delete<T extends NewsDeleteArgs>(args: SelectSubset<T, NewsDeleteArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one News.
     * @param {NewsUpdateArgs} args - Arguments to update one News.
     * @example
     * // Update one News
     * const news = await prisma.news.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsUpdateArgs>(args: SelectSubset<T, NewsUpdateArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more News.
     * @param {NewsDeleteManyArgs} args - Arguments to filter News to delete.
     * @example
     * // Delete a few News
     * const { count } = await prisma.news.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsDeleteManyArgs>(args?: SelectSubset<T, NewsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many News
     * const news = await prisma.news.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsUpdateManyArgs>(args: SelectSubset<T, NewsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more News and returns the data updated in the database.
     * @param {NewsUpdateManyAndReturnArgs} args - Arguments to update many News.
     * @example
     * // Update many News
     * const news = await prisma.news.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more News and only return the `id`
     * const newsWithIdOnly = await prisma.news.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NewsUpdateManyAndReturnArgs>(args: SelectSubset<T, NewsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one News.
     * @param {NewsUpsertArgs} args - Arguments to update or create a News.
     * @example
     * // Update or create a News
     * const news = await prisma.news.upsert({
     *   create: {
     *     // ... data to create a News
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the News we want to update
     *   }
     * })
     */
    upsert<T extends NewsUpsertArgs>(args: SelectSubset<T, NewsUpsertArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsCountArgs} args - Arguments to filter News to count.
     * @example
     * // Count the number of News
     * const count = await prisma.news.count({
     *   where: {
     *     // ... the filter for the News we want to count
     *   }
     * })
    **/
    count<T extends NewsCountArgs>(
      args?: Subset<T, NewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsAggregateArgs>(args: Subset<T, NewsAggregateArgs>): Prisma.PrismaPromise<GetNewsAggregateType<T>>

    /**
     * Group by News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsGroupByArgs['orderBy'] }
        : { orderBy?: NewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the News model
   */
  readonly fields: NewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for News.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tweet<T extends TweetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TweetDefaultArgs<ExtArgs>>): Prisma__TweetClient<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mediaSource<T extends MediaSourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MediaSourceDefaultArgs<ExtArgs>>): Prisma__MediaSourceClient<$Result.GetResult<Prisma.$MediaSourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    aiAnalysis<T extends News$aiAnalysisArgs<ExtArgs> = {}>(args?: Subset<T, News$aiAnalysisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the News model
   */
  interface NewsFieldRefs {
    readonly id: FieldRef<"News", 'String'>
    readonly tenantId: FieldRef<"News", 'String'>
    readonly tweetId: FieldRef<"News", 'String'>
    readonly mediaSourceId: FieldRef<"News", 'String'>
    readonly title: FieldRef<"News", 'String'>
    readonly content: FieldRef<"News", 'String'>
    readonly url: FieldRef<"News", 'String'>
    readonly extractedAt: FieldRef<"News", 'DateTime'>
    readonly contentHash: FieldRef<"News", 'String'>
    readonly createdAt: FieldRef<"News", 'DateTime'>
    readonly updatedAt: FieldRef<"News", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * News findUnique
   */
  export type NewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News findUniqueOrThrow
   */
  export type NewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News findFirst
   */
  export type NewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of News.
     */
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * News findFirstOrThrow
   */
  export type NewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of News.
     */
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * News findMany
   */
  export type NewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * News create
   */
  export type NewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * The data needed to create a News.
     */
    data: XOR<NewsCreateInput, NewsUncheckedCreateInput>
  }

  /**
   * News createMany
   */
  export type NewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many News.
     */
    data: NewsCreateManyInput | NewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * News createManyAndReturn
   */
  export type NewsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * The data used to create many News.
     */
    data: NewsCreateManyInput | NewsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * News update
   */
  export type NewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * The data needed to update a News.
     */
    data: XOR<NewsUpdateInput, NewsUncheckedUpdateInput>
    /**
     * Choose, which News to update.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News updateMany
   */
  export type NewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update News.
     */
    data: XOR<NewsUpdateManyMutationInput, NewsUncheckedUpdateManyInput>
    /**
     * Filter which News to update
     */
    where?: NewsWhereInput
    /**
     * Limit how many News to update.
     */
    limit?: number
  }

  /**
   * News updateManyAndReturn
   */
  export type NewsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * The data used to update News.
     */
    data: XOR<NewsUpdateManyMutationInput, NewsUncheckedUpdateManyInput>
    /**
     * Filter which News to update
     */
    where?: NewsWhereInput
    /**
     * Limit how many News to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * News upsert
   */
  export type NewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * The filter to search for the News to update in case it exists.
     */
    where: NewsWhereUniqueInput
    /**
     * In case the News found by the `where` argument doesn't exist, create a new News with this data.
     */
    create: XOR<NewsCreateInput, NewsUncheckedCreateInput>
    /**
     * In case the News was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsUpdateInput, NewsUncheckedUpdateInput>
  }

  /**
   * News delete
   */
  export type NewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    /**
     * Filter which News to delete.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News deleteMany
   */
  export type NewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which News to delete
     */
    where?: NewsWhereInput
    /**
     * Limit how many News to delete.
     */
    limit?: number
  }

  /**
   * News.aiAnalysis
   */
  export type News$aiAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAnalysis
     */
    select?: AiAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAnalysis
     */
    omit?: AiAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAnalysisInclude<ExtArgs> | null
    where?: AiAnalysisWhereInput
    orderBy?: AiAnalysisOrderByWithRelationInput | AiAnalysisOrderByWithRelationInput[]
    cursor?: AiAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiAnalysisScalarFieldEnum | AiAnalysisScalarFieldEnum[]
  }

  /**
   * News without action
   */
  export type NewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
  }


  /**
   * Model AiAnalysis
   */

  export type AggregateAiAnalysis = {
    _count: AiAnalysisCountAggregateOutputType | null
    _avg: AiAnalysisAvgAggregateOutputType | null
    _sum: AiAnalysisSumAggregateOutputType | null
    _min: AiAnalysisMinAggregateOutputType | null
    _max: AiAnalysisMaxAggregateOutputType | null
  }

  export type AiAnalysisAvgAggregateOutputType = {
    relevance: number | null
  }

  export type AiAnalysisSumAggregateOutputType = {
    relevance: number | null
  }

  export type AiAnalysisMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    tweetId: string | null
    newsId: string | null
    type: $Enums.AnalysisType | null
    prompt: string | null
    sentiment: string | null
    relevance: number | null
    threatLevel: $Enums.ThreatLevel | null
    processedAt: Date | null
    createdAt: Date | null
  }

  export type AiAnalysisMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    tweetId: string | null
    newsId: string | null
    type: $Enums.AnalysisType | null
    prompt: string | null
    sentiment: string | null
    relevance: number | null
    threatLevel: $Enums.ThreatLevel | null
    processedAt: Date | null
    createdAt: Date | null
  }

  export type AiAnalysisCountAggregateOutputType = {
    id: number
    tenantId: number
    tweetId: number
    newsId: number
    type: number
    prompt: number
    response: number
    sentiment: number
    relevance: number
    threatLevel: number
    tags: number
    processedAt: number
    createdAt: number
    _all: number
  }


  export type AiAnalysisAvgAggregateInputType = {
    relevance?: true
  }

  export type AiAnalysisSumAggregateInputType = {
    relevance?: true
  }

  export type AiAnalysisMinAggregateInputType = {
    id?: true
    tenantId?: true
    tweetId?: true
    newsId?: true
    type?: true
    prompt?: true
    sentiment?: true
    relevance?: true
    threatLevel?: true
    processedAt?: true
    createdAt?: true
  }

  export type AiAnalysisMaxAggregateInputType = {
    id?: true
    tenantId?: true
    tweetId?: true
    newsId?: true
    type?: true
    prompt?: true
    sentiment?: true
    relevance?: true
    threatLevel?: true
    processedAt?: true
    createdAt?: true
  }

  export type AiAnalysisCountAggregateInputType = {
    id?: true
    tenantId?: true
    tweetId?: true
    newsId?: true
    type?: true
    prompt?: true
    response?: true
    sentiment?: true
    relevance?: true
    threatLevel?: true
    tags?: true
    processedAt?: true
    createdAt?: true
    _all?: true
  }

  export type AiAnalysisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiAnalysis to aggregate.
     */
    where?: AiAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiAnalyses to fetch.
     */
    orderBy?: AiAnalysisOrderByWithRelationInput | AiAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiAnalyses
    **/
    _count?: true | AiAnalysisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiAnalysisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiAnalysisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiAnalysisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiAnalysisMaxAggregateInputType
  }

  export type GetAiAnalysisAggregateType<T extends AiAnalysisAggregateArgs> = {
        [P in keyof T & keyof AggregateAiAnalysis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiAnalysis[P]>
      : GetScalarType<T[P], AggregateAiAnalysis[P]>
  }




  export type AiAnalysisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiAnalysisWhereInput
    orderBy?: AiAnalysisOrderByWithAggregationInput | AiAnalysisOrderByWithAggregationInput[]
    by: AiAnalysisScalarFieldEnum[] | AiAnalysisScalarFieldEnum
    having?: AiAnalysisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiAnalysisCountAggregateInputType | true
    _avg?: AiAnalysisAvgAggregateInputType
    _sum?: AiAnalysisSumAggregateInputType
    _min?: AiAnalysisMinAggregateInputType
    _max?: AiAnalysisMaxAggregateInputType
  }

  export type AiAnalysisGroupByOutputType = {
    id: string
    tenantId: string
    tweetId: string | null
    newsId: string | null
    type: $Enums.AnalysisType
    prompt: string
    response: JsonValue
    sentiment: string | null
    relevance: number | null
    threatLevel: $Enums.ThreatLevel | null
    tags: string[]
    processedAt: Date
    createdAt: Date
    _count: AiAnalysisCountAggregateOutputType | null
    _avg: AiAnalysisAvgAggregateOutputType | null
    _sum: AiAnalysisSumAggregateOutputType | null
    _min: AiAnalysisMinAggregateOutputType | null
    _max: AiAnalysisMaxAggregateOutputType | null
  }

  type GetAiAnalysisGroupByPayload<T extends AiAnalysisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiAnalysisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiAnalysisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiAnalysisGroupByOutputType[P]>
            : GetScalarType<T[P], AiAnalysisGroupByOutputType[P]>
        }
      >
    >


  export type AiAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    tweetId?: boolean
    newsId?: boolean
    type?: boolean
    prompt?: boolean
    response?: boolean
    sentiment?: boolean
    relevance?: boolean
    threatLevel?: boolean
    tags?: boolean
    processedAt?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    tweet?: boolean | AiAnalysis$tweetArgs<ExtArgs>
    news?: boolean | AiAnalysis$newsArgs<ExtArgs>
  }, ExtArgs["result"]["aiAnalysis"]>

  export type AiAnalysisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    tweetId?: boolean
    newsId?: boolean
    type?: boolean
    prompt?: boolean
    response?: boolean
    sentiment?: boolean
    relevance?: boolean
    threatLevel?: boolean
    tags?: boolean
    processedAt?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    tweet?: boolean | AiAnalysis$tweetArgs<ExtArgs>
    news?: boolean | AiAnalysis$newsArgs<ExtArgs>
  }, ExtArgs["result"]["aiAnalysis"]>

  export type AiAnalysisSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    tweetId?: boolean
    newsId?: boolean
    type?: boolean
    prompt?: boolean
    response?: boolean
    sentiment?: boolean
    relevance?: boolean
    threatLevel?: boolean
    tags?: boolean
    processedAt?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    tweet?: boolean | AiAnalysis$tweetArgs<ExtArgs>
    news?: boolean | AiAnalysis$newsArgs<ExtArgs>
  }, ExtArgs["result"]["aiAnalysis"]>

  export type AiAnalysisSelectScalar = {
    id?: boolean
    tenantId?: boolean
    tweetId?: boolean
    newsId?: boolean
    type?: boolean
    prompt?: boolean
    response?: boolean
    sentiment?: boolean
    relevance?: boolean
    threatLevel?: boolean
    tags?: boolean
    processedAt?: boolean
    createdAt?: boolean
  }

  export type AiAnalysisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "tweetId" | "newsId" | "type" | "prompt" | "response" | "sentiment" | "relevance" | "threatLevel" | "tags" | "processedAt" | "createdAt", ExtArgs["result"]["aiAnalysis"]>
  export type AiAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    tweet?: boolean | AiAnalysis$tweetArgs<ExtArgs>
    news?: boolean | AiAnalysis$newsArgs<ExtArgs>
  }
  export type AiAnalysisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    tweet?: boolean | AiAnalysis$tweetArgs<ExtArgs>
    news?: boolean | AiAnalysis$newsArgs<ExtArgs>
  }
  export type AiAnalysisIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    tweet?: boolean | AiAnalysis$tweetArgs<ExtArgs>
    news?: boolean | AiAnalysis$newsArgs<ExtArgs>
  }

  export type $AiAnalysisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiAnalysis"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      tweet: Prisma.$TweetPayload<ExtArgs> | null
      news: Prisma.$NewsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      tweetId: string | null
      newsId: string | null
      type: $Enums.AnalysisType
      prompt: string
      response: Prisma.JsonValue
      sentiment: string | null
      relevance: number | null
      threatLevel: $Enums.ThreatLevel | null
      tags: string[]
      processedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["aiAnalysis"]>
    composites: {}
  }

  type AiAnalysisGetPayload<S extends boolean | null | undefined | AiAnalysisDefaultArgs> = $Result.GetResult<Prisma.$AiAnalysisPayload, S>

  type AiAnalysisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiAnalysisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiAnalysisCountAggregateInputType | true
    }

  export interface AiAnalysisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiAnalysis'], meta: { name: 'AiAnalysis' } }
    /**
     * Find zero or one AiAnalysis that matches the filter.
     * @param {AiAnalysisFindUniqueArgs} args - Arguments to find a AiAnalysis
     * @example
     * // Get one AiAnalysis
     * const aiAnalysis = await prisma.aiAnalysis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiAnalysisFindUniqueArgs>(args: SelectSubset<T, AiAnalysisFindUniqueArgs<ExtArgs>>): Prisma__AiAnalysisClient<$Result.GetResult<Prisma.$AiAnalysisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiAnalysis that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiAnalysisFindUniqueOrThrowArgs} args - Arguments to find a AiAnalysis
     * @example
     * // Get one AiAnalysis
     * const aiAnalysis = await prisma.aiAnalysis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiAnalysisFindUniqueOrThrowArgs>(args: SelectSubset<T, AiAnalysisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiAnalysisClient<$Result.GetResult<Prisma.$AiAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiAnalysis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAnalysisFindFirstArgs} args - Arguments to find a AiAnalysis
     * @example
     * // Get one AiAnalysis
     * const aiAnalysis = await prisma.aiAnalysis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiAnalysisFindFirstArgs>(args?: SelectSubset<T, AiAnalysisFindFirstArgs<ExtArgs>>): Prisma__AiAnalysisClient<$Result.GetResult<Prisma.$AiAnalysisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiAnalysis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAnalysisFindFirstOrThrowArgs} args - Arguments to find a AiAnalysis
     * @example
     * // Get one AiAnalysis
     * const aiAnalysis = await prisma.aiAnalysis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiAnalysisFindFirstOrThrowArgs>(args?: SelectSubset<T, AiAnalysisFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiAnalysisClient<$Result.GetResult<Prisma.$AiAnalysisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiAnalyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAnalysisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiAnalyses
     * const aiAnalyses = await prisma.aiAnalysis.findMany()
     * 
     * // Get first 10 AiAnalyses
     * const aiAnalyses = await prisma.aiAnalysis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiAnalysisWithIdOnly = await prisma.aiAnalysis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiAnalysisFindManyArgs>(args?: SelectSubset<T, AiAnalysisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiAnalysis.
     * @param {AiAnalysisCreateArgs} args - Arguments to create a AiAnalysis.
     * @example
     * // Create one AiAnalysis
     * const AiAnalysis = await prisma.aiAnalysis.create({
     *   data: {
     *     // ... data to create a AiAnalysis
     *   }
     * })
     * 
     */
    create<T extends AiAnalysisCreateArgs>(args: SelectSubset<T, AiAnalysisCreateArgs<ExtArgs>>): Prisma__AiAnalysisClient<$Result.GetResult<Prisma.$AiAnalysisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiAnalyses.
     * @param {AiAnalysisCreateManyArgs} args - Arguments to create many AiAnalyses.
     * @example
     * // Create many AiAnalyses
     * const aiAnalysis = await prisma.aiAnalysis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiAnalysisCreateManyArgs>(args?: SelectSubset<T, AiAnalysisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiAnalyses and returns the data saved in the database.
     * @param {AiAnalysisCreateManyAndReturnArgs} args - Arguments to create many AiAnalyses.
     * @example
     * // Create many AiAnalyses
     * const aiAnalysis = await prisma.aiAnalysis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiAnalyses and only return the `id`
     * const aiAnalysisWithIdOnly = await prisma.aiAnalysis.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiAnalysisCreateManyAndReturnArgs>(args?: SelectSubset<T, AiAnalysisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiAnalysisPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiAnalysis.
     * @param {AiAnalysisDeleteArgs} args - Arguments to delete one AiAnalysis.
     * @example
     * // Delete one AiAnalysis
     * const AiAnalysis = await prisma.aiAnalysis.delete({
     *   where: {
     *     // ... filter to delete one AiAnalysis
     *   }
     * })
     * 
     */
    delete<T extends AiAnalysisDeleteArgs>(args: SelectSubset<T, AiAnalysisDeleteArgs<ExtArgs>>): Prisma__AiAnalysisClient<$Result.GetResult<Prisma.$AiAnalysisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiAnalysis.
     * @param {AiAnalysisUpdateArgs} args - Arguments to update one AiAnalysis.
     * @example
     * // Update one AiAnalysis
     * const aiAnalysis = await prisma.aiAnalysis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiAnalysisUpdateArgs>(args: SelectSubset<T, AiAnalysisUpdateArgs<ExtArgs>>): Prisma__AiAnalysisClient<$Result.GetResult<Prisma.$AiAnalysisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiAnalyses.
     * @param {AiAnalysisDeleteManyArgs} args - Arguments to filter AiAnalyses to delete.
     * @example
     * // Delete a few AiAnalyses
     * const { count } = await prisma.aiAnalysis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiAnalysisDeleteManyArgs>(args?: SelectSubset<T, AiAnalysisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAnalysisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiAnalyses
     * const aiAnalysis = await prisma.aiAnalysis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiAnalysisUpdateManyArgs>(args: SelectSubset<T, AiAnalysisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiAnalyses and returns the data updated in the database.
     * @param {AiAnalysisUpdateManyAndReturnArgs} args - Arguments to update many AiAnalyses.
     * @example
     * // Update many AiAnalyses
     * const aiAnalysis = await prisma.aiAnalysis.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiAnalyses and only return the `id`
     * const aiAnalysisWithIdOnly = await prisma.aiAnalysis.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiAnalysisUpdateManyAndReturnArgs>(args: SelectSubset<T, AiAnalysisUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiAnalysisPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiAnalysis.
     * @param {AiAnalysisUpsertArgs} args - Arguments to update or create a AiAnalysis.
     * @example
     * // Update or create a AiAnalysis
     * const aiAnalysis = await prisma.aiAnalysis.upsert({
     *   create: {
     *     // ... data to create a AiAnalysis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiAnalysis we want to update
     *   }
     * })
     */
    upsert<T extends AiAnalysisUpsertArgs>(args: SelectSubset<T, AiAnalysisUpsertArgs<ExtArgs>>): Prisma__AiAnalysisClient<$Result.GetResult<Prisma.$AiAnalysisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAnalysisCountArgs} args - Arguments to filter AiAnalyses to count.
     * @example
     * // Count the number of AiAnalyses
     * const count = await prisma.aiAnalysis.count({
     *   where: {
     *     // ... the filter for the AiAnalyses we want to count
     *   }
     * })
    **/
    count<T extends AiAnalysisCountArgs>(
      args?: Subset<T, AiAnalysisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiAnalysisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAnalysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiAnalysisAggregateArgs>(args: Subset<T, AiAnalysisAggregateArgs>): Prisma.PrismaPromise<GetAiAnalysisAggregateType<T>>

    /**
     * Group by AiAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAnalysisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiAnalysisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiAnalysisGroupByArgs['orderBy'] }
        : { orderBy?: AiAnalysisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiAnalysisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiAnalysisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiAnalysis model
   */
  readonly fields: AiAnalysisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiAnalysis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiAnalysisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tweet<T extends AiAnalysis$tweetArgs<ExtArgs> = {}>(args?: Subset<T, AiAnalysis$tweetArgs<ExtArgs>>): Prisma__TweetClient<$Result.GetResult<Prisma.$TweetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    news<T extends AiAnalysis$newsArgs<ExtArgs> = {}>(args?: Subset<T, AiAnalysis$newsArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiAnalysis model
   */
  interface AiAnalysisFieldRefs {
    readonly id: FieldRef<"AiAnalysis", 'String'>
    readonly tenantId: FieldRef<"AiAnalysis", 'String'>
    readonly tweetId: FieldRef<"AiAnalysis", 'String'>
    readonly newsId: FieldRef<"AiAnalysis", 'String'>
    readonly type: FieldRef<"AiAnalysis", 'AnalysisType'>
    readonly prompt: FieldRef<"AiAnalysis", 'String'>
    readonly response: FieldRef<"AiAnalysis", 'Json'>
    readonly sentiment: FieldRef<"AiAnalysis", 'String'>
    readonly relevance: FieldRef<"AiAnalysis", 'Float'>
    readonly threatLevel: FieldRef<"AiAnalysis", 'ThreatLevel'>
    readonly tags: FieldRef<"AiAnalysis", 'String[]'>
    readonly processedAt: FieldRef<"AiAnalysis", 'DateTime'>
    readonly createdAt: FieldRef<"AiAnalysis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiAnalysis findUnique
   */
  export type AiAnalysisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAnalysis
     */
    select?: AiAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAnalysis
     */
    omit?: AiAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which AiAnalysis to fetch.
     */
    where: AiAnalysisWhereUniqueInput
  }

  /**
   * AiAnalysis findUniqueOrThrow
   */
  export type AiAnalysisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAnalysis
     */
    select?: AiAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAnalysis
     */
    omit?: AiAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which AiAnalysis to fetch.
     */
    where: AiAnalysisWhereUniqueInput
  }

  /**
   * AiAnalysis findFirst
   */
  export type AiAnalysisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAnalysis
     */
    select?: AiAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAnalysis
     */
    omit?: AiAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which AiAnalysis to fetch.
     */
    where?: AiAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiAnalyses to fetch.
     */
    orderBy?: AiAnalysisOrderByWithRelationInput | AiAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiAnalyses.
     */
    cursor?: AiAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiAnalyses.
     */
    distinct?: AiAnalysisScalarFieldEnum | AiAnalysisScalarFieldEnum[]
  }

  /**
   * AiAnalysis findFirstOrThrow
   */
  export type AiAnalysisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAnalysis
     */
    select?: AiAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAnalysis
     */
    omit?: AiAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which AiAnalysis to fetch.
     */
    where?: AiAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiAnalyses to fetch.
     */
    orderBy?: AiAnalysisOrderByWithRelationInput | AiAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiAnalyses.
     */
    cursor?: AiAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiAnalyses.
     */
    distinct?: AiAnalysisScalarFieldEnum | AiAnalysisScalarFieldEnum[]
  }

  /**
   * AiAnalysis findMany
   */
  export type AiAnalysisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAnalysis
     */
    select?: AiAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAnalysis
     */
    omit?: AiAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which AiAnalyses to fetch.
     */
    where?: AiAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiAnalyses to fetch.
     */
    orderBy?: AiAnalysisOrderByWithRelationInput | AiAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiAnalyses.
     */
    cursor?: AiAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiAnalyses.
     */
    skip?: number
    distinct?: AiAnalysisScalarFieldEnum | AiAnalysisScalarFieldEnum[]
  }

  /**
   * AiAnalysis create
   */
  export type AiAnalysisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAnalysis
     */
    select?: AiAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAnalysis
     */
    omit?: AiAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to create a AiAnalysis.
     */
    data: XOR<AiAnalysisCreateInput, AiAnalysisUncheckedCreateInput>
  }

  /**
   * AiAnalysis createMany
   */
  export type AiAnalysisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiAnalyses.
     */
    data: AiAnalysisCreateManyInput | AiAnalysisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiAnalysis createManyAndReturn
   */
  export type AiAnalysisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAnalysis
     */
    select?: AiAnalysisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiAnalysis
     */
    omit?: AiAnalysisOmit<ExtArgs> | null
    /**
     * The data used to create many AiAnalyses.
     */
    data: AiAnalysisCreateManyInput | AiAnalysisCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAnalysisIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiAnalysis update
   */
  export type AiAnalysisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAnalysis
     */
    select?: AiAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAnalysis
     */
    omit?: AiAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to update a AiAnalysis.
     */
    data: XOR<AiAnalysisUpdateInput, AiAnalysisUncheckedUpdateInput>
    /**
     * Choose, which AiAnalysis to update.
     */
    where: AiAnalysisWhereUniqueInput
  }

  /**
   * AiAnalysis updateMany
   */
  export type AiAnalysisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiAnalyses.
     */
    data: XOR<AiAnalysisUpdateManyMutationInput, AiAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which AiAnalyses to update
     */
    where?: AiAnalysisWhereInput
    /**
     * Limit how many AiAnalyses to update.
     */
    limit?: number
  }

  /**
   * AiAnalysis updateManyAndReturn
   */
  export type AiAnalysisUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAnalysis
     */
    select?: AiAnalysisSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiAnalysis
     */
    omit?: AiAnalysisOmit<ExtArgs> | null
    /**
     * The data used to update AiAnalyses.
     */
    data: XOR<AiAnalysisUpdateManyMutationInput, AiAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which AiAnalyses to update
     */
    where?: AiAnalysisWhereInput
    /**
     * Limit how many AiAnalyses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAnalysisIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiAnalysis upsert
   */
  export type AiAnalysisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAnalysis
     */
    select?: AiAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAnalysis
     */
    omit?: AiAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAnalysisInclude<ExtArgs> | null
    /**
     * The filter to search for the AiAnalysis to update in case it exists.
     */
    where: AiAnalysisWhereUniqueInput
    /**
     * In case the AiAnalysis found by the `where` argument doesn't exist, create a new AiAnalysis with this data.
     */
    create: XOR<AiAnalysisCreateInput, AiAnalysisUncheckedCreateInput>
    /**
     * In case the AiAnalysis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiAnalysisUpdateInput, AiAnalysisUncheckedUpdateInput>
  }

  /**
   * AiAnalysis delete
   */
  export type AiAnalysisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAnalysis
     */
    select?: AiAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAnalysis
     */
    omit?: AiAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAnalysisInclude<ExtArgs> | null
    /**
     * Filter which AiAnalysis to delete.
     */
    where: AiAnalysisWhereUniqueInput
  }

  /**
   * AiAnalysis deleteMany
   */
  export type AiAnalysisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiAnalyses to delete
     */
    where?: AiAnalysisWhereInput
    /**
     * Limit how many AiAnalyses to delete.
     */
    limit?: number
  }

  /**
   * AiAnalysis.tweet
   */
  export type AiAnalysis$tweetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tweet
     */
    select?: TweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tweet
     */
    omit?: TweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TweetInclude<ExtArgs> | null
    where?: TweetWhereInput
  }

  /**
   * AiAnalysis.news
   */
  export type AiAnalysis$newsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NewsInclude<ExtArgs> | null
    where?: NewsWhereInput
  }

  /**
   * AiAnalysis without action
   */
  export type AiAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAnalysis
     */
    select?: AiAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAnalysis
     */
    omit?: AiAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model AiProcessingQueue
   */

  export type AggregateAiProcessingQueue = {
    _count: AiProcessingQueueCountAggregateOutputType | null
    _avg: AiProcessingQueueAvgAggregateOutputType | null
    _sum: AiProcessingQueueSumAggregateOutputType | null
    _min: AiProcessingQueueMinAggregateOutputType | null
    _max: AiProcessingQueueMaxAggregateOutputType | null
  }

  export type AiProcessingQueueAvgAggregateOutputType = {
    priority: number | null
    attempts: number | null
    maxAttempts: number | null
  }

  export type AiProcessingQueueSumAggregateOutputType = {
    priority: number | null
    attempts: number | null
    maxAttempts: number | null
  }

  export type AiProcessingQueueMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    tweetId: string | null
    newsId: string | null
    queueType: $Enums.QueueType | null
    priority: number | null
    status: $Enums.QueueStatus | null
    attempts: number | null
    maxAttempts: number | null
    scheduledAt: Date | null
    processedAt: Date | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiProcessingQueueMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    tweetId: string | null
    newsId: string | null
    queueType: $Enums.QueueType | null
    priority: number | null
    status: $Enums.QueueStatus | null
    attempts: number | null
    maxAttempts: number | null
    scheduledAt: Date | null
    processedAt: Date | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiProcessingQueueCountAggregateOutputType = {
    id: number
    tenantId: number
    tweetId: number
    newsId: number
    queueType: number
    priority: number
    status: number
    attempts: number
    maxAttempts: number
    scheduledAt: number
    processedAt: number
    error: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AiProcessingQueueAvgAggregateInputType = {
    priority?: true
    attempts?: true
    maxAttempts?: true
  }

  export type AiProcessingQueueSumAggregateInputType = {
    priority?: true
    attempts?: true
    maxAttempts?: true
  }

  export type AiProcessingQueueMinAggregateInputType = {
    id?: true
    tenantId?: true
    tweetId?: true
    newsId?: true
    queueType?: true
    priority?: true
    status?: true
    attempts?: true
    maxAttempts?: true
    scheduledAt?: true
    processedAt?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiProcessingQueueMaxAggregateInputType = {
    id?: true
    tenantId?: true
    tweetId?: true
    newsId?: true
    queueType?: true
    priority?: true
    status?: true
    attempts?: true
    maxAttempts?: true
    scheduledAt?: true
    processedAt?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiProcessingQueueCountAggregateInputType = {
    id?: true
    tenantId?: true
    tweetId?: true
    newsId?: true
    queueType?: true
    priority?: true
    status?: true
    attempts?: true
    maxAttempts?: true
    scheduledAt?: true
    processedAt?: true
    error?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AiProcessingQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiProcessingQueue to aggregate.
     */
    where?: AiProcessingQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiProcessingQueues to fetch.
     */
    orderBy?: AiProcessingQueueOrderByWithRelationInput | AiProcessingQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiProcessingQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiProcessingQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiProcessingQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiProcessingQueues
    **/
    _count?: true | AiProcessingQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiProcessingQueueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiProcessingQueueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiProcessingQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiProcessingQueueMaxAggregateInputType
  }

  export type GetAiProcessingQueueAggregateType<T extends AiProcessingQueueAggregateArgs> = {
        [P in keyof T & keyof AggregateAiProcessingQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiProcessingQueue[P]>
      : GetScalarType<T[P], AggregateAiProcessingQueue[P]>
  }




  export type AiProcessingQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiProcessingQueueWhereInput
    orderBy?: AiProcessingQueueOrderByWithAggregationInput | AiProcessingQueueOrderByWithAggregationInput[]
    by: AiProcessingQueueScalarFieldEnum[] | AiProcessingQueueScalarFieldEnum
    having?: AiProcessingQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiProcessingQueueCountAggregateInputType | true
    _avg?: AiProcessingQueueAvgAggregateInputType
    _sum?: AiProcessingQueueSumAggregateInputType
    _min?: AiProcessingQueueMinAggregateInputType
    _max?: AiProcessingQueueMaxAggregateInputType
  }

  export type AiProcessingQueueGroupByOutputType = {
    id: string
    tenantId: string
    tweetId: string | null
    newsId: string | null
    queueType: $Enums.QueueType
    priority: number
    status: $Enums.QueueStatus
    attempts: number
    maxAttempts: number
    scheduledAt: Date
    processedAt: Date | null
    error: string | null
    createdAt: Date
    updatedAt: Date
    _count: AiProcessingQueueCountAggregateOutputType | null
    _avg: AiProcessingQueueAvgAggregateOutputType | null
    _sum: AiProcessingQueueSumAggregateOutputType | null
    _min: AiProcessingQueueMinAggregateOutputType | null
    _max: AiProcessingQueueMaxAggregateOutputType | null
  }

  type GetAiProcessingQueueGroupByPayload<T extends AiProcessingQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiProcessingQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiProcessingQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiProcessingQueueGroupByOutputType[P]>
            : GetScalarType<T[P], AiProcessingQueueGroupByOutputType[P]>
        }
      >
    >


  export type AiProcessingQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    tweetId?: boolean
    newsId?: boolean
    queueType?: boolean
    priority?: boolean
    status?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    scheduledAt?: boolean
    processedAt?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiProcessingQueue"]>

  export type AiProcessingQueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    tweetId?: boolean
    newsId?: boolean
    queueType?: boolean
    priority?: boolean
    status?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    scheduledAt?: boolean
    processedAt?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiProcessingQueue"]>

  export type AiProcessingQueueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    tweetId?: boolean
    newsId?: boolean
    queueType?: boolean
    priority?: boolean
    status?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    scheduledAt?: boolean
    processedAt?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiProcessingQueue"]>

  export type AiProcessingQueueSelectScalar = {
    id?: boolean
    tenantId?: boolean
    tweetId?: boolean
    newsId?: boolean
    queueType?: boolean
    priority?: boolean
    status?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    scheduledAt?: boolean
    processedAt?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AiProcessingQueueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "tweetId" | "newsId" | "queueType" | "priority" | "status" | "attempts" | "maxAttempts" | "scheduledAt" | "processedAt" | "error" | "createdAt" | "updatedAt", ExtArgs["result"]["aiProcessingQueue"]>
  export type AiProcessingQueueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type AiProcessingQueueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type AiProcessingQueueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $AiProcessingQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiProcessingQueue"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      tweetId: string | null
      newsId: string | null
      queueType: $Enums.QueueType
      priority: number
      status: $Enums.QueueStatus
      attempts: number
      maxAttempts: number
      scheduledAt: Date
      processedAt: Date | null
      error: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aiProcessingQueue"]>
    composites: {}
  }

  type AiProcessingQueueGetPayload<S extends boolean | null | undefined | AiProcessingQueueDefaultArgs> = $Result.GetResult<Prisma.$AiProcessingQueuePayload, S>

  type AiProcessingQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiProcessingQueueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiProcessingQueueCountAggregateInputType | true
    }

  export interface AiProcessingQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiProcessingQueue'], meta: { name: 'AiProcessingQueue' } }
    /**
     * Find zero or one AiProcessingQueue that matches the filter.
     * @param {AiProcessingQueueFindUniqueArgs} args - Arguments to find a AiProcessingQueue
     * @example
     * // Get one AiProcessingQueue
     * const aiProcessingQueue = await prisma.aiProcessingQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiProcessingQueueFindUniqueArgs>(args: SelectSubset<T, AiProcessingQueueFindUniqueArgs<ExtArgs>>): Prisma__AiProcessingQueueClient<$Result.GetResult<Prisma.$AiProcessingQueuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiProcessingQueue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiProcessingQueueFindUniqueOrThrowArgs} args - Arguments to find a AiProcessingQueue
     * @example
     * // Get one AiProcessingQueue
     * const aiProcessingQueue = await prisma.aiProcessingQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiProcessingQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, AiProcessingQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiProcessingQueueClient<$Result.GetResult<Prisma.$AiProcessingQueuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiProcessingQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiProcessingQueueFindFirstArgs} args - Arguments to find a AiProcessingQueue
     * @example
     * // Get one AiProcessingQueue
     * const aiProcessingQueue = await prisma.aiProcessingQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiProcessingQueueFindFirstArgs>(args?: SelectSubset<T, AiProcessingQueueFindFirstArgs<ExtArgs>>): Prisma__AiProcessingQueueClient<$Result.GetResult<Prisma.$AiProcessingQueuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiProcessingQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiProcessingQueueFindFirstOrThrowArgs} args - Arguments to find a AiProcessingQueue
     * @example
     * // Get one AiProcessingQueue
     * const aiProcessingQueue = await prisma.aiProcessingQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiProcessingQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, AiProcessingQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiProcessingQueueClient<$Result.GetResult<Prisma.$AiProcessingQueuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiProcessingQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiProcessingQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiProcessingQueues
     * const aiProcessingQueues = await prisma.aiProcessingQueue.findMany()
     * 
     * // Get first 10 AiProcessingQueues
     * const aiProcessingQueues = await prisma.aiProcessingQueue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiProcessingQueueWithIdOnly = await prisma.aiProcessingQueue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiProcessingQueueFindManyArgs>(args?: SelectSubset<T, AiProcessingQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiProcessingQueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiProcessingQueue.
     * @param {AiProcessingQueueCreateArgs} args - Arguments to create a AiProcessingQueue.
     * @example
     * // Create one AiProcessingQueue
     * const AiProcessingQueue = await prisma.aiProcessingQueue.create({
     *   data: {
     *     // ... data to create a AiProcessingQueue
     *   }
     * })
     * 
     */
    create<T extends AiProcessingQueueCreateArgs>(args: SelectSubset<T, AiProcessingQueueCreateArgs<ExtArgs>>): Prisma__AiProcessingQueueClient<$Result.GetResult<Prisma.$AiProcessingQueuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiProcessingQueues.
     * @param {AiProcessingQueueCreateManyArgs} args - Arguments to create many AiProcessingQueues.
     * @example
     * // Create many AiProcessingQueues
     * const aiProcessingQueue = await prisma.aiProcessingQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiProcessingQueueCreateManyArgs>(args?: SelectSubset<T, AiProcessingQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiProcessingQueues and returns the data saved in the database.
     * @param {AiProcessingQueueCreateManyAndReturnArgs} args - Arguments to create many AiProcessingQueues.
     * @example
     * // Create many AiProcessingQueues
     * const aiProcessingQueue = await prisma.aiProcessingQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiProcessingQueues and only return the `id`
     * const aiProcessingQueueWithIdOnly = await prisma.aiProcessingQueue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiProcessingQueueCreateManyAndReturnArgs>(args?: SelectSubset<T, AiProcessingQueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiProcessingQueuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiProcessingQueue.
     * @param {AiProcessingQueueDeleteArgs} args - Arguments to delete one AiProcessingQueue.
     * @example
     * // Delete one AiProcessingQueue
     * const AiProcessingQueue = await prisma.aiProcessingQueue.delete({
     *   where: {
     *     // ... filter to delete one AiProcessingQueue
     *   }
     * })
     * 
     */
    delete<T extends AiProcessingQueueDeleteArgs>(args: SelectSubset<T, AiProcessingQueueDeleteArgs<ExtArgs>>): Prisma__AiProcessingQueueClient<$Result.GetResult<Prisma.$AiProcessingQueuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiProcessingQueue.
     * @param {AiProcessingQueueUpdateArgs} args - Arguments to update one AiProcessingQueue.
     * @example
     * // Update one AiProcessingQueue
     * const aiProcessingQueue = await prisma.aiProcessingQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiProcessingQueueUpdateArgs>(args: SelectSubset<T, AiProcessingQueueUpdateArgs<ExtArgs>>): Prisma__AiProcessingQueueClient<$Result.GetResult<Prisma.$AiProcessingQueuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiProcessingQueues.
     * @param {AiProcessingQueueDeleteManyArgs} args - Arguments to filter AiProcessingQueues to delete.
     * @example
     * // Delete a few AiProcessingQueues
     * const { count } = await prisma.aiProcessingQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiProcessingQueueDeleteManyArgs>(args?: SelectSubset<T, AiProcessingQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiProcessingQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiProcessingQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiProcessingQueues
     * const aiProcessingQueue = await prisma.aiProcessingQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiProcessingQueueUpdateManyArgs>(args: SelectSubset<T, AiProcessingQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiProcessingQueues and returns the data updated in the database.
     * @param {AiProcessingQueueUpdateManyAndReturnArgs} args - Arguments to update many AiProcessingQueues.
     * @example
     * // Update many AiProcessingQueues
     * const aiProcessingQueue = await prisma.aiProcessingQueue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiProcessingQueues and only return the `id`
     * const aiProcessingQueueWithIdOnly = await prisma.aiProcessingQueue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiProcessingQueueUpdateManyAndReturnArgs>(args: SelectSubset<T, AiProcessingQueueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiProcessingQueuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiProcessingQueue.
     * @param {AiProcessingQueueUpsertArgs} args - Arguments to update or create a AiProcessingQueue.
     * @example
     * // Update or create a AiProcessingQueue
     * const aiProcessingQueue = await prisma.aiProcessingQueue.upsert({
     *   create: {
     *     // ... data to create a AiProcessingQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiProcessingQueue we want to update
     *   }
     * })
     */
    upsert<T extends AiProcessingQueueUpsertArgs>(args: SelectSubset<T, AiProcessingQueueUpsertArgs<ExtArgs>>): Prisma__AiProcessingQueueClient<$Result.GetResult<Prisma.$AiProcessingQueuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiProcessingQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiProcessingQueueCountArgs} args - Arguments to filter AiProcessingQueues to count.
     * @example
     * // Count the number of AiProcessingQueues
     * const count = await prisma.aiProcessingQueue.count({
     *   where: {
     *     // ... the filter for the AiProcessingQueues we want to count
     *   }
     * })
    **/
    count<T extends AiProcessingQueueCountArgs>(
      args?: Subset<T, AiProcessingQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiProcessingQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiProcessingQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiProcessingQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiProcessingQueueAggregateArgs>(args: Subset<T, AiProcessingQueueAggregateArgs>): Prisma.PrismaPromise<GetAiProcessingQueueAggregateType<T>>

    /**
     * Group by AiProcessingQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiProcessingQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiProcessingQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiProcessingQueueGroupByArgs['orderBy'] }
        : { orderBy?: AiProcessingQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiProcessingQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiProcessingQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiProcessingQueue model
   */
  readonly fields: AiProcessingQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiProcessingQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiProcessingQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiProcessingQueue model
   */
  interface AiProcessingQueueFieldRefs {
    readonly id: FieldRef<"AiProcessingQueue", 'String'>
    readonly tenantId: FieldRef<"AiProcessingQueue", 'String'>
    readonly tweetId: FieldRef<"AiProcessingQueue", 'String'>
    readonly newsId: FieldRef<"AiProcessingQueue", 'String'>
    readonly queueType: FieldRef<"AiProcessingQueue", 'QueueType'>
    readonly priority: FieldRef<"AiProcessingQueue", 'Int'>
    readonly status: FieldRef<"AiProcessingQueue", 'QueueStatus'>
    readonly attempts: FieldRef<"AiProcessingQueue", 'Int'>
    readonly maxAttempts: FieldRef<"AiProcessingQueue", 'Int'>
    readonly scheduledAt: FieldRef<"AiProcessingQueue", 'DateTime'>
    readonly processedAt: FieldRef<"AiProcessingQueue", 'DateTime'>
    readonly error: FieldRef<"AiProcessingQueue", 'String'>
    readonly createdAt: FieldRef<"AiProcessingQueue", 'DateTime'>
    readonly updatedAt: FieldRef<"AiProcessingQueue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiProcessingQueue findUnique
   */
  export type AiProcessingQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiProcessingQueue
     */
    select?: AiProcessingQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiProcessingQueue
     */
    omit?: AiProcessingQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiProcessingQueueInclude<ExtArgs> | null
    /**
     * Filter, which AiProcessingQueue to fetch.
     */
    where: AiProcessingQueueWhereUniqueInput
  }

  /**
   * AiProcessingQueue findUniqueOrThrow
   */
  export type AiProcessingQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiProcessingQueue
     */
    select?: AiProcessingQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiProcessingQueue
     */
    omit?: AiProcessingQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiProcessingQueueInclude<ExtArgs> | null
    /**
     * Filter, which AiProcessingQueue to fetch.
     */
    where: AiProcessingQueueWhereUniqueInput
  }

  /**
   * AiProcessingQueue findFirst
   */
  export type AiProcessingQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiProcessingQueue
     */
    select?: AiProcessingQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiProcessingQueue
     */
    omit?: AiProcessingQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiProcessingQueueInclude<ExtArgs> | null
    /**
     * Filter, which AiProcessingQueue to fetch.
     */
    where?: AiProcessingQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiProcessingQueues to fetch.
     */
    orderBy?: AiProcessingQueueOrderByWithRelationInput | AiProcessingQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiProcessingQueues.
     */
    cursor?: AiProcessingQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiProcessingQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiProcessingQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiProcessingQueues.
     */
    distinct?: AiProcessingQueueScalarFieldEnum | AiProcessingQueueScalarFieldEnum[]
  }

  /**
   * AiProcessingQueue findFirstOrThrow
   */
  export type AiProcessingQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiProcessingQueue
     */
    select?: AiProcessingQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiProcessingQueue
     */
    omit?: AiProcessingQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiProcessingQueueInclude<ExtArgs> | null
    /**
     * Filter, which AiProcessingQueue to fetch.
     */
    where?: AiProcessingQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiProcessingQueues to fetch.
     */
    orderBy?: AiProcessingQueueOrderByWithRelationInput | AiProcessingQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiProcessingQueues.
     */
    cursor?: AiProcessingQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiProcessingQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiProcessingQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiProcessingQueues.
     */
    distinct?: AiProcessingQueueScalarFieldEnum | AiProcessingQueueScalarFieldEnum[]
  }

  /**
   * AiProcessingQueue findMany
   */
  export type AiProcessingQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiProcessingQueue
     */
    select?: AiProcessingQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiProcessingQueue
     */
    omit?: AiProcessingQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiProcessingQueueInclude<ExtArgs> | null
    /**
     * Filter, which AiProcessingQueues to fetch.
     */
    where?: AiProcessingQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiProcessingQueues to fetch.
     */
    orderBy?: AiProcessingQueueOrderByWithRelationInput | AiProcessingQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiProcessingQueues.
     */
    cursor?: AiProcessingQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiProcessingQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiProcessingQueues.
     */
    skip?: number
    distinct?: AiProcessingQueueScalarFieldEnum | AiProcessingQueueScalarFieldEnum[]
  }

  /**
   * AiProcessingQueue create
   */
  export type AiProcessingQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiProcessingQueue
     */
    select?: AiProcessingQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiProcessingQueue
     */
    omit?: AiProcessingQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiProcessingQueueInclude<ExtArgs> | null
    /**
     * The data needed to create a AiProcessingQueue.
     */
    data: XOR<AiProcessingQueueCreateInput, AiProcessingQueueUncheckedCreateInput>
  }

  /**
   * AiProcessingQueue createMany
   */
  export type AiProcessingQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiProcessingQueues.
     */
    data: AiProcessingQueueCreateManyInput | AiProcessingQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiProcessingQueue createManyAndReturn
   */
  export type AiProcessingQueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiProcessingQueue
     */
    select?: AiProcessingQueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiProcessingQueue
     */
    omit?: AiProcessingQueueOmit<ExtArgs> | null
    /**
     * The data used to create many AiProcessingQueues.
     */
    data: AiProcessingQueueCreateManyInput | AiProcessingQueueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiProcessingQueueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiProcessingQueue update
   */
  export type AiProcessingQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiProcessingQueue
     */
    select?: AiProcessingQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiProcessingQueue
     */
    omit?: AiProcessingQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiProcessingQueueInclude<ExtArgs> | null
    /**
     * The data needed to update a AiProcessingQueue.
     */
    data: XOR<AiProcessingQueueUpdateInput, AiProcessingQueueUncheckedUpdateInput>
    /**
     * Choose, which AiProcessingQueue to update.
     */
    where: AiProcessingQueueWhereUniqueInput
  }

  /**
   * AiProcessingQueue updateMany
   */
  export type AiProcessingQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiProcessingQueues.
     */
    data: XOR<AiProcessingQueueUpdateManyMutationInput, AiProcessingQueueUncheckedUpdateManyInput>
    /**
     * Filter which AiProcessingQueues to update
     */
    where?: AiProcessingQueueWhereInput
    /**
     * Limit how many AiProcessingQueues to update.
     */
    limit?: number
  }

  /**
   * AiProcessingQueue updateManyAndReturn
   */
  export type AiProcessingQueueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiProcessingQueue
     */
    select?: AiProcessingQueueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiProcessingQueue
     */
    omit?: AiProcessingQueueOmit<ExtArgs> | null
    /**
     * The data used to update AiProcessingQueues.
     */
    data: XOR<AiProcessingQueueUpdateManyMutationInput, AiProcessingQueueUncheckedUpdateManyInput>
    /**
     * Filter which AiProcessingQueues to update
     */
    where?: AiProcessingQueueWhereInput
    /**
     * Limit how many AiProcessingQueues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiProcessingQueueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiProcessingQueue upsert
   */
  export type AiProcessingQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiProcessingQueue
     */
    select?: AiProcessingQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiProcessingQueue
     */
    omit?: AiProcessingQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiProcessingQueueInclude<ExtArgs> | null
    /**
     * The filter to search for the AiProcessingQueue to update in case it exists.
     */
    where: AiProcessingQueueWhereUniqueInput
    /**
     * In case the AiProcessingQueue found by the `where` argument doesn't exist, create a new AiProcessingQueue with this data.
     */
    create: XOR<AiProcessingQueueCreateInput, AiProcessingQueueUncheckedCreateInput>
    /**
     * In case the AiProcessingQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiProcessingQueueUpdateInput, AiProcessingQueueUncheckedUpdateInput>
  }

  /**
   * AiProcessingQueue delete
   */
  export type AiProcessingQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiProcessingQueue
     */
    select?: AiProcessingQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiProcessingQueue
     */
    omit?: AiProcessingQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiProcessingQueueInclude<ExtArgs> | null
    /**
     * Filter which AiProcessingQueue to delete.
     */
    where: AiProcessingQueueWhereUniqueInput
  }

  /**
   * AiProcessingQueue deleteMany
   */
  export type AiProcessingQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiProcessingQueues to delete
     */
    where?: AiProcessingQueueWhereInput
    /**
     * Limit how many AiProcessingQueues to delete.
     */
    limit?: number
  }

  /**
   * AiProcessingQueue without action
   */
  export type AiProcessingQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiProcessingQueue
     */
    select?: AiProcessingQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiProcessingQueue
     */
    omit?: AiProcessingQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiProcessingQueueInclude<ExtArgs> | null
  }


  /**
   * Model Alert
   */

  export type AggregateAlert = {
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  export type AlertMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    type: $Enums.AlertType | null
    title: string | null
    message: string | null
    severity: $Enums.AlertSeverity | null
    status: $Enums.AlertStatus | null
    triggeredAt: Date | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlertMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    type: $Enums.AlertType | null
    title: string | null
    message: string | null
    severity: $Enums.AlertSeverity | null
    status: $Enums.AlertStatus | null
    triggeredAt: Date | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlertCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    type: number
    title: number
    message: number
    severity: number
    status: number
    metadata: number
    triggeredAt: number
    readAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AlertMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    severity?: true
    status?: true
    triggeredAt?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlertMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    severity?: true
    status?: true
    triggeredAt?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlertCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    severity?: true
    status?: true
    metadata?: true
    triggeredAt?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alert to aggregate.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alerts
    **/
    _count?: true | AlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertMaxAggregateInputType
  }

  export type GetAlertAggregateType<T extends AlertAggregateArgs> = {
        [P in keyof T & keyof AggregateAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlert[P]>
      : GetScalarType<T[P], AggregateAlert[P]>
  }




  export type AlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithAggregationInput | AlertOrderByWithAggregationInput[]
    by: AlertScalarFieldEnum[] | AlertScalarFieldEnum
    having?: AlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertCountAggregateInputType | true
    _min?: AlertMinAggregateInputType
    _max?: AlertMaxAggregateInputType
  }

  export type AlertGroupByOutputType = {
    id: string
    tenantId: string
    userId: string | null
    type: $Enums.AlertType
    title: string
    message: string
    severity: $Enums.AlertSeverity
    status: $Enums.AlertStatus
    metadata: JsonValue | null
    triggeredAt: Date
    readAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  type GetAlertGroupByPayload<T extends AlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertGroupByOutputType[P]>
            : GetScalarType<T[P], AlertGroupByOutputType[P]>
        }
      >
    >


  export type AlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    severity?: boolean
    status?: boolean
    metadata?: boolean
    triggeredAt?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Alert$userArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    severity?: boolean
    status?: boolean
    metadata?: boolean
    triggeredAt?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Alert$userArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    severity?: boolean
    status?: boolean
    metadata?: boolean
    triggeredAt?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Alert$userArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    severity?: boolean
    status?: boolean
    metadata?: boolean
    triggeredAt?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "userId" | "type" | "title" | "message" | "severity" | "status" | "metadata" | "triggeredAt" | "readAt" | "createdAt" | "updatedAt", ExtArgs["result"]["alert"]>
  export type AlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Alert$userArgs<ExtArgs>
  }
  export type AlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Alert$userArgs<ExtArgs>
  }
  export type AlertIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Alert$userArgs<ExtArgs>
  }

  export type $AlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alert"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string | null
      type: $Enums.AlertType
      title: string
      message: string
      severity: $Enums.AlertSeverity
      status: $Enums.AlertStatus
      metadata: Prisma.JsonValue | null
      triggeredAt: Date
      readAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["alert"]>
    composites: {}
  }

  type AlertGetPayload<S extends boolean | null | undefined | AlertDefaultArgs> = $Result.GetResult<Prisma.$AlertPayload, S>

  type AlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlertCountAggregateInputType | true
    }

  export interface AlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alert'], meta: { name: 'Alert' } }
    /**
     * Find zero or one Alert that matches the filter.
     * @param {AlertFindUniqueArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertFindUniqueArgs>(args: SelectSubset<T, AlertFindUniqueArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Alert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlertFindUniqueOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertFindFirstArgs>(args?: SelectSubset<T, AlertFindFirstArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alerts
     * const alerts = await prisma.alert.findMany()
     * 
     * // Get first 10 Alerts
     * const alerts = await prisma.alert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertWithIdOnly = await prisma.alert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertFindManyArgs>(args?: SelectSubset<T, AlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Alert.
     * @param {AlertCreateArgs} args - Arguments to create a Alert.
     * @example
     * // Create one Alert
     * const Alert = await prisma.alert.create({
     *   data: {
     *     // ... data to create a Alert
     *   }
     * })
     * 
     */
    create<T extends AlertCreateArgs>(args: SelectSubset<T, AlertCreateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Alerts.
     * @param {AlertCreateManyArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertCreateManyArgs>(args?: SelectSubset<T, AlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alerts and returns the data saved in the database.
     * @param {AlertCreateManyAndReturnArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alerts and only return the `id`
     * const alertWithIdOnly = await prisma.alert.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Alert.
     * @param {AlertDeleteArgs} args - Arguments to delete one Alert.
     * @example
     * // Delete one Alert
     * const Alert = await prisma.alert.delete({
     *   where: {
     *     // ... filter to delete one Alert
     *   }
     * })
     * 
     */
    delete<T extends AlertDeleteArgs>(args: SelectSubset<T, AlertDeleteArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Alert.
     * @param {AlertUpdateArgs} args - Arguments to update one Alert.
     * @example
     * // Update one Alert
     * const alert = await prisma.alert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertUpdateArgs>(args: SelectSubset<T, AlertUpdateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Alerts.
     * @param {AlertDeleteManyArgs} args - Arguments to filter Alerts to delete.
     * @example
     * // Delete a few Alerts
     * const { count } = await prisma.alert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertDeleteManyArgs>(args?: SelectSubset<T, AlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertUpdateManyArgs>(args: SelectSubset<T, AlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts and returns the data updated in the database.
     * @param {AlertUpdateManyAndReturnArgs} args - Arguments to update many Alerts.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Alerts and only return the `id`
     * const alertWithIdOnly = await prisma.alert.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlertUpdateManyAndReturnArgs>(args: SelectSubset<T, AlertUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Alert.
     * @param {AlertUpsertArgs} args - Arguments to update or create a Alert.
     * @example
     * // Update or create a Alert
     * const alert = await prisma.alert.upsert({
     *   create: {
     *     // ... data to create a Alert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alert we want to update
     *   }
     * })
     */
    upsert<T extends AlertUpsertArgs>(args: SelectSubset<T, AlertUpsertArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertCountArgs} args - Arguments to filter Alerts to count.
     * @example
     * // Count the number of Alerts
     * const count = await prisma.alert.count({
     *   where: {
     *     // ... the filter for the Alerts we want to count
     *   }
     * })
    **/
    count<T extends AlertCountArgs>(
      args?: Subset<T, AlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertAggregateArgs>(args: Subset<T, AlertAggregateArgs>): Prisma.PrismaPromise<GetAlertAggregateType<T>>

    /**
     * Group by Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertGroupByArgs['orderBy'] }
        : { orderBy?: AlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alert model
   */
  readonly fields: AlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends Alert$userArgs<ExtArgs> = {}>(args?: Subset<T, Alert$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alert model
   */
  interface AlertFieldRefs {
    readonly id: FieldRef<"Alert", 'String'>
    readonly tenantId: FieldRef<"Alert", 'String'>
    readonly userId: FieldRef<"Alert", 'String'>
    readonly type: FieldRef<"Alert", 'AlertType'>
    readonly title: FieldRef<"Alert", 'String'>
    readonly message: FieldRef<"Alert", 'String'>
    readonly severity: FieldRef<"Alert", 'AlertSeverity'>
    readonly status: FieldRef<"Alert", 'AlertStatus'>
    readonly metadata: FieldRef<"Alert", 'Json'>
    readonly triggeredAt: FieldRef<"Alert", 'DateTime'>
    readonly readAt: FieldRef<"Alert", 'DateTime'>
    readonly createdAt: FieldRef<"Alert", 'DateTime'>
    readonly updatedAt: FieldRef<"Alert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Alert findUnique
   */
  export type AlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findUniqueOrThrow
   */
  export type AlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findFirst
   */
  export type AlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findFirstOrThrow
   */
  export type AlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findMany
   */
  export type AlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alerts to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert create
   */
  export type AlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to create a Alert.
     */
    data: XOR<AlertCreateInput, AlertUncheckedCreateInput>
  }

  /**
   * Alert createMany
   */
  export type AlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alert createManyAndReturn
   */
  export type AlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Alert update
   */
  export type AlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to update a Alert.
     */
    data: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
    /**
     * Choose, which Alert to update.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert updateMany
   */
  export type AlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
    /**
     * Limit how many Alerts to update.
     */
    limit?: number
  }

  /**
   * Alert updateManyAndReturn
   */
  export type AlertUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
    /**
     * Limit how many Alerts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Alert upsert
   */
  export type AlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The filter to search for the Alert to update in case it exists.
     */
    where: AlertWhereUniqueInput
    /**
     * In case the Alert found by the `where` argument doesn't exist, create a new Alert with this data.
     */
    create: XOR<AlertCreateInput, AlertUncheckedCreateInput>
    /**
     * In case the Alert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
  }

  /**
   * Alert delete
   */
  export type AlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter which Alert to delete.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert deleteMany
   */
  export type AlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alerts to delete
     */
    where?: AlertWhereInput
    /**
     * Limit how many Alerts to delete.
     */
    limit?: number
  }

  /**
   * Alert.user
   */
  export type Alert$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Alert without action
   */
  export type AlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    action: $Enums.AuditAction | null
    entityType: $Enums.AuditEntityType | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    sessionId: string | null
    clientFingerprint: string | null
    checksum: string | null
    digitalSignature: string | null
    performedAt: Date | null
    createdAt: Date | null
    securityLevel: $Enums.SecurityLevel | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    action: $Enums.AuditAction | null
    entityType: $Enums.AuditEntityType | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    sessionId: string | null
    clientFingerprint: string | null
    checksum: string | null
    digitalSignature: string | null
    performedAt: Date | null
    createdAt: Date | null
    securityLevel: $Enums.SecurityLevel | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    action: number
    entityType: number
    entityId: number
    oldValues: number
    newValues: number
    metadata: number
    ipAddress: number
    userAgent: number
    sessionId: number
    clientFingerprint: number
    checksum: number
    digitalSignature: number
    performedAt: number
    createdAt: number
    securityLevel: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    sessionId?: true
    clientFingerprint?: true
    checksum?: true
    digitalSignature?: true
    performedAt?: true
    createdAt?: true
    securityLevel?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    sessionId?: true
    clientFingerprint?: true
    checksum?: true
    digitalSignature?: true
    performedAt?: true
    createdAt?: true
    securityLevel?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    oldValues?: true
    newValues?: true
    metadata?: true
    ipAddress?: true
    userAgent?: true
    sessionId?: true
    clientFingerprint?: true
    checksum?: true
    digitalSignature?: true
    performedAt?: true
    createdAt?: true
    securityLevel?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    tenantId: string
    userId: string | null
    action: $Enums.AuditAction
    entityType: $Enums.AuditEntityType
    entityId: string | null
    oldValues: JsonValue | null
    newValues: JsonValue | null
    metadata: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    sessionId: string | null
    clientFingerprint: string | null
    checksum: string
    digitalSignature: string | null
    performedAt: Date
    createdAt: Date
    securityLevel: $Enums.SecurityLevel
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    sessionId?: boolean
    clientFingerprint?: boolean
    checksum?: boolean
    digitalSignature?: boolean
    performedAt?: boolean
    createdAt?: boolean
    securityLevel?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    sessionId?: boolean
    clientFingerprint?: boolean
    checksum?: boolean
    digitalSignature?: boolean
    performedAt?: boolean
    createdAt?: boolean
    securityLevel?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    sessionId?: boolean
    clientFingerprint?: boolean
    checksum?: boolean
    digitalSignature?: boolean
    performedAt?: boolean
    createdAt?: boolean
    securityLevel?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    sessionId?: boolean
    clientFingerprint?: boolean
    checksum?: boolean
    digitalSignature?: boolean
    performedAt?: boolean
    createdAt?: boolean
    securityLevel?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "userId" | "action" | "entityType" | "entityId" | "oldValues" | "newValues" | "metadata" | "ipAddress" | "userAgent" | "sessionId" | "clientFingerprint" | "checksum" | "digitalSignature" | "performedAt" | "createdAt" | "securityLevel", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string | null
      action: $Enums.AuditAction
      entityType: $Enums.AuditEntityType
      entityId: string | null
      oldValues: Prisma.JsonValue | null
      newValues: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      sessionId: string | null
      clientFingerprint: string | null
      checksum: string
      digitalSignature: string | null
      performedAt: Date
      createdAt: Date
      securityLevel: $Enums.SecurityLevel
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly tenantId: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'AuditAction'>
    readonly entityType: FieldRef<"AuditLog", 'AuditEntityType'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly oldValues: FieldRef<"AuditLog", 'Json'>
    readonly newValues: FieldRef<"AuditLog", 'Json'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly sessionId: FieldRef<"AuditLog", 'String'>
    readonly clientFingerprint: FieldRef<"AuditLog", 'String'>
    readonly checksum: FieldRef<"AuditLog", 'String'>
    readonly digitalSignature: FieldRef<"AuditLog", 'String'>
    readonly performedAt: FieldRef<"AuditLog", 'DateTime'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
    readonly securityLevel: FieldRef<"AuditLog", 'SecurityLevel'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    status: 'status',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    email: 'email',
    username: 'username',
    password: 'password',
    role: 'role',
    status: 'status',
    settings: 'settings',
    lastLoginAt: 'lastLoginAt',
    isTemporaryPassword: 'isTemporaryPassword',
    temporaryPasswordExpiresAt: 'temporaryPasswordExpiresAt',
    suspendedAt: 'suspendedAt',
    suspendedBy: 'suspendedBy',
    suspensionReason: 'suspensionReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const MediaSourceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    baseUrl: 'baseUrl',
    twitterHandle: 'twitterHandle',
    selectors: 'selectors',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MediaSourceScalarFieldEnum = (typeof MediaSourceScalarFieldEnum)[keyof typeof MediaSourceScalarFieldEnum]


  export const TweetScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    tweetId: 'tweetId',
    mediaSourceId: 'mediaSourceId',
    authorName: 'authorName',
    authorHandle: 'authorHandle',
    content: 'content',
    publishedAt: 'publishedAt',
    hashtags: 'hashtags',
    mentions: 'mentions',
    mediaUrls: 'mediaUrls',
    engagement: 'engagement',
    contentHash: 'contentHash',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TweetScalarFieldEnum = (typeof TweetScalarFieldEnum)[keyof typeof TweetScalarFieldEnum]


  export const TweetMediaScalarFieldEnum: {
    id: 'id',
    tweetId: 'tweetId',
    type: 'type',
    url: 'url',
    metadata: 'metadata'
  };

  export type TweetMediaScalarFieldEnum = (typeof TweetMediaScalarFieldEnum)[keyof typeof TweetMediaScalarFieldEnum]


  export const NewsScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    tweetId: 'tweetId',
    mediaSourceId: 'mediaSourceId',
    title: 'title',
    content: 'content',
    url: 'url',
    extractedAt: 'extractedAt',
    contentHash: 'contentHash',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NewsScalarFieldEnum = (typeof NewsScalarFieldEnum)[keyof typeof NewsScalarFieldEnum]


  export const AiAnalysisScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    tweetId: 'tweetId',
    newsId: 'newsId',
    type: 'type',
    prompt: 'prompt',
    response: 'response',
    sentiment: 'sentiment',
    relevance: 'relevance',
    threatLevel: 'threatLevel',
    tags: 'tags',
    processedAt: 'processedAt',
    createdAt: 'createdAt'
  };

  export type AiAnalysisScalarFieldEnum = (typeof AiAnalysisScalarFieldEnum)[keyof typeof AiAnalysisScalarFieldEnum]


  export const AiProcessingQueueScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    tweetId: 'tweetId',
    newsId: 'newsId',
    queueType: 'queueType',
    priority: 'priority',
    status: 'status',
    attempts: 'attempts',
    maxAttempts: 'maxAttempts',
    scheduledAt: 'scheduledAt',
    processedAt: 'processedAt',
    error: 'error',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AiProcessingQueueScalarFieldEnum = (typeof AiProcessingQueueScalarFieldEnum)[keyof typeof AiProcessingQueueScalarFieldEnum]


  export const AlertScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    severity: 'severity',
    status: 'status',
    metadata: 'metadata',
    triggeredAt: 'triggeredAt',
    readAt: 'readAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AlertScalarFieldEnum = (typeof AlertScalarFieldEnum)[keyof typeof AlertScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    oldValues: 'oldValues',
    newValues: 'newValues',
    metadata: 'metadata',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    sessionId: 'sessionId',
    clientFingerprint: 'clientFingerprint',
    checksum: 'checksum',
    digitalSignature: 'digitalSignature',
    performedAt: 'performedAt',
    createdAt: 'createdAt',
    securityLevel: 'securityLevel'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'TenantType'
   */
  export type EnumTenantTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantType'>
    


  /**
   * Reference to a field of type 'TenantType[]'
   */
  export type ListEnumTenantTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantType[]'>
    


  /**
   * Reference to a field of type 'TenantStatus'
   */
  export type EnumTenantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantStatus'>
    


  /**
   * Reference to a field of type 'TenantStatus[]'
   */
  export type ListEnumTenantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'MediaType'
   */
  export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    


  /**
   * Reference to a field of type 'MediaType[]'
   */
  export type ListEnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType[]'>
    


  /**
   * Reference to a field of type 'AnalysisType'
   */
  export type EnumAnalysisTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnalysisType'>
    


  /**
   * Reference to a field of type 'AnalysisType[]'
   */
  export type ListEnumAnalysisTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnalysisType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ThreatLevel'
   */
  export type EnumThreatLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ThreatLevel'>
    


  /**
   * Reference to a field of type 'ThreatLevel[]'
   */
  export type ListEnumThreatLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ThreatLevel[]'>
    


  /**
   * Reference to a field of type 'QueueType'
   */
  export type EnumQueueTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueueType'>
    


  /**
   * Reference to a field of type 'QueueType[]'
   */
  export type ListEnumQueueTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueueType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'QueueStatus'
   */
  export type EnumQueueStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueueStatus'>
    


  /**
   * Reference to a field of type 'QueueStatus[]'
   */
  export type ListEnumQueueStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueueStatus[]'>
    


  /**
   * Reference to a field of type 'AlertType'
   */
  export type EnumAlertTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertType'>
    


  /**
   * Reference to a field of type 'AlertType[]'
   */
  export type ListEnumAlertTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertType[]'>
    


  /**
   * Reference to a field of type 'AlertSeverity'
   */
  export type EnumAlertSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertSeverity'>
    


  /**
   * Reference to a field of type 'AlertSeverity[]'
   */
  export type ListEnumAlertSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertSeverity[]'>
    


  /**
   * Reference to a field of type 'AlertStatus'
   */
  export type EnumAlertStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertStatus'>
    


  /**
   * Reference to a field of type 'AlertStatus[]'
   */
  export type ListEnumAlertStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertStatus[]'>
    


  /**
   * Reference to a field of type 'AuditAction'
   */
  export type EnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction'>
    


  /**
   * Reference to a field of type 'AuditAction[]'
   */
  export type ListEnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction[]'>
    


  /**
   * Reference to a field of type 'AuditEntityType'
   */
  export type EnumAuditEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditEntityType'>
    


  /**
   * Reference to a field of type 'AuditEntityType[]'
   */
  export type ListEnumAuditEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditEntityType[]'>
    


  /**
   * Reference to a field of type 'SecurityLevel'
   */
  export type EnumSecurityLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SecurityLevel'>
    


  /**
   * Reference to a field of type 'SecurityLevel[]'
   */
  export type ListEnumSecurityLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SecurityLevel[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    type?: EnumTenantTypeFilter<"Tenant"> | $Enums.TenantType
    status?: EnumTenantStatusFilter<"Tenant"> | $Enums.TenantStatus
    settings?: JsonNullableFilter<"Tenant">
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    tweets?: TweetListRelationFilter
    news?: NewsListRelationFilter
    aiAnalysis?: AiAnalysisListRelationFilter
    alerts?: AlertListRelationFilter
    aiProcessingQueue?: AiProcessingQueueListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    tweets?: TweetOrderByRelationAggregateInput
    news?: NewsOrderByRelationAggregateInput
    aiAnalysis?: AiAnalysisOrderByRelationAggregateInput
    alerts?: AlertOrderByRelationAggregateInput
    aiProcessingQueue?: AiProcessingQueueOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    type?: EnumTenantTypeFilter<"Tenant"> | $Enums.TenantType
    status?: EnumTenantStatusFilter<"Tenant"> | $Enums.TenantStatus
    settings?: JsonNullableFilter<"Tenant">
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    tweets?: TweetListRelationFilter
    news?: NewsListRelationFilter
    aiAnalysis?: AiAnalysisListRelationFilter
    alerts?: AlertListRelationFilter
    aiProcessingQueue?: AiProcessingQueueListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    type?: EnumTenantTypeWithAggregatesFilter<"Tenant"> | $Enums.TenantType
    status?: EnumTenantStatusWithAggregatesFilter<"Tenant"> | $Enums.TenantStatus
    settings?: JsonNullableWithAggregatesFilter<"Tenant">
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    settings?: JsonNullableFilter<"User">
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isTemporaryPassword?: BoolFilter<"User"> | boolean
    temporaryPasswordExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    suspendedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    suspendedBy?: StringNullableFilter<"User"> | string | null
    suspensionReason?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
    alerts?: AlertListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
    settings?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    isTemporaryPassword?: SortOrder
    temporaryPasswordExpiresAt?: SortOrderInput | SortOrder
    suspendedAt?: SortOrderInput | SortOrder
    suspendedBy?: SortOrderInput | SortOrder
    suspensionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    alerts?: AlertOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    tenantId?: StringNullableFilter<"User"> | string | null
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    settings?: JsonNullableFilter<"User">
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isTemporaryPassword?: BoolFilter<"User"> | boolean
    temporaryPasswordExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    suspendedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    suspendedBy?: StringNullableFilter<"User"> | string | null
    suspensionReason?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
    alerts?: AlertListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
    settings?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    isTemporaryPassword?: SortOrder
    temporaryPasswordExpiresAt?: SortOrderInput | SortOrder
    suspendedAt?: SortOrderInput | SortOrder
    suspendedBy?: SortOrderInput | SortOrder
    suspensionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    tenantId?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    settings?: JsonNullableWithAggregatesFilter<"User">
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isTemporaryPassword?: BoolWithAggregatesFilter<"User"> | boolean
    temporaryPasswordExpiresAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    suspendedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    suspendedBy?: StringNullableWithAggregatesFilter<"User"> | string | null
    suspensionReason?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type MediaSourceWhereInput = {
    AND?: MediaSourceWhereInput | MediaSourceWhereInput[]
    OR?: MediaSourceWhereInput[]
    NOT?: MediaSourceWhereInput | MediaSourceWhereInput[]
    id?: StringFilter<"MediaSource"> | string
    name?: StringFilter<"MediaSource"> | string
    type?: EnumMediaTypeFilter<"MediaSource"> | $Enums.MediaType
    baseUrl?: StringNullableFilter<"MediaSource"> | string | null
    twitterHandle?: StringNullableFilter<"MediaSource"> | string | null
    selectors?: JsonNullableFilter<"MediaSource">
    isActive?: BoolFilter<"MediaSource"> | boolean
    createdAt?: DateTimeFilter<"MediaSource"> | Date | string
    updatedAt?: DateTimeFilter<"MediaSource"> | Date | string
    tweets?: TweetListRelationFilter
    news?: NewsListRelationFilter
  }

  export type MediaSourceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    baseUrl?: SortOrderInput | SortOrder
    twitterHandle?: SortOrderInput | SortOrder
    selectors?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tweets?: TweetOrderByRelationAggregateInput
    news?: NewsOrderByRelationAggregateInput
  }

  export type MediaSourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaSourceWhereInput | MediaSourceWhereInput[]
    OR?: MediaSourceWhereInput[]
    NOT?: MediaSourceWhereInput | MediaSourceWhereInput[]
    name?: StringFilter<"MediaSource"> | string
    type?: EnumMediaTypeFilter<"MediaSource"> | $Enums.MediaType
    baseUrl?: StringNullableFilter<"MediaSource"> | string | null
    twitterHandle?: StringNullableFilter<"MediaSource"> | string | null
    selectors?: JsonNullableFilter<"MediaSource">
    isActive?: BoolFilter<"MediaSource"> | boolean
    createdAt?: DateTimeFilter<"MediaSource"> | Date | string
    updatedAt?: DateTimeFilter<"MediaSource"> | Date | string
    tweets?: TweetListRelationFilter
    news?: NewsListRelationFilter
  }, "id">

  export type MediaSourceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    baseUrl?: SortOrderInput | SortOrder
    twitterHandle?: SortOrderInput | SortOrder
    selectors?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MediaSourceCountOrderByAggregateInput
    _max?: MediaSourceMaxOrderByAggregateInput
    _min?: MediaSourceMinOrderByAggregateInput
  }

  export type MediaSourceScalarWhereWithAggregatesInput = {
    AND?: MediaSourceScalarWhereWithAggregatesInput | MediaSourceScalarWhereWithAggregatesInput[]
    OR?: MediaSourceScalarWhereWithAggregatesInput[]
    NOT?: MediaSourceScalarWhereWithAggregatesInput | MediaSourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MediaSource"> | string
    name?: StringWithAggregatesFilter<"MediaSource"> | string
    type?: EnumMediaTypeWithAggregatesFilter<"MediaSource"> | $Enums.MediaType
    baseUrl?: StringNullableWithAggregatesFilter<"MediaSource"> | string | null
    twitterHandle?: StringNullableWithAggregatesFilter<"MediaSource"> | string | null
    selectors?: JsonNullableWithAggregatesFilter<"MediaSource">
    isActive?: BoolWithAggregatesFilter<"MediaSource"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MediaSource"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MediaSource"> | Date | string
  }

  export type TweetWhereInput = {
    AND?: TweetWhereInput | TweetWhereInput[]
    OR?: TweetWhereInput[]
    NOT?: TweetWhereInput | TweetWhereInput[]
    id?: StringFilter<"Tweet"> | string
    tenantId?: StringFilter<"Tweet"> | string
    tweetId?: StringFilter<"Tweet"> | string
    mediaSourceId?: StringFilter<"Tweet"> | string
    authorName?: StringFilter<"Tweet"> | string
    authorHandle?: StringFilter<"Tweet"> | string
    content?: StringFilter<"Tweet"> | string
    publishedAt?: DateTimeFilter<"Tweet"> | Date | string
    hashtags?: StringNullableListFilter<"Tweet">
    mentions?: StringNullableListFilter<"Tweet">
    mediaUrls?: JsonNullableFilter<"Tweet">
    engagement?: JsonNullableFilter<"Tweet">
    contentHash?: StringFilter<"Tweet"> | string
    createdAt?: DateTimeFilter<"Tweet"> | Date | string
    updatedAt?: DateTimeFilter<"Tweet"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    mediaSource?: XOR<MediaSourceScalarRelationFilter, MediaSourceWhereInput>
    news?: NewsListRelationFilter
    aiAnalysis?: AiAnalysisListRelationFilter
    tweetMedia?: TweetMediaListRelationFilter
  }

  export type TweetOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tweetId?: SortOrder
    mediaSourceId?: SortOrder
    authorName?: SortOrder
    authorHandle?: SortOrder
    content?: SortOrder
    publishedAt?: SortOrder
    hashtags?: SortOrder
    mentions?: SortOrder
    mediaUrls?: SortOrderInput | SortOrder
    engagement?: SortOrderInput | SortOrder
    contentHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    mediaSource?: MediaSourceOrderByWithRelationInput
    news?: NewsOrderByRelationAggregateInput
    aiAnalysis?: AiAnalysisOrderByRelationAggregateInput
    tweetMedia?: TweetMediaOrderByRelationAggregateInput
  }

  export type TweetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tweetId?: string
    AND?: TweetWhereInput | TweetWhereInput[]
    OR?: TweetWhereInput[]
    NOT?: TweetWhereInput | TweetWhereInput[]
    tenantId?: StringFilter<"Tweet"> | string
    mediaSourceId?: StringFilter<"Tweet"> | string
    authorName?: StringFilter<"Tweet"> | string
    authorHandle?: StringFilter<"Tweet"> | string
    content?: StringFilter<"Tweet"> | string
    publishedAt?: DateTimeFilter<"Tweet"> | Date | string
    hashtags?: StringNullableListFilter<"Tweet">
    mentions?: StringNullableListFilter<"Tweet">
    mediaUrls?: JsonNullableFilter<"Tweet">
    engagement?: JsonNullableFilter<"Tweet">
    contentHash?: StringFilter<"Tweet"> | string
    createdAt?: DateTimeFilter<"Tweet"> | Date | string
    updatedAt?: DateTimeFilter<"Tweet"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    mediaSource?: XOR<MediaSourceScalarRelationFilter, MediaSourceWhereInput>
    news?: NewsListRelationFilter
    aiAnalysis?: AiAnalysisListRelationFilter
    tweetMedia?: TweetMediaListRelationFilter
  }, "id" | "tweetId">

  export type TweetOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tweetId?: SortOrder
    mediaSourceId?: SortOrder
    authorName?: SortOrder
    authorHandle?: SortOrder
    content?: SortOrder
    publishedAt?: SortOrder
    hashtags?: SortOrder
    mentions?: SortOrder
    mediaUrls?: SortOrderInput | SortOrder
    engagement?: SortOrderInput | SortOrder
    contentHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TweetCountOrderByAggregateInput
    _max?: TweetMaxOrderByAggregateInput
    _min?: TweetMinOrderByAggregateInput
  }

  export type TweetScalarWhereWithAggregatesInput = {
    AND?: TweetScalarWhereWithAggregatesInput | TweetScalarWhereWithAggregatesInput[]
    OR?: TweetScalarWhereWithAggregatesInput[]
    NOT?: TweetScalarWhereWithAggregatesInput | TweetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tweet"> | string
    tenantId?: StringWithAggregatesFilter<"Tweet"> | string
    tweetId?: StringWithAggregatesFilter<"Tweet"> | string
    mediaSourceId?: StringWithAggregatesFilter<"Tweet"> | string
    authorName?: StringWithAggregatesFilter<"Tweet"> | string
    authorHandle?: StringWithAggregatesFilter<"Tweet"> | string
    content?: StringWithAggregatesFilter<"Tweet"> | string
    publishedAt?: DateTimeWithAggregatesFilter<"Tweet"> | Date | string
    hashtags?: StringNullableListFilter<"Tweet">
    mentions?: StringNullableListFilter<"Tweet">
    mediaUrls?: JsonNullableWithAggregatesFilter<"Tweet">
    engagement?: JsonNullableWithAggregatesFilter<"Tweet">
    contentHash?: StringWithAggregatesFilter<"Tweet"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tweet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tweet"> | Date | string
  }

  export type TweetMediaWhereInput = {
    AND?: TweetMediaWhereInput | TweetMediaWhereInput[]
    OR?: TweetMediaWhereInput[]
    NOT?: TweetMediaWhereInput | TweetMediaWhereInput[]
    id?: StringFilter<"TweetMedia"> | string
    tweetId?: StringFilter<"TweetMedia"> | string
    type?: EnumMediaTypeFilter<"TweetMedia"> | $Enums.MediaType
    url?: StringFilter<"TweetMedia"> | string
    metadata?: JsonNullableFilter<"TweetMedia">
    tweet?: XOR<TweetScalarRelationFilter, TweetWhereInput>
  }

  export type TweetMediaOrderByWithRelationInput = {
    id?: SortOrder
    tweetId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    metadata?: SortOrderInput | SortOrder
    tweet?: TweetOrderByWithRelationInput
  }

  export type TweetMediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TweetMediaWhereInput | TweetMediaWhereInput[]
    OR?: TweetMediaWhereInput[]
    NOT?: TweetMediaWhereInput | TweetMediaWhereInput[]
    tweetId?: StringFilter<"TweetMedia"> | string
    type?: EnumMediaTypeFilter<"TweetMedia"> | $Enums.MediaType
    url?: StringFilter<"TweetMedia"> | string
    metadata?: JsonNullableFilter<"TweetMedia">
    tweet?: XOR<TweetScalarRelationFilter, TweetWhereInput>
  }, "id">

  export type TweetMediaOrderByWithAggregationInput = {
    id?: SortOrder
    tweetId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: TweetMediaCountOrderByAggregateInput
    _max?: TweetMediaMaxOrderByAggregateInput
    _min?: TweetMediaMinOrderByAggregateInput
  }

  export type TweetMediaScalarWhereWithAggregatesInput = {
    AND?: TweetMediaScalarWhereWithAggregatesInput | TweetMediaScalarWhereWithAggregatesInput[]
    OR?: TweetMediaScalarWhereWithAggregatesInput[]
    NOT?: TweetMediaScalarWhereWithAggregatesInput | TweetMediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TweetMedia"> | string
    tweetId?: StringWithAggregatesFilter<"TweetMedia"> | string
    type?: EnumMediaTypeWithAggregatesFilter<"TweetMedia"> | $Enums.MediaType
    url?: StringWithAggregatesFilter<"TweetMedia"> | string
    metadata?: JsonNullableWithAggregatesFilter<"TweetMedia">
  }

  export type NewsWhereInput = {
    AND?: NewsWhereInput | NewsWhereInput[]
    OR?: NewsWhereInput[]
    NOT?: NewsWhereInput | NewsWhereInput[]
    id?: StringFilter<"News"> | string
    tenantId?: StringFilter<"News"> | string
    tweetId?: StringFilter<"News"> | string
    mediaSourceId?: StringFilter<"News"> | string
    title?: StringNullableFilter<"News"> | string | null
    content?: StringNullableFilter<"News"> | string | null
    url?: StringNullableFilter<"News"> | string | null
    extractedAt?: DateTimeFilter<"News"> | Date | string
    contentHash?: StringFilter<"News"> | string
    createdAt?: DateTimeFilter<"News"> | Date | string
    updatedAt?: DateTimeFilter<"News"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    tweet?: XOR<TweetScalarRelationFilter, TweetWhereInput>
    mediaSource?: XOR<MediaSourceScalarRelationFilter, MediaSourceWhereInput>
    aiAnalysis?: AiAnalysisListRelationFilter
  }

  export type NewsOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tweetId?: SortOrder
    mediaSourceId?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    extractedAt?: SortOrder
    contentHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    tweet?: TweetOrderByWithRelationInput
    mediaSource?: MediaSourceOrderByWithRelationInput
    aiAnalysis?: AiAnalysisOrderByRelationAggregateInput
  }

  export type NewsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NewsWhereInput | NewsWhereInput[]
    OR?: NewsWhereInput[]
    NOT?: NewsWhereInput | NewsWhereInput[]
    tenantId?: StringFilter<"News"> | string
    tweetId?: StringFilter<"News"> | string
    mediaSourceId?: StringFilter<"News"> | string
    title?: StringNullableFilter<"News"> | string | null
    content?: StringNullableFilter<"News"> | string | null
    url?: StringNullableFilter<"News"> | string | null
    extractedAt?: DateTimeFilter<"News"> | Date | string
    contentHash?: StringFilter<"News"> | string
    createdAt?: DateTimeFilter<"News"> | Date | string
    updatedAt?: DateTimeFilter<"News"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    tweet?: XOR<TweetScalarRelationFilter, TweetWhereInput>
    mediaSource?: XOR<MediaSourceScalarRelationFilter, MediaSourceWhereInput>
    aiAnalysis?: AiAnalysisListRelationFilter
  }, "id">

  export type NewsOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tweetId?: SortOrder
    mediaSourceId?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    extractedAt?: SortOrder
    contentHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NewsCountOrderByAggregateInput
    _max?: NewsMaxOrderByAggregateInput
    _min?: NewsMinOrderByAggregateInput
  }

  export type NewsScalarWhereWithAggregatesInput = {
    AND?: NewsScalarWhereWithAggregatesInput | NewsScalarWhereWithAggregatesInput[]
    OR?: NewsScalarWhereWithAggregatesInput[]
    NOT?: NewsScalarWhereWithAggregatesInput | NewsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"News"> | string
    tenantId?: StringWithAggregatesFilter<"News"> | string
    tweetId?: StringWithAggregatesFilter<"News"> | string
    mediaSourceId?: StringWithAggregatesFilter<"News"> | string
    title?: StringNullableWithAggregatesFilter<"News"> | string | null
    content?: StringNullableWithAggregatesFilter<"News"> | string | null
    url?: StringNullableWithAggregatesFilter<"News"> | string | null
    extractedAt?: DateTimeWithAggregatesFilter<"News"> | Date | string
    contentHash?: StringWithAggregatesFilter<"News"> | string
    createdAt?: DateTimeWithAggregatesFilter<"News"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"News"> | Date | string
  }

  export type AiAnalysisWhereInput = {
    AND?: AiAnalysisWhereInput | AiAnalysisWhereInput[]
    OR?: AiAnalysisWhereInput[]
    NOT?: AiAnalysisWhereInput | AiAnalysisWhereInput[]
    id?: StringFilter<"AiAnalysis"> | string
    tenantId?: StringFilter<"AiAnalysis"> | string
    tweetId?: StringNullableFilter<"AiAnalysis"> | string | null
    newsId?: StringNullableFilter<"AiAnalysis"> | string | null
    type?: EnumAnalysisTypeFilter<"AiAnalysis"> | $Enums.AnalysisType
    prompt?: StringFilter<"AiAnalysis"> | string
    response?: JsonFilter<"AiAnalysis">
    sentiment?: StringNullableFilter<"AiAnalysis"> | string | null
    relevance?: FloatNullableFilter<"AiAnalysis"> | number | null
    threatLevel?: EnumThreatLevelNullableFilter<"AiAnalysis"> | $Enums.ThreatLevel | null
    tags?: StringNullableListFilter<"AiAnalysis">
    processedAt?: DateTimeFilter<"AiAnalysis"> | Date | string
    createdAt?: DateTimeFilter<"AiAnalysis"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    tweet?: XOR<TweetNullableScalarRelationFilter, TweetWhereInput> | null
    news?: XOR<NewsNullableScalarRelationFilter, NewsWhereInput> | null
  }

  export type AiAnalysisOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tweetId?: SortOrderInput | SortOrder
    newsId?: SortOrderInput | SortOrder
    type?: SortOrder
    prompt?: SortOrder
    response?: SortOrder
    sentiment?: SortOrderInput | SortOrder
    relevance?: SortOrderInput | SortOrder
    threatLevel?: SortOrderInput | SortOrder
    tags?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    tweet?: TweetOrderByWithRelationInput
    news?: NewsOrderByWithRelationInput
  }

  export type AiAnalysisWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiAnalysisWhereInput | AiAnalysisWhereInput[]
    OR?: AiAnalysisWhereInput[]
    NOT?: AiAnalysisWhereInput | AiAnalysisWhereInput[]
    tenantId?: StringFilter<"AiAnalysis"> | string
    tweetId?: StringNullableFilter<"AiAnalysis"> | string | null
    newsId?: StringNullableFilter<"AiAnalysis"> | string | null
    type?: EnumAnalysisTypeFilter<"AiAnalysis"> | $Enums.AnalysisType
    prompt?: StringFilter<"AiAnalysis"> | string
    response?: JsonFilter<"AiAnalysis">
    sentiment?: StringNullableFilter<"AiAnalysis"> | string | null
    relevance?: FloatNullableFilter<"AiAnalysis"> | number | null
    threatLevel?: EnumThreatLevelNullableFilter<"AiAnalysis"> | $Enums.ThreatLevel | null
    tags?: StringNullableListFilter<"AiAnalysis">
    processedAt?: DateTimeFilter<"AiAnalysis"> | Date | string
    createdAt?: DateTimeFilter<"AiAnalysis"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    tweet?: XOR<TweetNullableScalarRelationFilter, TweetWhereInput> | null
    news?: XOR<NewsNullableScalarRelationFilter, NewsWhereInput> | null
  }, "id">

  export type AiAnalysisOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tweetId?: SortOrderInput | SortOrder
    newsId?: SortOrderInput | SortOrder
    type?: SortOrder
    prompt?: SortOrder
    response?: SortOrder
    sentiment?: SortOrderInput | SortOrder
    relevance?: SortOrderInput | SortOrder
    threatLevel?: SortOrderInput | SortOrder
    tags?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    _count?: AiAnalysisCountOrderByAggregateInput
    _avg?: AiAnalysisAvgOrderByAggregateInput
    _max?: AiAnalysisMaxOrderByAggregateInput
    _min?: AiAnalysisMinOrderByAggregateInput
    _sum?: AiAnalysisSumOrderByAggregateInput
  }

  export type AiAnalysisScalarWhereWithAggregatesInput = {
    AND?: AiAnalysisScalarWhereWithAggregatesInput | AiAnalysisScalarWhereWithAggregatesInput[]
    OR?: AiAnalysisScalarWhereWithAggregatesInput[]
    NOT?: AiAnalysisScalarWhereWithAggregatesInput | AiAnalysisScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiAnalysis"> | string
    tenantId?: StringWithAggregatesFilter<"AiAnalysis"> | string
    tweetId?: StringNullableWithAggregatesFilter<"AiAnalysis"> | string | null
    newsId?: StringNullableWithAggregatesFilter<"AiAnalysis"> | string | null
    type?: EnumAnalysisTypeWithAggregatesFilter<"AiAnalysis"> | $Enums.AnalysisType
    prompt?: StringWithAggregatesFilter<"AiAnalysis"> | string
    response?: JsonWithAggregatesFilter<"AiAnalysis">
    sentiment?: StringNullableWithAggregatesFilter<"AiAnalysis"> | string | null
    relevance?: FloatNullableWithAggregatesFilter<"AiAnalysis"> | number | null
    threatLevel?: EnumThreatLevelNullableWithAggregatesFilter<"AiAnalysis"> | $Enums.ThreatLevel | null
    tags?: StringNullableListFilter<"AiAnalysis">
    processedAt?: DateTimeWithAggregatesFilter<"AiAnalysis"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AiAnalysis"> | Date | string
  }

  export type AiProcessingQueueWhereInput = {
    AND?: AiProcessingQueueWhereInput | AiProcessingQueueWhereInput[]
    OR?: AiProcessingQueueWhereInput[]
    NOT?: AiProcessingQueueWhereInput | AiProcessingQueueWhereInput[]
    id?: StringFilter<"AiProcessingQueue"> | string
    tenantId?: StringFilter<"AiProcessingQueue"> | string
    tweetId?: StringNullableFilter<"AiProcessingQueue"> | string | null
    newsId?: StringNullableFilter<"AiProcessingQueue"> | string | null
    queueType?: EnumQueueTypeFilter<"AiProcessingQueue"> | $Enums.QueueType
    priority?: IntFilter<"AiProcessingQueue"> | number
    status?: EnumQueueStatusFilter<"AiProcessingQueue"> | $Enums.QueueStatus
    attempts?: IntFilter<"AiProcessingQueue"> | number
    maxAttempts?: IntFilter<"AiProcessingQueue"> | number
    scheduledAt?: DateTimeFilter<"AiProcessingQueue"> | Date | string
    processedAt?: DateTimeNullableFilter<"AiProcessingQueue"> | Date | string | null
    error?: StringNullableFilter<"AiProcessingQueue"> | string | null
    createdAt?: DateTimeFilter<"AiProcessingQueue"> | Date | string
    updatedAt?: DateTimeFilter<"AiProcessingQueue"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type AiProcessingQueueOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tweetId?: SortOrderInput | SortOrder
    newsId?: SortOrderInput | SortOrder
    queueType?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    scheduledAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type AiProcessingQueueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiProcessingQueueWhereInput | AiProcessingQueueWhereInput[]
    OR?: AiProcessingQueueWhereInput[]
    NOT?: AiProcessingQueueWhereInput | AiProcessingQueueWhereInput[]
    tenantId?: StringFilter<"AiProcessingQueue"> | string
    tweetId?: StringNullableFilter<"AiProcessingQueue"> | string | null
    newsId?: StringNullableFilter<"AiProcessingQueue"> | string | null
    queueType?: EnumQueueTypeFilter<"AiProcessingQueue"> | $Enums.QueueType
    priority?: IntFilter<"AiProcessingQueue"> | number
    status?: EnumQueueStatusFilter<"AiProcessingQueue"> | $Enums.QueueStatus
    attempts?: IntFilter<"AiProcessingQueue"> | number
    maxAttempts?: IntFilter<"AiProcessingQueue"> | number
    scheduledAt?: DateTimeFilter<"AiProcessingQueue"> | Date | string
    processedAt?: DateTimeNullableFilter<"AiProcessingQueue"> | Date | string | null
    error?: StringNullableFilter<"AiProcessingQueue"> | string | null
    createdAt?: DateTimeFilter<"AiProcessingQueue"> | Date | string
    updatedAt?: DateTimeFilter<"AiProcessingQueue"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type AiProcessingQueueOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tweetId?: SortOrderInput | SortOrder
    newsId?: SortOrderInput | SortOrder
    queueType?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    scheduledAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AiProcessingQueueCountOrderByAggregateInput
    _avg?: AiProcessingQueueAvgOrderByAggregateInput
    _max?: AiProcessingQueueMaxOrderByAggregateInput
    _min?: AiProcessingQueueMinOrderByAggregateInput
    _sum?: AiProcessingQueueSumOrderByAggregateInput
  }

  export type AiProcessingQueueScalarWhereWithAggregatesInput = {
    AND?: AiProcessingQueueScalarWhereWithAggregatesInput | AiProcessingQueueScalarWhereWithAggregatesInput[]
    OR?: AiProcessingQueueScalarWhereWithAggregatesInput[]
    NOT?: AiProcessingQueueScalarWhereWithAggregatesInput | AiProcessingQueueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiProcessingQueue"> | string
    tenantId?: StringWithAggregatesFilter<"AiProcessingQueue"> | string
    tweetId?: StringNullableWithAggregatesFilter<"AiProcessingQueue"> | string | null
    newsId?: StringNullableWithAggregatesFilter<"AiProcessingQueue"> | string | null
    queueType?: EnumQueueTypeWithAggregatesFilter<"AiProcessingQueue"> | $Enums.QueueType
    priority?: IntWithAggregatesFilter<"AiProcessingQueue"> | number
    status?: EnumQueueStatusWithAggregatesFilter<"AiProcessingQueue"> | $Enums.QueueStatus
    attempts?: IntWithAggregatesFilter<"AiProcessingQueue"> | number
    maxAttempts?: IntWithAggregatesFilter<"AiProcessingQueue"> | number
    scheduledAt?: DateTimeWithAggregatesFilter<"AiProcessingQueue"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"AiProcessingQueue"> | Date | string | null
    error?: StringNullableWithAggregatesFilter<"AiProcessingQueue"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AiProcessingQueue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AiProcessingQueue"> | Date | string
  }

  export type AlertWhereInput = {
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    id?: StringFilter<"Alert"> | string
    tenantId?: StringFilter<"Alert"> | string
    userId?: StringNullableFilter<"Alert"> | string | null
    type?: EnumAlertTypeFilter<"Alert"> | $Enums.AlertType
    title?: StringFilter<"Alert"> | string
    message?: StringFilter<"Alert"> | string
    severity?: EnumAlertSeverityFilter<"Alert"> | $Enums.AlertSeverity
    status?: EnumAlertStatusFilter<"Alert"> | $Enums.AlertStatus
    metadata?: JsonNullableFilter<"Alert">
    triggeredAt?: DateTimeFilter<"Alert"> | Date | string
    readAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AlertOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    triggeredAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    tenantId?: StringFilter<"Alert"> | string
    userId?: StringNullableFilter<"Alert"> | string | null
    type?: EnumAlertTypeFilter<"Alert"> | $Enums.AlertType
    title?: StringFilter<"Alert"> | string
    message?: StringFilter<"Alert"> | string
    severity?: EnumAlertSeverityFilter<"Alert"> | $Enums.AlertSeverity
    status?: EnumAlertStatusFilter<"Alert"> | $Enums.AlertStatus
    metadata?: JsonNullableFilter<"Alert">
    triggeredAt?: DateTimeFilter<"Alert"> | Date | string
    readAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AlertOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    triggeredAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AlertCountOrderByAggregateInput
    _max?: AlertMaxOrderByAggregateInput
    _min?: AlertMinOrderByAggregateInput
  }

  export type AlertScalarWhereWithAggregatesInput = {
    AND?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    OR?: AlertScalarWhereWithAggregatesInput[]
    NOT?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Alert"> | string
    tenantId?: StringWithAggregatesFilter<"Alert"> | string
    userId?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    type?: EnumAlertTypeWithAggregatesFilter<"Alert"> | $Enums.AlertType
    title?: StringWithAggregatesFilter<"Alert"> | string
    message?: StringWithAggregatesFilter<"Alert"> | string
    severity?: EnumAlertSeverityWithAggregatesFilter<"Alert"> | $Enums.AlertSeverity
    status?: EnumAlertStatusWithAggregatesFilter<"Alert"> | $Enums.AlertStatus
    metadata?: JsonNullableWithAggregatesFilter<"Alert">
    triggeredAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
    readAt?: DateTimeNullableWithAggregatesFilter<"Alert"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    tenantId?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    entityType?: EnumAuditEntityTypeFilter<"AuditLog"> | $Enums.AuditEntityType
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    metadata?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    sessionId?: StringNullableFilter<"AuditLog"> | string | null
    clientFingerprint?: StringNullableFilter<"AuditLog"> | string | null
    checksum?: StringFilter<"AuditLog"> | string
    digitalSignature?: StringNullableFilter<"AuditLog"> | string | null
    performedAt?: DateTimeFilter<"AuditLog"> | Date | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    securityLevel?: EnumSecurityLevelFilter<"AuditLog"> | $Enums.SecurityLevel
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    clientFingerprint?: SortOrderInput | SortOrder
    checksum?: SortOrder
    digitalSignature?: SortOrderInput | SortOrder
    performedAt?: SortOrder
    createdAt?: SortOrder
    securityLevel?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    tenantId?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    entityType?: EnumAuditEntityTypeFilter<"AuditLog"> | $Enums.AuditEntityType
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    metadata?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    sessionId?: StringNullableFilter<"AuditLog"> | string | null
    clientFingerprint?: StringNullableFilter<"AuditLog"> | string | null
    checksum?: StringFilter<"AuditLog"> | string
    digitalSignature?: StringNullableFilter<"AuditLog"> | string | null
    performedAt?: DateTimeFilter<"AuditLog"> | Date | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    securityLevel?: EnumSecurityLevelFilter<"AuditLog"> | $Enums.SecurityLevel
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    clientFingerprint?: SortOrderInput | SortOrder
    checksum?: SortOrder
    digitalSignature?: SortOrderInput | SortOrder
    performedAt?: SortOrder
    createdAt?: SortOrder
    securityLevel?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    tenantId?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: EnumAuditActionWithAggregatesFilter<"AuditLog"> | $Enums.AuditAction
    entityType?: EnumAuditEntityTypeWithAggregatesFilter<"AuditLog"> | $Enums.AuditEntityType
    entityId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    oldValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    newValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    sessionId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    clientFingerprint?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    checksum?: StringWithAggregatesFilter<"AuditLog"> | string
    digitalSignature?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    performedAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
    securityLevel?: EnumSecurityLevelWithAggregatesFilter<"AuditLog"> | $Enums.SecurityLevel
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    tweets?: TweetCreateNestedManyWithoutTenantInput
    news?: NewsCreateNestedManyWithoutTenantInput
    aiAnalysis?: AiAnalysisCreateNestedManyWithoutTenantInput
    alerts?: AlertCreateNestedManyWithoutTenantInput
    aiProcessingQueue?: AiProcessingQueueCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    tweets?: TweetUncheckedCreateNestedManyWithoutTenantInput
    news?: NewsUncheckedCreateNestedManyWithoutTenantInput
    aiAnalysis?: AiAnalysisUncheckedCreateNestedManyWithoutTenantInput
    alerts?: AlertUncheckedCreateNestedManyWithoutTenantInput
    aiProcessingQueue?: AiProcessingQueueUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    tweets?: TweetUpdateManyWithoutTenantNestedInput
    news?: NewsUpdateManyWithoutTenantNestedInput
    aiAnalysis?: AiAnalysisUpdateManyWithoutTenantNestedInput
    alerts?: AlertUpdateManyWithoutTenantNestedInput
    aiProcessingQueue?: AiProcessingQueueUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    tweets?: TweetUncheckedUpdateManyWithoutTenantNestedInput
    news?: NewsUncheckedUpdateManyWithoutTenantNestedInput
    aiAnalysis?: AiAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutTenantNestedInput
    aiProcessingQueue?: AiProcessingQueueUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username: string
    password: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    isTemporaryPassword?: boolean
    temporaryPasswordExpiresAt?: Date | string | null
    suspendedAt?: Date | string | null
    suspendedBy?: string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    alerts?: AlertCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    tenantId?: string | null
    email: string
    username: string
    password: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    isTemporaryPassword?: boolean
    temporaryPasswordExpiresAt?: Date | string | null
    suspendedAt?: Date | string | null
    suspendedBy?: string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTemporaryPassword?: BoolFieldUpdateOperationsInput | boolean
    temporaryPasswordExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendedBy?: NullableStringFieldUpdateOperationsInput | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    alerts?: AlertUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTemporaryPassword?: BoolFieldUpdateOperationsInput | boolean
    temporaryPasswordExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendedBy?: NullableStringFieldUpdateOperationsInput | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    tenantId?: string | null
    email: string
    username: string
    password: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    isTemporaryPassword?: boolean
    temporaryPasswordExpiresAt?: Date | string | null
    suspendedAt?: Date | string | null
    suspendedBy?: string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTemporaryPassword?: BoolFieldUpdateOperationsInput | boolean
    temporaryPasswordExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendedBy?: NullableStringFieldUpdateOperationsInput | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTemporaryPassword?: BoolFieldUpdateOperationsInput | boolean
    temporaryPasswordExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendedBy?: NullableStringFieldUpdateOperationsInput | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaSourceCreateInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    baseUrl?: string | null
    twitterHandle?: string | null
    selectors?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tweets?: TweetCreateNestedManyWithoutMediaSourceInput
    news?: NewsCreateNestedManyWithoutMediaSourceInput
  }

  export type MediaSourceUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    baseUrl?: string | null
    twitterHandle?: string | null
    selectors?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tweets?: TweetUncheckedCreateNestedManyWithoutMediaSourceInput
    news?: NewsUncheckedCreateNestedManyWithoutMediaSourceInput
  }

  export type MediaSourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterHandle?: NullableStringFieldUpdateOperationsInput | string | null
    selectors?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tweets?: TweetUpdateManyWithoutMediaSourceNestedInput
    news?: NewsUpdateManyWithoutMediaSourceNestedInput
  }

  export type MediaSourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterHandle?: NullableStringFieldUpdateOperationsInput | string | null
    selectors?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tweets?: TweetUncheckedUpdateManyWithoutMediaSourceNestedInput
    news?: NewsUncheckedUpdateManyWithoutMediaSourceNestedInput
  }

  export type MediaSourceCreateManyInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    baseUrl?: string | null
    twitterHandle?: string | null
    selectors?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaSourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterHandle?: NullableStringFieldUpdateOperationsInput | string | null
    selectors?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaSourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterHandle?: NullableStringFieldUpdateOperationsInput | string | null
    selectors?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetCreateInput = {
    id?: string
    tweetId: string
    authorName: string
    authorHandle: string
    content: string
    publishedAt: Date | string
    hashtags?: TweetCreatehashtagsInput | string[]
    mentions?: TweetCreatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTweetsInput
    mediaSource: MediaSourceCreateNestedOneWithoutTweetsInput
    news?: NewsCreateNestedManyWithoutTweetInput
    aiAnalysis?: AiAnalysisCreateNestedManyWithoutTweetInput
    tweetMedia?: TweetMediaCreateNestedManyWithoutTweetInput
  }

  export type TweetUncheckedCreateInput = {
    id?: string
    tenantId: string
    tweetId: string
    mediaSourceId: string
    authorName: string
    authorHandle: string
    content: string
    publishedAt: Date | string
    hashtags?: TweetCreatehashtagsInput | string[]
    mentions?: TweetCreatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    news?: NewsUncheckedCreateNestedManyWithoutTweetInput
    aiAnalysis?: AiAnalysisUncheckedCreateNestedManyWithoutTweetInput
    tweetMedia?: TweetMediaUncheckedCreateNestedManyWithoutTweetInput
  }

  export type TweetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorHandle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtags?: TweetUpdatehashtagsInput | string[]
    mentions?: TweetUpdatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTweetsNestedInput
    mediaSource?: MediaSourceUpdateOneRequiredWithoutTweetsNestedInput
    news?: NewsUpdateManyWithoutTweetNestedInput
    aiAnalysis?: AiAnalysisUpdateManyWithoutTweetNestedInput
    tweetMedia?: TweetMediaUpdateManyWithoutTweetNestedInput
  }

  export type TweetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    mediaSourceId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorHandle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtags?: TweetUpdatehashtagsInput | string[]
    mentions?: TweetUpdatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    news?: NewsUncheckedUpdateManyWithoutTweetNestedInput
    aiAnalysis?: AiAnalysisUncheckedUpdateManyWithoutTweetNestedInput
    tweetMedia?: TweetMediaUncheckedUpdateManyWithoutTweetNestedInput
  }

  export type TweetCreateManyInput = {
    id?: string
    tenantId: string
    tweetId: string
    mediaSourceId: string
    authorName: string
    authorHandle: string
    content: string
    publishedAt: Date | string
    hashtags?: TweetCreatehashtagsInput | string[]
    mentions?: TweetCreatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorHandle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtags?: TweetUpdatehashtagsInput | string[]
    mentions?: TweetUpdatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    mediaSourceId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorHandle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtags?: TweetUpdatehashtagsInput | string[]
    mentions?: TweetUpdatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetMediaCreateInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tweet: TweetCreateNestedOneWithoutTweetMediaInput
  }

  export type TweetMediaUncheckedCreateInput = {
    id?: string
    tweetId: string
    type: $Enums.MediaType
    url: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TweetMediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tweet?: TweetUpdateOneRequiredWithoutTweetMediaNestedInput
  }

  export type TweetMediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TweetMediaCreateManyInput = {
    id?: string
    tweetId: string
    type: $Enums.MediaType
    url: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TweetMediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TweetMediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NewsCreateInput = {
    id?: string
    title?: string | null
    content?: string | null
    url?: string | null
    extractedAt: Date | string
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutNewsInput
    tweet: TweetCreateNestedOneWithoutNewsInput
    mediaSource: MediaSourceCreateNestedOneWithoutNewsInput
    aiAnalysis?: AiAnalysisCreateNestedManyWithoutNewsInput
  }

  export type NewsUncheckedCreateInput = {
    id?: string
    tenantId: string
    tweetId: string
    mediaSourceId: string
    title?: string | null
    content?: string | null
    url?: string | null
    extractedAt: Date | string
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    aiAnalysis?: AiAnalysisUncheckedCreateNestedManyWithoutNewsInput
  }

  export type NewsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extractedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutNewsNestedInput
    tweet?: TweetUpdateOneRequiredWithoutNewsNestedInput
    mediaSource?: MediaSourceUpdateOneRequiredWithoutNewsNestedInput
    aiAnalysis?: AiAnalysisUpdateManyWithoutNewsNestedInput
  }

  export type NewsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    mediaSourceId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extractedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiAnalysis?: AiAnalysisUncheckedUpdateManyWithoutNewsNestedInput
  }

  export type NewsCreateManyInput = {
    id?: string
    tenantId: string
    tweetId: string
    mediaSourceId: string
    title?: string | null
    content?: string | null
    url?: string | null
    extractedAt: Date | string
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extractedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    mediaSourceId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extractedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiAnalysisCreateInput = {
    id?: string
    type: $Enums.AnalysisType
    prompt: string
    response: JsonNullValueInput | InputJsonValue
    sentiment?: string | null
    relevance?: number | null
    threatLevel?: $Enums.ThreatLevel | null
    tags?: AiAnalysisCreatetagsInput | string[]
    processedAt?: Date | string
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAiAnalysisInput
    tweet?: TweetCreateNestedOneWithoutAiAnalysisInput
    news?: NewsCreateNestedOneWithoutAiAnalysisInput
  }

  export type AiAnalysisUncheckedCreateInput = {
    id?: string
    tenantId: string
    tweetId?: string | null
    newsId?: string | null
    type: $Enums.AnalysisType
    prompt: string
    response: JsonNullValueInput | InputJsonValue
    sentiment?: string | null
    relevance?: number | null
    threatLevel?: $Enums.ThreatLevel | null
    tags?: AiAnalysisCreatetagsInput | string[]
    processedAt?: Date | string
    createdAt?: Date | string
  }

  export type AiAnalysisUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    prompt?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    relevance?: NullableFloatFieldUpdateOperationsInput | number | null
    threatLevel?: NullableEnumThreatLevelFieldUpdateOperationsInput | $Enums.ThreatLevel | null
    tags?: AiAnalysisUpdatetagsInput | string[]
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAiAnalysisNestedInput
    tweet?: TweetUpdateOneWithoutAiAnalysisNestedInput
    news?: NewsUpdateOneWithoutAiAnalysisNestedInput
  }

  export type AiAnalysisUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    newsId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    prompt?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    relevance?: NullableFloatFieldUpdateOperationsInput | number | null
    threatLevel?: NullableEnumThreatLevelFieldUpdateOperationsInput | $Enums.ThreatLevel | null
    tags?: AiAnalysisUpdatetagsInput | string[]
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiAnalysisCreateManyInput = {
    id?: string
    tenantId: string
    tweetId?: string | null
    newsId?: string | null
    type: $Enums.AnalysisType
    prompt: string
    response: JsonNullValueInput | InputJsonValue
    sentiment?: string | null
    relevance?: number | null
    threatLevel?: $Enums.ThreatLevel | null
    tags?: AiAnalysisCreatetagsInput | string[]
    processedAt?: Date | string
    createdAt?: Date | string
  }

  export type AiAnalysisUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    prompt?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    relevance?: NullableFloatFieldUpdateOperationsInput | number | null
    threatLevel?: NullableEnumThreatLevelFieldUpdateOperationsInput | $Enums.ThreatLevel | null
    tags?: AiAnalysisUpdatetagsInput | string[]
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiAnalysisUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    newsId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    prompt?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    relevance?: NullableFloatFieldUpdateOperationsInput | number | null
    threatLevel?: NullableEnumThreatLevelFieldUpdateOperationsInput | $Enums.ThreatLevel | null
    tags?: AiAnalysisUpdatetagsInput | string[]
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiProcessingQueueCreateInput = {
    id?: string
    tweetId?: string | null
    newsId?: string | null
    queueType: $Enums.QueueType
    priority?: number
    status?: $Enums.QueueStatus
    attempts?: number
    maxAttempts?: number
    scheduledAt?: Date | string
    processedAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAiProcessingQueueInput
  }

  export type AiProcessingQueueUncheckedCreateInput = {
    id?: string
    tenantId: string
    tweetId?: string | null
    newsId?: string | null
    queueType: $Enums.QueueType
    priority?: number
    status?: $Enums.QueueStatus
    attempts?: number
    maxAttempts?: number
    scheduledAt?: Date | string
    processedAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiProcessingQueueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    newsId?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: EnumQueueTypeFieldUpdateOperationsInput | $Enums.QueueType
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAiProcessingQueueNestedInput
  }

  export type AiProcessingQueueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    newsId?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: EnumQueueTypeFieldUpdateOperationsInput | $Enums.QueueType
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiProcessingQueueCreateManyInput = {
    id?: string
    tenantId: string
    tweetId?: string | null
    newsId?: string | null
    queueType: $Enums.QueueType
    priority?: number
    status?: $Enums.QueueStatus
    attempts?: number
    maxAttempts?: number
    scheduledAt?: Date | string
    processedAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiProcessingQueueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    newsId?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: EnumQueueTypeFieldUpdateOperationsInput | $Enums.QueueType
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiProcessingQueueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    newsId?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: EnumQueueTypeFieldUpdateOperationsInput | $Enums.QueueType
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertCreateInput = {
    id?: string
    type: $Enums.AlertType
    title: string
    message: string
    severity: $Enums.AlertSeverity
    status?: $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: Date | string
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAlertsInput
    user?: UserCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId?: string | null
    type: $Enums.AlertType
    title: string
    message: string
    severity: $Enums.AlertSeverity
    status?: $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: Date | string
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAlertsNestedInput
    user?: UserUpdateOneWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertCreateManyInput = {
    id?: string
    tenantId: string
    userId?: string | null
    type: $Enums.AlertType
    title: string
    message: string
    severity: $Enums.AlertSeverity
    status?: $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: Date | string
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: $Enums.AuditAction
    entityType: $Enums.AuditEntityType
    entityId?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    sessionId?: string | null
    clientFingerprint?: string | null
    checksum: string
    digitalSignature?: string | null
    performedAt?: Date | string
    createdAt?: Date | string
    securityLevel?: $Enums.SecurityLevel
    tenant: TenantCreateNestedOneWithoutAuditLogsInput
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId?: string | null
    action: $Enums.AuditAction
    entityType: $Enums.AuditEntityType
    entityId?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    sessionId?: string | null
    clientFingerprint?: string | null
    checksum: string
    digitalSignature?: string | null
    performedAt?: Date | string
    createdAt?: Date | string
    securityLevel?: $Enums.SecurityLevel
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: EnumAuditEntityTypeFieldUpdateOperationsInput | $Enums.AuditEntityType
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    clientFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    checksum?: StringFieldUpdateOperationsInput | string
    digitalSignature?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    securityLevel?: EnumSecurityLevelFieldUpdateOperationsInput | $Enums.SecurityLevel
    tenant?: TenantUpdateOneRequiredWithoutAuditLogsNestedInput
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: EnumAuditEntityTypeFieldUpdateOperationsInput | $Enums.AuditEntityType
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    clientFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    checksum?: StringFieldUpdateOperationsInput | string
    digitalSignature?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    securityLevel?: EnumSecurityLevelFieldUpdateOperationsInput | $Enums.SecurityLevel
  }

  export type AuditLogCreateManyInput = {
    id?: string
    tenantId: string
    userId?: string | null
    action: $Enums.AuditAction
    entityType: $Enums.AuditEntityType
    entityId?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    sessionId?: string | null
    clientFingerprint?: string | null
    checksum: string
    digitalSignature?: string | null
    performedAt?: Date | string
    createdAt?: Date | string
    securityLevel?: $Enums.SecurityLevel
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: EnumAuditEntityTypeFieldUpdateOperationsInput | $Enums.AuditEntityType
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    clientFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    checksum?: StringFieldUpdateOperationsInput | string
    digitalSignature?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    securityLevel?: EnumSecurityLevelFieldUpdateOperationsInput | $Enums.SecurityLevel
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: EnumAuditEntityTypeFieldUpdateOperationsInput | $Enums.AuditEntityType
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    clientFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    checksum?: StringFieldUpdateOperationsInput | string
    digitalSignature?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    securityLevel?: EnumSecurityLevelFieldUpdateOperationsInput | $Enums.SecurityLevel
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumTenantTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantType | EnumTenantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantTypeFilter<$PrismaModel> | $Enums.TenantType
  }

  export type EnumTenantStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantStatus | EnumTenantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantStatusFilter<$PrismaModel> | $Enums.TenantStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type TweetListRelationFilter = {
    every?: TweetWhereInput
    some?: TweetWhereInput
    none?: TweetWhereInput
  }

  export type NewsListRelationFilter = {
    every?: NewsWhereInput
    some?: NewsWhereInput
    none?: NewsWhereInput
  }

  export type AiAnalysisListRelationFilter = {
    every?: AiAnalysisWhereInput
    some?: AiAnalysisWhereInput
    none?: AiAnalysisWhereInput
  }

  export type AlertListRelationFilter = {
    every?: AlertWhereInput
    some?: AlertWhereInput
    none?: AlertWhereInput
  }

  export type AiProcessingQueueListRelationFilter = {
    every?: AiProcessingQueueWhereInput
    some?: AiProcessingQueueWhereInput
    none?: AiProcessingQueueWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TweetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NewsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiAnalysisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiProcessingQueueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumTenantTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantType | EnumTenantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantTypeWithAggregatesFilter<$PrismaModel> | $Enums.TenantType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantTypeFilter<$PrismaModel>
    _max?: NestedEnumTenantTypeFilter<$PrismaModel>
  }

  export type EnumTenantStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantStatus | EnumTenantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantStatusWithAggregatesFilter<$PrismaModel> | $Enums.TenantStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantStatusFilter<$PrismaModel>
    _max?: NestedEnumTenantStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type TenantNullableScalarRelationFilter = {
    is?: TenantWhereInput | null
    isNot?: TenantWhereInput | null
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
    settings?: SortOrder
    lastLoginAt?: SortOrder
    isTemporaryPassword?: SortOrder
    temporaryPasswordExpiresAt?: SortOrder
    suspendedAt?: SortOrder
    suspendedBy?: SortOrder
    suspensionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
    lastLoginAt?: SortOrder
    isTemporaryPassword?: SortOrder
    temporaryPasswordExpiresAt?: SortOrder
    suspendedAt?: SortOrder
    suspendedBy?: SortOrder
    suspensionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
    lastLoginAt?: SortOrder
    isTemporaryPassword?: SortOrder
    temporaryPasswordExpiresAt?: SortOrder
    suspendedAt?: SortOrder
    suspendedBy?: SortOrder
    suspensionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type MediaSourceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    baseUrl?: SortOrder
    twitterHandle?: SortOrder
    selectors?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaSourceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    baseUrl?: SortOrder
    twitterHandle?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaSourceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    baseUrl?: SortOrder
    twitterHandle?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type TenantScalarRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type MediaSourceScalarRelationFilter = {
    is?: MediaSourceWhereInput
    isNot?: MediaSourceWhereInput
  }

  export type TweetMediaListRelationFilter = {
    every?: TweetMediaWhereInput
    some?: TweetMediaWhereInput
    none?: TweetMediaWhereInput
  }

  export type TweetMediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TweetCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tweetId?: SortOrder
    mediaSourceId?: SortOrder
    authorName?: SortOrder
    authorHandle?: SortOrder
    content?: SortOrder
    publishedAt?: SortOrder
    hashtags?: SortOrder
    mentions?: SortOrder
    mediaUrls?: SortOrder
    engagement?: SortOrder
    contentHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TweetMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tweetId?: SortOrder
    mediaSourceId?: SortOrder
    authorName?: SortOrder
    authorHandle?: SortOrder
    content?: SortOrder
    publishedAt?: SortOrder
    contentHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TweetMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tweetId?: SortOrder
    mediaSourceId?: SortOrder
    authorName?: SortOrder
    authorHandle?: SortOrder
    content?: SortOrder
    publishedAt?: SortOrder
    contentHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TweetScalarRelationFilter = {
    is?: TweetWhereInput
    isNot?: TweetWhereInput
  }

  export type TweetMediaCountOrderByAggregateInput = {
    id?: SortOrder
    tweetId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    metadata?: SortOrder
  }

  export type TweetMediaMaxOrderByAggregateInput = {
    id?: SortOrder
    tweetId?: SortOrder
    type?: SortOrder
    url?: SortOrder
  }

  export type TweetMediaMinOrderByAggregateInput = {
    id?: SortOrder
    tweetId?: SortOrder
    type?: SortOrder
    url?: SortOrder
  }

  export type NewsCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tweetId?: SortOrder
    mediaSourceId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    url?: SortOrder
    extractedAt?: SortOrder
    contentHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tweetId?: SortOrder
    mediaSourceId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    url?: SortOrder
    extractedAt?: SortOrder
    contentHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tweetId?: SortOrder
    mediaSourceId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    url?: SortOrder
    extractedAt?: SortOrder
    contentHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAnalysisTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalysisType | EnumAnalysisTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalysisTypeFilter<$PrismaModel> | $Enums.AnalysisType
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumThreatLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ThreatLevel | EnumThreatLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.ThreatLevel[] | ListEnumThreatLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ThreatLevel[] | ListEnumThreatLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumThreatLevelNullableFilter<$PrismaModel> | $Enums.ThreatLevel | null
  }

  export type TweetNullableScalarRelationFilter = {
    is?: TweetWhereInput | null
    isNot?: TweetWhereInput | null
  }

  export type NewsNullableScalarRelationFilter = {
    is?: NewsWhereInput | null
    isNot?: NewsWhereInput | null
  }

  export type AiAnalysisCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tweetId?: SortOrder
    newsId?: SortOrder
    type?: SortOrder
    prompt?: SortOrder
    response?: SortOrder
    sentiment?: SortOrder
    relevance?: SortOrder
    threatLevel?: SortOrder
    tags?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AiAnalysisAvgOrderByAggregateInput = {
    relevance?: SortOrder
  }

  export type AiAnalysisMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tweetId?: SortOrder
    newsId?: SortOrder
    type?: SortOrder
    prompt?: SortOrder
    sentiment?: SortOrder
    relevance?: SortOrder
    threatLevel?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AiAnalysisMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tweetId?: SortOrder
    newsId?: SortOrder
    type?: SortOrder
    prompt?: SortOrder
    sentiment?: SortOrder
    relevance?: SortOrder
    threatLevel?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AiAnalysisSumOrderByAggregateInput = {
    relevance?: SortOrder
  }

  export type EnumAnalysisTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalysisType | EnumAnalysisTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalysisTypeWithAggregatesFilter<$PrismaModel> | $Enums.AnalysisType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnalysisTypeFilter<$PrismaModel>
    _max?: NestedEnumAnalysisTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumThreatLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ThreatLevel | EnumThreatLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.ThreatLevel[] | ListEnumThreatLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ThreatLevel[] | ListEnumThreatLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumThreatLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.ThreatLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumThreatLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumThreatLevelNullableFilter<$PrismaModel>
  }

  export type EnumQueueTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueType | EnumQueueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QueueType[] | ListEnumQueueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueueType[] | ListEnumQueueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQueueTypeFilter<$PrismaModel> | $Enums.QueueType
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumQueueStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueStatus | EnumQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueueStatusFilter<$PrismaModel> | $Enums.QueueStatus
  }

  export type AiProcessingQueueCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tweetId?: SortOrder
    newsId?: SortOrder
    queueType?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    scheduledAt?: SortOrder
    processedAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiProcessingQueueAvgOrderByAggregateInput = {
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
  }

  export type AiProcessingQueueMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tweetId?: SortOrder
    newsId?: SortOrder
    queueType?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    scheduledAt?: SortOrder
    processedAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiProcessingQueueMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tweetId?: SortOrder
    newsId?: SortOrder
    queueType?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    scheduledAt?: SortOrder
    processedAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiProcessingQueueSumOrderByAggregateInput = {
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
  }

  export type EnumQueueTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueType | EnumQueueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QueueType[] | ListEnumQueueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueueType[] | ListEnumQueueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQueueTypeWithAggregatesFilter<$PrismaModel> | $Enums.QueueType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQueueTypeFilter<$PrismaModel>
    _max?: NestedEnumQueueTypeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumQueueStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueStatus | EnumQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueueStatusWithAggregatesFilter<$PrismaModel> | $Enums.QueueStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQueueStatusFilter<$PrismaModel>
    _max?: NestedEnumQueueStatusFilter<$PrismaModel>
  }

  export type EnumAlertTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeFilter<$PrismaModel> | $Enums.AlertType
  }

  export type EnumAlertSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertSeverity | EnumAlertSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.AlertSeverity[] | ListEnumAlertSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertSeverity[] | ListEnumAlertSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertSeverityFilter<$PrismaModel> | $Enums.AlertSeverity
  }

  export type EnumAlertStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertStatus | EnumAlertStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertStatusFilter<$PrismaModel> | $Enums.AlertStatus
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AlertCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    triggeredAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    triggeredAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    triggeredAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAlertTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeWithAggregatesFilter<$PrismaModel> | $Enums.AlertType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertTypeFilter<$PrismaModel>
    _max?: NestedEnumAlertTypeFilter<$PrismaModel>
  }

  export type EnumAlertSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertSeverity | EnumAlertSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.AlertSeverity[] | ListEnumAlertSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertSeverity[] | ListEnumAlertSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertSeverityWithAggregatesFilter<$PrismaModel> | $Enums.AlertSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertSeverityFilter<$PrismaModel>
    _max?: NestedEnumAlertSeverityFilter<$PrismaModel>
  }

  export type EnumAlertStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertStatus | EnumAlertStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertStatusWithAggregatesFilter<$PrismaModel> | $Enums.AlertStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertStatusFilter<$PrismaModel>
    _max?: NestedEnumAlertStatusFilter<$PrismaModel>
  }

  export type EnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type EnumAuditEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditEntityType | EnumAuditEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditEntityType[] | ListEnumAuditEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditEntityType[] | ListEnumAuditEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditEntityTypeFilter<$PrismaModel> | $Enums.AuditEntityType
  }

  export type EnumSecurityLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.SecurityLevel | EnumSecurityLevelFieldRefInput<$PrismaModel>
    in?: $Enums.SecurityLevel[] | ListEnumSecurityLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecurityLevel[] | ListEnumSecurityLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumSecurityLevelFilter<$PrismaModel> | $Enums.SecurityLevel
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    metadata?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    sessionId?: SortOrder
    clientFingerprint?: SortOrder
    checksum?: SortOrder
    digitalSignature?: SortOrder
    performedAt?: SortOrder
    createdAt?: SortOrder
    securityLevel?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    sessionId?: SortOrder
    clientFingerprint?: SortOrder
    checksum?: SortOrder
    digitalSignature?: SortOrder
    performedAt?: SortOrder
    createdAt?: SortOrder
    securityLevel?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    sessionId?: SortOrder
    clientFingerprint?: SortOrder
    checksum?: SortOrder
    digitalSignature?: SortOrder
    performedAt?: SortOrder
    createdAt?: SortOrder
    securityLevel?: SortOrder
  }

  export type EnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }

  export type EnumAuditEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditEntityType | EnumAuditEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditEntityType[] | ListEnumAuditEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditEntityType[] | ListEnumAuditEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuditEntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumAuditEntityTypeFilter<$PrismaModel>
  }

  export type EnumSecurityLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SecurityLevel | EnumSecurityLevelFieldRefInput<$PrismaModel>
    in?: $Enums.SecurityLevel[] | ListEnumSecurityLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecurityLevel[] | ListEnumSecurityLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumSecurityLevelWithAggregatesFilter<$PrismaModel> | $Enums.SecurityLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSecurityLevelFilter<$PrismaModel>
    _max?: NestedEnumSecurityLevelFilter<$PrismaModel>
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TweetCreateNestedManyWithoutTenantInput = {
    create?: XOR<TweetCreateWithoutTenantInput, TweetUncheckedCreateWithoutTenantInput> | TweetCreateWithoutTenantInput[] | TweetUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TweetCreateOrConnectWithoutTenantInput | TweetCreateOrConnectWithoutTenantInput[]
    createMany?: TweetCreateManyTenantInputEnvelope
    connect?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
  }

  export type NewsCreateNestedManyWithoutTenantInput = {
    create?: XOR<NewsCreateWithoutTenantInput, NewsUncheckedCreateWithoutTenantInput> | NewsCreateWithoutTenantInput[] | NewsUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NewsCreateOrConnectWithoutTenantInput | NewsCreateOrConnectWithoutTenantInput[]
    createMany?: NewsCreateManyTenantInputEnvelope
    connect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
  }

  export type AiAnalysisCreateNestedManyWithoutTenantInput = {
    create?: XOR<AiAnalysisCreateWithoutTenantInput, AiAnalysisUncheckedCreateWithoutTenantInput> | AiAnalysisCreateWithoutTenantInput[] | AiAnalysisUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AiAnalysisCreateOrConnectWithoutTenantInput | AiAnalysisCreateOrConnectWithoutTenantInput[]
    createMany?: AiAnalysisCreateManyTenantInputEnvelope
    connect?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
  }

  export type AlertCreateNestedManyWithoutTenantInput = {
    create?: XOR<AlertCreateWithoutTenantInput, AlertUncheckedCreateWithoutTenantInput> | AlertCreateWithoutTenantInput[] | AlertUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutTenantInput | AlertCreateOrConnectWithoutTenantInput[]
    createMany?: AlertCreateManyTenantInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type AiProcessingQueueCreateNestedManyWithoutTenantInput = {
    create?: XOR<AiProcessingQueueCreateWithoutTenantInput, AiProcessingQueueUncheckedCreateWithoutTenantInput> | AiProcessingQueueCreateWithoutTenantInput[] | AiProcessingQueueUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AiProcessingQueueCreateOrConnectWithoutTenantInput | AiProcessingQueueCreateOrConnectWithoutTenantInput[]
    createMany?: AiProcessingQueueCreateManyTenantInputEnvelope
    connect?: AiProcessingQueueWhereUniqueInput | AiProcessingQueueWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TweetUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TweetCreateWithoutTenantInput, TweetUncheckedCreateWithoutTenantInput> | TweetCreateWithoutTenantInput[] | TweetUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TweetCreateOrConnectWithoutTenantInput | TweetCreateOrConnectWithoutTenantInput[]
    createMany?: TweetCreateManyTenantInputEnvelope
    connect?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
  }

  export type NewsUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<NewsCreateWithoutTenantInput, NewsUncheckedCreateWithoutTenantInput> | NewsCreateWithoutTenantInput[] | NewsUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NewsCreateOrConnectWithoutTenantInput | NewsCreateOrConnectWithoutTenantInput[]
    createMany?: NewsCreateManyTenantInputEnvelope
    connect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
  }

  export type AiAnalysisUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AiAnalysisCreateWithoutTenantInput, AiAnalysisUncheckedCreateWithoutTenantInput> | AiAnalysisCreateWithoutTenantInput[] | AiAnalysisUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AiAnalysisCreateOrConnectWithoutTenantInput | AiAnalysisCreateOrConnectWithoutTenantInput[]
    createMany?: AiAnalysisCreateManyTenantInputEnvelope
    connect?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
  }

  export type AlertUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AlertCreateWithoutTenantInput, AlertUncheckedCreateWithoutTenantInput> | AlertCreateWithoutTenantInput[] | AlertUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutTenantInput | AlertCreateOrConnectWithoutTenantInput[]
    createMany?: AlertCreateManyTenantInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type AiProcessingQueueUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AiProcessingQueueCreateWithoutTenantInput, AiProcessingQueueUncheckedCreateWithoutTenantInput> | AiProcessingQueueCreateWithoutTenantInput[] | AiProcessingQueueUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AiProcessingQueueCreateOrConnectWithoutTenantInput | AiProcessingQueueCreateOrConnectWithoutTenantInput[]
    createMany?: AiProcessingQueueCreateManyTenantInputEnvelope
    connect?: AiProcessingQueueWhereUniqueInput | AiProcessingQueueWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumTenantTypeFieldUpdateOperationsInput = {
    set?: $Enums.TenantType
  }

  export type EnumTenantStatusFieldUpdateOperationsInput = {
    set?: $Enums.TenantStatus
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TweetUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TweetCreateWithoutTenantInput, TweetUncheckedCreateWithoutTenantInput> | TweetCreateWithoutTenantInput[] | TweetUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TweetCreateOrConnectWithoutTenantInput | TweetCreateOrConnectWithoutTenantInput[]
    upsert?: TweetUpsertWithWhereUniqueWithoutTenantInput | TweetUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TweetCreateManyTenantInputEnvelope
    set?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
    disconnect?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
    delete?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
    connect?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
    update?: TweetUpdateWithWhereUniqueWithoutTenantInput | TweetUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TweetUpdateManyWithWhereWithoutTenantInput | TweetUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TweetScalarWhereInput | TweetScalarWhereInput[]
  }

  export type NewsUpdateManyWithoutTenantNestedInput = {
    create?: XOR<NewsCreateWithoutTenantInput, NewsUncheckedCreateWithoutTenantInput> | NewsCreateWithoutTenantInput[] | NewsUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NewsCreateOrConnectWithoutTenantInput | NewsCreateOrConnectWithoutTenantInput[]
    upsert?: NewsUpsertWithWhereUniqueWithoutTenantInput | NewsUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: NewsCreateManyTenantInputEnvelope
    set?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    disconnect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    delete?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    connect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    update?: NewsUpdateWithWhereUniqueWithoutTenantInput | NewsUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: NewsUpdateManyWithWhereWithoutTenantInput | NewsUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: NewsScalarWhereInput | NewsScalarWhereInput[]
  }

  export type AiAnalysisUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AiAnalysisCreateWithoutTenantInput, AiAnalysisUncheckedCreateWithoutTenantInput> | AiAnalysisCreateWithoutTenantInput[] | AiAnalysisUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AiAnalysisCreateOrConnectWithoutTenantInput | AiAnalysisCreateOrConnectWithoutTenantInput[]
    upsert?: AiAnalysisUpsertWithWhereUniqueWithoutTenantInput | AiAnalysisUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AiAnalysisCreateManyTenantInputEnvelope
    set?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
    disconnect?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
    delete?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
    connect?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
    update?: AiAnalysisUpdateWithWhereUniqueWithoutTenantInput | AiAnalysisUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AiAnalysisUpdateManyWithWhereWithoutTenantInput | AiAnalysisUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AiAnalysisScalarWhereInput | AiAnalysisScalarWhereInput[]
  }

  export type AlertUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AlertCreateWithoutTenantInput, AlertUncheckedCreateWithoutTenantInput> | AlertCreateWithoutTenantInput[] | AlertUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutTenantInput | AlertCreateOrConnectWithoutTenantInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutTenantInput | AlertUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AlertCreateManyTenantInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutTenantInput | AlertUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutTenantInput | AlertUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type AiProcessingQueueUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AiProcessingQueueCreateWithoutTenantInput, AiProcessingQueueUncheckedCreateWithoutTenantInput> | AiProcessingQueueCreateWithoutTenantInput[] | AiProcessingQueueUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AiProcessingQueueCreateOrConnectWithoutTenantInput | AiProcessingQueueCreateOrConnectWithoutTenantInput[]
    upsert?: AiProcessingQueueUpsertWithWhereUniqueWithoutTenantInput | AiProcessingQueueUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AiProcessingQueueCreateManyTenantInputEnvelope
    set?: AiProcessingQueueWhereUniqueInput | AiProcessingQueueWhereUniqueInput[]
    disconnect?: AiProcessingQueueWhereUniqueInput | AiProcessingQueueWhereUniqueInput[]
    delete?: AiProcessingQueueWhereUniqueInput | AiProcessingQueueWhereUniqueInput[]
    connect?: AiProcessingQueueWhereUniqueInput | AiProcessingQueueWhereUniqueInput[]
    update?: AiProcessingQueueUpdateWithWhereUniqueWithoutTenantInput | AiProcessingQueueUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AiProcessingQueueUpdateManyWithWhereWithoutTenantInput | AiProcessingQueueUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AiProcessingQueueScalarWhereInput | AiProcessingQueueScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutTenantInput | AuditLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutTenantInput | AuditLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutTenantInput | AuditLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TweetUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TweetCreateWithoutTenantInput, TweetUncheckedCreateWithoutTenantInput> | TweetCreateWithoutTenantInput[] | TweetUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TweetCreateOrConnectWithoutTenantInput | TweetCreateOrConnectWithoutTenantInput[]
    upsert?: TweetUpsertWithWhereUniqueWithoutTenantInput | TweetUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TweetCreateManyTenantInputEnvelope
    set?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
    disconnect?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
    delete?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
    connect?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
    update?: TweetUpdateWithWhereUniqueWithoutTenantInput | TweetUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TweetUpdateManyWithWhereWithoutTenantInput | TweetUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TweetScalarWhereInput | TweetScalarWhereInput[]
  }

  export type NewsUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<NewsCreateWithoutTenantInput, NewsUncheckedCreateWithoutTenantInput> | NewsCreateWithoutTenantInput[] | NewsUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NewsCreateOrConnectWithoutTenantInput | NewsCreateOrConnectWithoutTenantInput[]
    upsert?: NewsUpsertWithWhereUniqueWithoutTenantInput | NewsUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: NewsCreateManyTenantInputEnvelope
    set?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    disconnect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    delete?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    connect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    update?: NewsUpdateWithWhereUniqueWithoutTenantInput | NewsUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: NewsUpdateManyWithWhereWithoutTenantInput | NewsUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: NewsScalarWhereInput | NewsScalarWhereInput[]
  }

  export type AiAnalysisUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AiAnalysisCreateWithoutTenantInput, AiAnalysisUncheckedCreateWithoutTenantInput> | AiAnalysisCreateWithoutTenantInput[] | AiAnalysisUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AiAnalysisCreateOrConnectWithoutTenantInput | AiAnalysisCreateOrConnectWithoutTenantInput[]
    upsert?: AiAnalysisUpsertWithWhereUniqueWithoutTenantInput | AiAnalysisUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AiAnalysisCreateManyTenantInputEnvelope
    set?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
    disconnect?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
    delete?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
    connect?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
    update?: AiAnalysisUpdateWithWhereUniqueWithoutTenantInput | AiAnalysisUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AiAnalysisUpdateManyWithWhereWithoutTenantInput | AiAnalysisUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AiAnalysisScalarWhereInput | AiAnalysisScalarWhereInput[]
  }

  export type AlertUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AlertCreateWithoutTenantInput, AlertUncheckedCreateWithoutTenantInput> | AlertCreateWithoutTenantInput[] | AlertUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutTenantInput | AlertCreateOrConnectWithoutTenantInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutTenantInput | AlertUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AlertCreateManyTenantInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutTenantInput | AlertUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutTenantInput | AlertUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type AiProcessingQueueUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AiProcessingQueueCreateWithoutTenantInput, AiProcessingQueueUncheckedCreateWithoutTenantInput> | AiProcessingQueueCreateWithoutTenantInput[] | AiProcessingQueueUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AiProcessingQueueCreateOrConnectWithoutTenantInput | AiProcessingQueueCreateOrConnectWithoutTenantInput[]
    upsert?: AiProcessingQueueUpsertWithWhereUniqueWithoutTenantInput | AiProcessingQueueUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AiProcessingQueueCreateManyTenantInputEnvelope
    set?: AiProcessingQueueWhereUniqueInput | AiProcessingQueueWhereUniqueInput[]
    disconnect?: AiProcessingQueueWhereUniqueInput | AiProcessingQueueWhereUniqueInput[]
    delete?: AiProcessingQueueWhereUniqueInput | AiProcessingQueueWhereUniqueInput[]
    connect?: AiProcessingQueueWhereUniqueInput | AiProcessingQueueWhereUniqueInput[]
    update?: AiProcessingQueueUpdateWithWhereUniqueWithoutTenantInput | AiProcessingQueueUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AiProcessingQueueUpdateManyWithWhereWithoutTenantInput | AiProcessingQueueUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AiProcessingQueueScalarWhereInput | AiProcessingQueueScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutTenantInput | AuditLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutTenantInput | AuditLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutTenantInput | AuditLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type AlertCreateNestedManyWithoutUserInput = {
    create?: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput> | AlertCreateWithoutUserInput[] | AlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutUserInput | AlertCreateOrConnectWithoutUserInput[]
    createMany?: AlertCreateManyUserInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AlertUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput> | AlertCreateWithoutUserInput[] | AlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutUserInput | AlertCreateOrConnectWithoutUserInput[]
    createMany?: AlertCreateManyUserInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type TenantUpdateOneWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type AlertUpdateManyWithoutUserNestedInput = {
    create?: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput> | AlertCreateWithoutUserInput[] | AlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutUserInput | AlertCreateOrConnectWithoutUserInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutUserInput | AlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AlertCreateManyUserInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutUserInput | AlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutUserInput | AlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type AlertUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput> | AlertCreateWithoutUserInput[] | AlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutUserInput | AlertCreateOrConnectWithoutUserInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutUserInput | AlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AlertCreateManyUserInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutUserInput | AlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutUserInput | AlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type TweetCreateNestedManyWithoutMediaSourceInput = {
    create?: XOR<TweetCreateWithoutMediaSourceInput, TweetUncheckedCreateWithoutMediaSourceInput> | TweetCreateWithoutMediaSourceInput[] | TweetUncheckedCreateWithoutMediaSourceInput[]
    connectOrCreate?: TweetCreateOrConnectWithoutMediaSourceInput | TweetCreateOrConnectWithoutMediaSourceInput[]
    createMany?: TweetCreateManyMediaSourceInputEnvelope
    connect?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
  }

  export type NewsCreateNestedManyWithoutMediaSourceInput = {
    create?: XOR<NewsCreateWithoutMediaSourceInput, NewsUncheckedCreateWithoutMediaSourceInput> | NewsCreateWithoutMediaSourceInput[] | NewsUncheckedCreateWithoutMediaSourceInput[]
    connectOrCreate?: NewsCreateOrConnectWithoutMediaSourceInput | NewsCreateOrConnectWithoutMediaSourceInput[]
    createMany?: NewsCreateManyMediaSourceInputEnvelope
    connect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
  }

  export type TweetUncheckedCreateNestedManyWithoutMediaSourceInput = {
    create?: XOR<TweetCreateWithoutMediaSourceInput, TweetUncheckedCreateWithoutMediaSourceInput> | TweetCreateWithoutMediaSourceInput[] | TweetUncheckedCreateWithoutMediaSourceInput[]
    connectOrCreate?: TweetCreateOrConnectWithoutMediaSourceInput | TweetCreateOrConnectWithoutMediaSourceInput[]
    createMany?: TweetCreateManyMediaSourceInputEnvelope
    connect?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
  }

  export type NewsUncheckedCreateNestedManyWithoutMediaSourceInput = {
    create?: XOR<NewsCreateWithoutMediaSourceInput, NewsUncheckedCreateWithoutMediaSourceInput> | NewsCreateWithoutMediaSourceInput[] | NewsUncheckedCreateWithoutMediaSourceInput[]
    connectOrCreate?: NewsCreateOrConnectWithoutMediaSourceInput | NewsCreateOrConnectWithoutMediaSourceInput[]
    createMany?: NewsCreateManyMediaSourceInputEnvelope
    connect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
  }

  export type EnumMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaType
  }

  export type TweetUpdateManyWithoutMediaSourceNestedInput = {
    create?: XOR<TweetCreateWithoutMediaSourceInput, TweetUncheckedCreateWithoutMediaSourceInput> | TweetCreateWithoutMediaSourceInput[] | TweetUncheckedCreateWithoutMediaSourceInput[]
    connectOrCreate?: TweetCreateOrConnectWithoutMediaSourceInput | TweetCreateOrConnectWithoutMediaSourceInput[]
    upsert?: TweetUpsertWithWhereUniqueWithoutMediaSourceInput | TweetUpsertWithWhereUniqueWithoutMediaSourceInput[]
    createMany?: TweetCreateManyMediaSourceInputEnvelope
    set?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
    disconnect?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
    delete?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
    connect?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
    update?: TweetUpdateWithWhereUniqueWithoutMediaSourceInput | TweetUpdateWithWhereUniqueWithoutMediaSourceInput[]
    updateMany?: TweetUpdateManyWithWhereWithoutMediaSourceInput | TweetUpdateManyWithWhereWithoutMediaSourceInput[]
    deleteMany?: TweetScalarWhereInput | TweetScalarWhereInput[]
  }

  export type NewsUpdateManyWithoutMediaSourceNestedInput = {
    create?: XOR<NewsCreateWithoutMediaSourceInput, NewsUncheckedCreateWithoutMediaSourceInput> | NewsCreateWithoutMediaSourceInput[] | NewsUncheckedCreateWithoutMediaSourceInput[]
    connectOrCreate?: NewsCreateOrConnectWithoutMediaSourceInput | NewsCreateOrConnectWithoutMediaSourceInput[]
    upsert?: NewsUpsertWithWhereUniqueWithoutMediaSourceInput | NewsUpsertWithWhereUniqueWithoutMediaSourceInput[]
    createMany?: NewsCreateManyMediaSourceInputEnvelope
    set?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    disconnect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    delete?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    connect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    update?: NewsUpdateWithWhereUniqueWithoutMediaSourceInput | NewsUpdateWithWhereUniqueWithoutMediaSourceInput[]
    updateMany?: NewsUpdateManyWithWhereWithoutMediaSourceInput | NewsUpdateManyWithWhereWithoutMediaSourceInput[]
    deleteMany?: NewsScalarWhereInput | NewsScalarWhereInput[]
  }

  export type TweetUncheckedUpdateManyWithoutMediaSourceNestedInput = {
    create?: XOR<TweetCreateWithoutMediaSourceInput, TweetUncheckedCreateWithoutMediaSourceInput> | TweetCreateWithoutMediaSourceInput[] | TweetUncheckedCreateWithoutMediaSourceInput[]
    connectOrCreate?: TweetCreateOrConnectWithoutMediaSourceInput | TweetCreateOrConnectWithoutMediaSourceInput[]
    upsert?: TweetUpsertWithWhereUniqueWithoutMediaSourceInput | TweetUpsertWithWhereUniqueWithoutMediaSourceInput[]
    createMany?: TweetCreateManyMediaSourceInputEnvelope
    set?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
    disconnect?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
    delete?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
    connect?: TweetWhereUniqueInput | TweetWhereUniqueInput[]
    update?: TweetUpdateWithWhereUniqueWithoutMediaSourceInput | TweetUpdateWithWhereUniqueWithoutMediaSourceInput[]
    updateMany?: TweetUpdateManyWithWhereWithoutMediaSourceInput | TweetUpdateManyWithWhereWithoutMediaSourceInput[]
    deleteMany?: TweetScalarWhereInput | TweetScalarWhereInput[]
  }

  export type NewsUncheckedUpdateManyWithoutMediaSourceNestedInput = {
    create?: XOR<NewsCreateWithoutMediaSourceInput, NewsUncheckedCreateWithoutMediaSourceInput> | NewsCreateWithoutMediaSourceInput[] | NewsUncheckedCreateWithoutMediaSourceInput[]
    connectOrCreate?: NewsCreateOrConnectWithoutMediaSourceInput | NewsCreateOrConnectWithoutMediaSourceInput[]
    upsert?: NewsUpsertWithWhereUniqueWithoutMediaSourceInput | NewsUpsertWithWhereUniqueWithoutMediaSourceInput[]
    createMany?: NewsCreateManyMediaSourceInputEnvelope
    set?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    disconnect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    delete?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    connect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    update?: NewsUpdateWithWhereUniqueWithoutMediaSourceInput | NewsUpdateWithWhereUniqueWithoutMediaSourceInput[]
    updateMany?: NewsUpdateManyWithWhereWithoutMediaSourceInput | NewsUpdateManyWithWhereWithoutMediaSourceInput[]
    deleteMany?: NewsScalarWhereInput | NewsScalarWhereInput[]
  }

  export type TweetCreatehashtagsInput = {
    set: string[]
  }

  export type TweetCreatementionsInput = {
    set: string[]
  }

  export type TenantCreateNestedOneWithoutTweetsInput = {
    create?: XOR<TenantCreateWithoutTweetsInput, TenantUncheckedCreateWithoutTweetsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTweetsInput
    connect?: TenantWhereUniqueInput
  }

  export type MediaSourceCreateNestedOneWithoutTweetsInput = {
    create?: XOR<MediaSourceCreateWithoutTweetsInput, MediaSourceUncheckedCreateWithoutTweetsInput>
    connectOrCreate?: MediaSourceCreateOrConnectWithoutTweetsInput
    connect?: MediaSourceWhereUniqueInput
  }

  export type NewsCreateNestedManyWithoutTweetInput = {
    create?: XOR<NewsCreateWithoutTweetInput, NewsUncheckedCreateWithoutTweetInput> | NewsCreateWithoutTweetInput[] | NewsUncheckedCreateWithoutTweetInput[]
    connectOrCreate?: NewsCreateOrConnectWithoutTweetInput | NewsCreateOrConnectWithoutTweetInput[]
    createMany?: NewsCreateManyTweetInputEnvelope
    connect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
  }

  export type AiAnalysisCreateNestedManyWithoutTweetInput = {
    create?: XOR<AiAnalysisCreateWithoutTweetInput, AiAnalysisUncheckedCreateWithoutTweetInput> | AiAnalysisCreateWithoutTweetInput[] | AiAnalysisUncheckedCreateWithoutTweetInput[]
    connectOrCreate?: AiAnalysisCreateOrConnectWithoutTweetInput | AiAnalysisCreateOrConnectWithoutTweetInput[]
    createMany?: AiAnalysisCreateManyTweetInputEnvelope
    connect?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
  }

  export type TweetMediaCreateNestedManyWithoutTweetInput = {
    create?: XOR<TweetMediaCreateWithoutTweetInput, TweetMediaUncheckedCreateWithoutTweetInput> | TweetMediaCreateWithoutTweetInput[] | TweetMediaUncheckedCreateWithoutTweetInput[]
    connectOrCreate?: TweetMediaCreateOrConnectWithoutTweetInput | TweetMediaCreateOrConnectWithoutTweetInput[]
    createMany?: TweetMediaCreateManyTweetInputEnvelope
    connect?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
  }

  export type NewsUncheckedCreateNestedManyWithoutTweetInput = {
    create?: XOR<NewsCreateWithoutTweetInput, NewsUncheckedCreateWithoutTweetInput> | NewsCreateWithoutTweetInput[] | NewsUncheckedCreateWithoutTweetInput[]
    connectOrCreate?: NewsCreateOrConnectWithoutTweetInput | NewsCreateOrConnectWithoutTweetInput[]
    createMany?: NewsCreateManyTweetInputEnvelope
    connect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
  }

  export type AiAnalysisUncheckedCreateNestedManyWithoutTweetInput = {
    create?: XOR<AiAnalysisCreateWithoutTweetInput, AiAnalysisUncheckedCreateWithoutTweetInput> | AiAnalysisCreateWithoutTweetInput[] | AiAnalysisUncheckedCreateWithoutTweetInput[]
    connectOrCreate?: AiAnalysisCreateOrConnectWithoutTweetInput | AiAnalysisCreateOrConnectWithoutTweetInput[]
    createMany?: AiAnalysisCreateManyTweetInputEnvelope
    connect?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
  }

  export type TweetMediaUncheckedCreateNestedManyWithoutTweetInput = {
    create?: XOR<TweetMediaCreateWithoutTweetInput, TweetMediaUncheckedCreateWithoutTweetInput> | TweetMediaCreateWithoutTweetInput[] | TweetMediaUncheckedCreateWithoutTweetInput[]
    connectOrCreate?: TweetMediaCreateOrConnectWithoutTweetInput | TweetMediaCreateOrConnectWithoutTweetInput[]
    createMany?: TweetMediaCreateManyTweetInputEnvelope
    connect?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
  }

  export type TweetUpdatehashtagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TweetUpdatementionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TenantUpdateOneRequiredWithoutTweetsNestedInput = {
    create?: XOR<TenantCreateWithoutTweetsInput, TenantUncheckedCreateWithoutTweetsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTweetsInput
    upsert?: TenantUpsertWithoutTweetsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutTweetsInput, TenantUpdateWithoutTweetsInput>, TenantUncheckedUpdateWithoutTweetsInput>
  }

  export type MediaSourceUpdateOneRequiredWithoutTweetsNestedInput = {
    create?: XOR<MediaSourceCreateWithoutTweetsInput, MediaSourceUncheckedCreateWithoutTweetsInput>
    connectOrCreate?: MediaSourceCreateOrConnectWithoutTweetsInput
    upsert?: MediaSourceUpsertWithoutTweetsInput
    connect?: MediaSourceWhereUniqueInput
    update?: XOR<XOR<MediaSourceUpdateToOneWithWhereWithoutTweetsInput, MediaSourceUpdateWithoutTweetsInput>, MediaSourceUncheckedUpdateWithoutTweetsInput>
  }

  export type NewsUpdateManyWithoutTweetNestedInput = {
    create?: XOR<NewsCreateWithoutTweetInput, NewsUncheckedCreateWithoutTweetInput> | NewsCreateWithoutTweetInput[] | NewsUncheckedCreateWithoutTweetInput[]
    connectOrCreate?: NewsCreateOrConnectWithoutTweetInput | NewsCreateOrConnectWithoutTweetInput[]
    upsert?: NewsUpsertWithWhereUniqueWithoutTweetInput | NewsUpsertWithWhereUniqueWithoutTweetInput[]
    createMany?: NewsCreateManyTweetInputEnvelope
    set?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    disconnect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    delete?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    connect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    update?: NewsUpdateWithWhereUniqueWithoutTweetInput | NewsUpdateWithWhereUniqueWithoutTweetInput[]
    updateMany?: NewsUpdateManyWithWhereWithoutTweetInput | NewsUpdateManyWithWhereWithoutTweetInput[]
    deleteMany?: NewsScalarWhereInput | NewsScalarWhereInput[]
  }

  export type AiAnalysisUpdateManyWithoutTweetNestedInput = {
    create?: XOR<AiAnalysisCreateWithoutTweetInput, AiAnalysisUncheckedCreateWithoutTweetInput> | AiAnalysisCreateWithoutTweetInput[] | AiAnalysisUncheckedCreateWithoutTweetInput[]
    connectOrCreate?: AiAnalysisCreateOrConnectWithoutTweetInput | AiAnalysisCreateOrConnectWithoutTweetInput[]
    upsert?: AiAnalysisUpsertWithWhereUniqueWithoutTweetInput | AiAnalysisUpsertWithWhereUniqueWithoutTweetInput[]
    createMany?: AiAnalysisCreateManyTweetInputEnvelope
    set?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
    disconnect?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
    delete?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
    connect?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
    update?: AiAnalysisUpdateWithWhereUniqueWithoutTweetInput | AiAnalysisUpdateWithWhereUniqueWithoutTweetInput[]
    updateMany?: AiAnalysisUpdateManyWithWhereWithoutTweetInput | AiAnalysisUpdateManyWithWhereWithoutTweetInput[]
    deleteMany?: AiAnalysisScalarWhereInput | AiAnalysisScalarWhereInput[]
  }

  export type TweetMediaUpdateManyWithoutTweetNestedInput = {
    create?: XOR<TweetMediaCreateWithoutTweetInput, TweetMediaUncheckedCreateWithoutTweetInput> | TweetMediaCreateWithoutTweetInput[] | TweetMediaUncheckedCreateWithoutTweetInput[]
    connectOrCreate?: TweetMediaCreateOrConnectWithoutTweetInput | TweetMediaCreateOrConnectWithoutTweetInput[]
    upsert?: TweetMediaUpsertWithWhereUniqueWithoutTweetInput | TweetMediaUpsertWithWhereUniqueWithoutTweetInput[]
    createMany?: TweetMediaCreateManyTweetInputEnvelope
    set?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
    disconnect?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
    delete?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
    connect?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
    update?: TweetMediaUpdateWithWhereUniqueWithoutTweetInput | TweetMediaUpdateWithWhereUniqueWithoutTweetInput[]
    updateMany?: TweetMediaUpdateManyWithWhereWithoutTweetInput | TweetMediaUpdateManyWithWhereWithoutTweetInput[]
    deleteMany?: TweetMediaScalarWhereInput | TweetMediaScalarWhereInput[]
  }

  export type NewsUncheckedUpdateManyWithoutTweetNestedInput = {
    create?: XOR<NewsCreateWithoutTweetInput, NewsUncheckedCreateWithoutTweetInput> | NewsCreateWithoutTweetInput[] | NewsUncheckedCreateWithoutTweetInput[]
    connectOrCreate?: NewsCreateOrConnectWithoutTweetInput | NewsCreateOrConnectWithoutTweetInput[]
    upsert?: NewsUpsertWithWhereUniqueWithoutTweetInput | NewsUpsertWithWhereUniqueWithoutTweetInput[]
    createMany?: NewsCreateManyTweetInputEnvelope
    set?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    disconnect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    delete?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    connect?: NewsWhereUniqueInput | NewsWhereUniqueInput[]
    update?: NewsUpdateWithWhereUniqueWithoutTweetInput | NewsUpdateWithWhereUniqueWithoutTweetInput[]
    updateMany?: NewsUpdateManyWithWhereWithoutTweetInput | NewsUpdateManyWithWhereWithoutTweetInput[]
    deleteMany?: NewsScalarWhereInput | NewsScalarWhereInput[]
  }

  export type AiAnalysisUncheckedUpdateManyWithoutTweetNestedInput = {
    create?: XOR<AiAnalysisCreateWithoutTweetInput, AiAnalysisUncheckedCreateWithoutTweetInput> | AiAnalysisCreateWithoutTweetInput[] | AiAnalysisUncheckedCreateWithoutTweetInput[]
    connectOrCreate?: AiAnalysisCreateOrConnectWithoutTweetInput | AiAnalysisCreateOrConnectWithoutTweetInput[]
    upsert?: AiAnalysisUpsertWithWhereUniqueWithoutTweetInput | AiAnalysisUpsertWithWhereUniqueWithoutTweetInput[]
    createMany?: AiAnalysisCreateManyTweetInputEnvelope
    set?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
    disconnect?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
    delete?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
    connect?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
    update?: AiAnalysisUpdateWithWhereUniqueWithoutTweetInput | AiAnalysisUpdateWithWhereUniqueWithoutTweetInput[]
    updateMany?: AiAnalysisUpdateManyWithWhereWithoutTweetInput | AiAnalysisUpdateManyWithWhereWithoutTweetInput[]
    deleteMany?: AiAnalysisScalarWhereInput | AiAnalysisScalarWhereInput[]
  }

  export type TweetMediaUncheckedUpdateManyWithoutTweetNestedInput = {
    create?: XOR<TweetMediaCreateWithoutTweetInput, TweetMediaUncheckedCreateWithoutTweetInput> | TweetMediaCreateWithoutTweetInput[] | TweetMediaUncheckedCreateWithoutTweetInput[]
    connectOrCreate?: TweetMediaCreateOrConnectWithoutTweetInput | TweetMediaCreateOrConnectWithoutTweetInput[]
    upsert?: TweetMediaUpsertWithWhereUniqueWithoutTweetInput | TweetMediaUpsertWithWhereUniqueWithoutTweetInput[]
    createMany?: TweetMediaCreateManyTweetInputEnvelope
    set?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
    disconnect?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
    delete?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
    connect?: TweetMediaWhereUniqueInput | TweetMediaWhereUniqueInput[]
    update?: TweetMediaUpdateWithWhereUniqueWithoutTweetInput | TweetMediaUpdateWithWhereUniqueWithoutTweetInput[]
    updateMany?: TweetMediaUpdateManyWithWhereWithoutTweetInput | TweetMediaUpdateManyWithWhereWithoutTweetInput[]
    deleteMany?: TweetMediaScalarWhereInput | TweetMediaScalarWhereInput[]
  }

  export type TweetCreateNestedOneWithoutTweetMediaInput = {
    create?: XOR<TweetCreateWithoutTweetMediaInput, TweetUncheckedCreateWithoutTweetMediaInput>
    connectOrCreate?: TweetCreateOrConnectWithoutTweetMediaInput
    connect?: TweetWhereUniqueInput
  }

  export type TweetUpdateOneRequiredWithoutTweetMediaNestedInput = {
    create?: XOR<TweetCreateWithoutTweetMediaInput, TweetUncheckedCreateWithoutTweetMediaInput>
    connectOrCreate?: TweetCreateOrConnectWithoutTweetMediaInput
    upsert?: TweetUpsertWithoutTweetMediaInput
    connect?: TweetWhereUniqueInput
    update?: XOR<XOR<TweetUpdateToOneWithWhereWithoutTweetMediaInput, TweetUpdateWithoutTweetMediaInput>, TweetUncheckedUpdateWithoutTweetMediaInput>
  }

  export type TenantCreateNestedOneWithoutNewsInput = {
    create?: XOR<TenantCreateWithoutNewsInput, TenantUncheckedCreateWithoutNewsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutNewsInput
    connect?: TenantWhereUniqueInput
  }

  export type TweetCreateNestedOneWithoutNewsInput = {
    create?: XOR<TweetCreateWithoutNewsInput, TweetUncheckedCreateWithoutNewsInput>
    connectOrCreate?: TweetCreateOrConnectWithoutNewsInput
    connect?: TweetWhereUniqueInput
  }

  export type MediaSourceCreateNestedOneWithoutNewsInput = {
    create?: XOR<MediaSourceCreateWithoutNewsInput, MediaSourceUncheckedCreateWithoutNewsInput>
    connectOrCreate?: MediaSourceCreateOrConnectWithoutNewsInput
    connect?: MediaSourceWhereUniqueInput
  }

  export type AiAnalysisCreateNestedManyWithoutNewsInput = {
    create?: XOR<AiAnalysisCreateWithoutNewsInput, AiAnalysisUncheckedCreateWithoutNewsInput> | AiAnalysisCreateWithoutNewsInput[] | AiAnalysisUncheckedCreateWithoutNewsInput[]
    connectOrCreate?: AiAnalysisCreateOrConnectWithoutNewsInput | AiAnalysisCreateOrConnectWithoutNewsInput[]
    createMany?: AiAnalysisCreateManyNewsInputEnvelope
    connect?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
  }

  export type AiAnalysisUncheckedCreateNestedManyWithoutNewsInput = {
    create?: XOR<AiAnalysisCreateWithoutNewsInput, AiAnalysisUncheckedCreateWithoutNewsInput> | AiAnalysisCreateWithoutNewsInput[] | AiAnalysisUncheckedCreateWithoutNewsInput[]
    connectOrCreate?: AiAnalysisCreateOrConnectWithoutNewsInput | AiAnalysisCreateOrConnectWithoutNewsInput[]
    createMany?: AiAnalysisCreateManyNewsInputEnvelope
    connect?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutNewsNestedInput = {
    create?: XOR<TenantCreateWithoutNewsInput, TenantUncheckedCreateWithoutNewsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutNewsInput
    upsert?: TenantUpsertWithoutNewsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutNewsInput, TenantUpdateWithoutNewsInput>, TenantUncheckedUpdateWithoutNewsInput>
  }

  export type TweetUpdateOneRequiredWithoutNewsNestedInput = {
    create?: XOR<TweetCreateWithoutNewsInput, TweetUncheckedCreateWithoutNewsInput>
    connectOrCreate?: TweetCreateOrConnectWithoutNewsInput
    upsert?: TweetUpsertWithoutNewsInput
    connect?: TweetWhereUniqueInput
    update?: XOR<XOR<TweetUpdateToOneWithWhereWithoutNewsInput, TweetUpdateWithoutNewsInput>, TweetUncheckedUpdateWithoutNewsInput>
  }

  export type MediaSourceUpdateOneRequiredWithoutNewsNestedInput = {
    create?: XOR<MediaSourceCreateWithoutNewsInput, MediaSourceUncheckedCreateWithoutNewsInput>
    connectOrCreate?: MediaSourceCreateOrConnectWithoutNewsInput
    upsert?: MediaSourceUpsertWithoutNewsInput
    connect?: MediaSourceWhereUniqueInput
    update?: XOR<XOR<MediaSourceUpdateToOneWithWhereWithoutNewsInput, MediaSourceUpdateWithoutNewsInput>, MediaSourceUncheckedUpdateWithoutNewsInput>
  }

  export type AiAnalysisUpdateManyWithoutNewsNestedInput = {
    create?: XOR<AiAnalysisCreateWithoutNewsInput, AiAnalysisUncheckedCreateWithoutNewsInput> | AiAnalysisCreateWithoutNewsInput[] | AiAnalysisUncheckedCreateWithoutNewsInput[]
    connectOrCreate?: AiAnalysisCreateOrConnectWithoutNewsInput | AiAnalysisCreateOrConnectWithoutNewsInput[]
    upsert?: AiAnalysisUpsertWithWhereUniqueWithoutNewsInput | AiAnalysisUpsertWithWhereUniqueWithoutNewsInput[]
    createMany?: AiAnalysisCreateManyNewsInputEnvelope
    set?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
    disconnect?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
    delete?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
    connect?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
    update?: AiAnalysisUpdateWithWhereUniqueWithoutNewsInput | AiAnalysisUpdateWithWhereUniqueWithoutNewsInput[]
    updateMany?: AiAnalysisUpdateManyWithWhereWithoutNewsInput | AiAnalysisUpdateManyWithWhereWithoutNewsInput[]
    deleteMany?: AiAnalysisScalarWhereInput | AiAnalysisScalarWhereInput[]
  }

  export type AiAnalysisUncheckedUpdateManyWithoutNewsNestedInput = {
    create?: XOR<AiAnalysisCreateWithoutNewsInput, AiAnalysisUncheckedCreateWithoutNewsInput> | AiAnalysisCreateWithoutNewsInput[] | AiAnalysisUncheckedCreateWithoutNewsInput[]
    connectOrCreate?: AiAnalysisCreateOrConnectWithoutNewsInput | AiAnalysisCreateOrConnectWithoutNewsInput[]
    upsert?: AiAnalysisUpsertWithWhereUniqueWithoutNewsInput | AiAnalysisUpsertWithWhereUniqueWithoutNewsInput[]
    createMany?: AiAnalysisCreateManyNewsInputEnvelope
    set?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
    disconnect?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
    delete?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
    connect?: AiAnalysisWhereUniqueInput | AiAnalysisWhereUniqueInput[]
    update?: AiAnalysisUpdateWithWhereUniqueWithoutNewsInput | AiAnalysisUpdateWithWhereUniqueWithoutNewsInput[]
    updateMany?: AiAnalysisUpdateManyWithWhereWithoutNewsInput | AiAnalysisUpdateManyWithWhereWithoutNewsInput[]
    deleteMany?: AiAnalysisScalarWhereInput | AiAnalysisScalarWhereInput[]
  }

  export type AiAnalysisCreatetagsInput = {
    set: string[]
  }

  export type TenantCreateNestedOneWithoutAiAnalysisInput = {
    create?: XOR<TenantCreateWithoutAiAnalysisInput, TenantUncheckedCreateWithoutAiAnalysisInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAiAnalysisInput
    connect?: TenantWhereUniqueInput
  }

  export type TweetCreateNestedOneWithoutAiAnalysisInput = {
    create?: XOR<TweetCreateWithoutAiAnalysisInput, TweetUncheckedCreateWithoutAiAnalysisInput>
    connectOrCreate?: TweetCreateOrConnectWithoutAiAnalysisInput
    connect?: TweetWhereUniqueInput
  }

  export type NewsCreateNestedOneWithoutAiAnalysisInput = {
    create?: XOR<NewsCreateWithoutAiAnalysisInput, NewsUncheckedCreateWithoutAiAnalysisInput>
    connectOrCreate?: NewsCreateOrConnectWithoutAiAnalysisInput
    connect?: NewsWhereUniqueInput
  }

  export type EnumAnalysisTypeFieldUpdateOperationsInput = {
    set?: $Enums.AnalysisType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumThreatLevelFieldUpdateOperationsInput = {
    set?: $Enums.ThreatLevel | null
  }

  export type AiAnalysisUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TenantUpdateOneRequiredWithoutAiAnalysisNestedInput = {
    create?: XOR<TenantCreateWithoutAiAnalysisInput, TenantUncheckedCreateWithoutAiAnalysisInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAiAnalysisInput
    upsert?: TenantUpsertWithoutAiAnalysisInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAiAnalysisInput, TenantUpdateWithoutAiAnalysisInput>, TenantUncheckedUpdateWithoutAiAnalysisInput>
  }

  export type TweetUpdateOneWithoutAiAnalysisNestedInput = {
    create?: XOR<TweetCreateWithoutAiAnalysisInput, TweetUncheckedCreateWithoutAiAnalysisInput>
    connectOrCreate?: TweetCreateOrConnectWithoutAiAnalysisInput
    upsert?: TweetUpsertWithoutAiAnalysisInput
    disconnect?: TweetWhereInput | boolean
    delete?: TweetWhereInput | boolean
    connect?: TweetWhereUniqueInput
    update?: XOR<XOR<TweetUpdateToOneWithWhereWithoutAiAnalysisInput, TweetUpdateWithoutAiAnalysisInput>, TweetUncheckedUpdateWithoutAiAnalysisInput>
  }

  export type NewsUpdateOneWithoutAiAnalysisNestedInput = {
    create?: XOR<NewsCreateWithoutAiAnalysisInput, NewsUncheckedCreateWithoutAiAnalysisInput>
    connectOrCreate?: NewsCreateOrConnectWithoutAiAnalysisInput
    upsert?: NewsUpsertWithoutAiAnalysisInput
    disconnect?: NewsWhereInput | boolean
    delete?: NewsWhereInput | boolean
    connect?: NewsWhereUniqueInput
    update?: XOR<XOR<NewsUpdateToOneWithWhereWithoutAiAnalysisInput, NewsUpdateWithoutAiAnalysisInput>, NewsUncheckedUpdateWithoutAiAnalysisInput>
  }

  export type TenantCreateNestedOneWithoutAiProcessingQueueInput = {
    create?: XOR<TenantCreateWithoutAiProcessingQueueInput, TenantUncheckedCreateWithoutAiProcessingQueueInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAiProcessingQueueInput
    connect?: TenantWhereUniqueInput
  }

  export type EnumQueueTypeFieldUpdateOperationsInput = {
    set?: $Enums.QueueType
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumQueueStatusFieldUpdateOperationsInput = {
    set?: $Enums.QueueStatus
  }

  export type TenantUpdateOneRequiredWithoutAiProcessingQueueNestedInput = {
    create?: XOR<TenantCreateWithoutAiProcessingQueueInput, TenantUncheckedCreateWithoutAiProcessingQueueInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAiProcessingQueueInput
    upsert?: TenantUpsertWithoutAiProcessingQueueInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAiProcessingQueueInput, TenantUpdateWithoutAiProcessingQueueInput>, TenantUncheckedUpdateWithoutAiProcessingQueueInput>
  }

  export type TenantCreateNestedOneWithoutAlertsInput = {
    create?: XOR<TenantCreateWithoutAlertsInput, TenantUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAlertsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAlertsInput = {
    create?: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAlertTypeFieldUpdateOperationsInput = {
    set?: $Enums.AlertType
  }

  export type EnumAlertSeverityFieldUpdateOperationsInput = {
    set?: $Enums.AlertSeverity
  }

  export type EnumAlertStatusFieldUpdateOperationsInput = {
    set?: $Enums.AlertStatus
  }

  export type TenantUpdateOneRequiredWithoutAlertsNestedInput = {
    create?: XOR<TenantCreateWithoutAlertsInput, TenantUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAlertsInput
    upsert?: TenantUpsertWithoutAlertsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAlertsInput, TenantUpdateWithoutAlertsInput>, TenantUncheckedUpdateWithoutAlertsInput>
  }

  export type UserUpdateOneWithoutAlertsNestedInput = {
    create?: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertsInput
    upsert?: UserUpsertWithoutAlertsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAlertsInput, UserUpdateWithoutAlertsInput>, UserUncheckedUpdateWithoutAlertsInput>
  }

  export type TenantCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditLogsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAuditActionFieldUpdateOperationsInput = {
    set?: $Enums.AuditAction
  }

  export type EnumAuditEntityTypeFieldUpdateOperationsInput = {
    set?: $Enums.AuditEntityType
  }

  export type EnumSecurityLevelFieldUpdateOperationsInput = {
    set?: $Enums.SecurityLevel
  }

  export type TenantUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditLogsInput
    upsert?: TenantUpsertWithoutAuditLogsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAuditLogsInput, TenantUpdateWithoutAuditLogsInput>, TenantUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumTenantTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantType | EnumTenantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantTypeFilter<$PrismaModel> | $Enums.TenantType
  }

  export type NestedEnumTenantStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantStatus | EnumTenantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantStatusFilter<$PrismaModel> | $Enums.TenantStatus
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumTenantTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantType | EnumTenantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantTypeWithAggregatesFilter<$PrismaModel> | $Enums.TenantType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantTypeFilter<$PrismaModel>
    _max?: NestedEnumTenantTypeFilter<$PrismaModel>
  }

  export type NestedEnumTenantStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantStatus | EnumTenantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantStatusWithAggregatesFilter<$PrismaModel> | $Enums.TenantStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantStatusFilter<$PrismaModel>
    _max?: NestedEnumTenantStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type NestedEnumAnalysisTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalysisType | EnumAnalysisTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalysisTypeFilter<$PrismaModel> | $Enums.AnalysisType
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumThreatLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ThreatLevel | EnumThreatLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.ThreatLevel[] | ListEnumThreatLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ThreatLevel[] | ListEnumThreatLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumThreatLevelNullableFilter<$PrismaModel> | $Enums.ThreatLevel | null
  }

  export type NestedEnumAnalysisTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalysisType | EnumAnalysisTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalysisTypeWithAggregatesFilter<$PrismaModel> | $Enums.AnalysisType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnalysisTypeFilter<$PrismaModel>
    _max?: NestedEnumAnalysisTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumThreatLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ThreatLevel | EnumThreatLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.ThreatLevel[] | ListEnumThreatLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ThreatLevel[] | ListEnumThreatLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumThreatLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.ThreatLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumThreatLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumThreatLevelNullableFilter<$PrismaModel>
  }

  export type NestedEnumQueueTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueType | EnumQueueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QueueType[] | ListEnumQueueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueueType[] | ListEnumQueueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQueueTypeFilter<$PrismaModel> | $Enums.QueueType
  }

  export type NestedEnumQueueStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueStatus | EnumQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueueStatusFilter<$PrismaModel> | $Enums.QueueStatus
  }

  export type NestedEnumQueueTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueType | EnumQueueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QueueType[] | ListEnumQueueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueueType[] | ListEnumQueueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQueueTypeWithAggregatesFilter<$PrismaModel> | $Enums.QueueType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQueueTypeFilter<$PrismaModel>
    _max?: NestedEnumQueueTypeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumQueueStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueStatus | EnumQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueueStatusWithAggregatesFilter<$PrismaModel> | $Enums.QueueStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQueueStatusFilter<$PrismaModel>
    _max?: NestedEnumQueueStatusFilter<$PrismaModel>
  }

  export type NestedEnumAlertTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeFilter<$PrismaModel> | $Enums.AlertType
  }

  export type NestedEnumAlertSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertSeverity | EnumAlertSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.AlertSeverity[] | ListEnumAlertSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertSeverity[] | ListEnumAlertSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertSeverityFilter<$PrismaModel> | $Enums.AlertSeverity
  }

  export type NestedEnumAlertStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertStatus | EnumAlertStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertStatusFilter<$PrismaModel> | $Enums.AlertStatus
  }

  export type NestedEnumAlertTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeWithAggregatesFilter<$PrismaModel> | $Enums.AlertType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertTypeFilter<$PrismaModel>
    _max?: NestedEnumAlertTypeFilter<$PrismaModel>
  }

  export type NestedEnumAlertSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertSeverity | EnumAlertSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.AlertSeverity[] | ListEnumAlertSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertSeverity[] | ListEnumAlertSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertSeverityWithAggregatesFilter<$PrismaModel> | $Enums.AlertSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertSeverityFilter<$PrismaModel>
    _max?: NestedEnumAlertSeverityFilter<$PrismaModel>
  }

  export type NestedEnumAlertStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertStatus | EnumAlertStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertStatusWithAggregatesFilter<$PrismaModel> | $Enums.AlertStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertStatusFilter<$PrismaModel>
    _max?: NestedEnumAlertStatusFilter<$PrismaModel>
  }

  export type NestedEnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type NestedEnumAuditEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditEntityType | EnumAuditEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditEntityType[] | ListEnumAuditEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditEntityType[] | ListEnumAuditEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditEntityTypeFilter<$PrismaModel> | $Enums.AuditEntityType
  }

  export type NestedEnumSecurityLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.SecurityLevel | EnumSecurityLevelFieldRefInput<$PrismaModel>
    in?: $Enums.SecurityLevel[] | ListEnumSecurityLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecurityLevel[] | ListEnumSecurityLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumSecurityLevelFilter<$PrismaModel> | $Enums.SecurityLevel
  }

  export type NestedEnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }

  export type NestedEnumAuditEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditEntityType | EnumAuditEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditEntityType[] | ListEnumAuditEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditEntityType[] | ListEnumAuditEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuditEntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumAuditEntityTypeFilter<$PrismaModel>
  }

  export type NestedEnumSecurityLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SecurityLevel | EnumSecurityLevelFieldRefInput<$PrismaModel>
    in?: $Enums.SecurityLevel[] | ListEnumSecurityLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.SecurityLevel[] | ListEnumSecurityLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumSecurityLevelWithAggregatesFilter<$PrismaModel> | $Enums.SecurityLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSecurityLevelFilter<$PrismaModel>
    _max?: NestedEnumSecurityLevelFilter<$PrismaModel>
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    email: string
    username: string
    password: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    isTemporaryPassword?: boolean
    temporaryPasswordExpiresAt?: Date | string | null
    suspendedAt?: Date | string | null
    suspendedBy?: string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    email: string
    username: string
    password: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    isTemporaryPassword?: boolean
    temporaryPasswordExpiresAt?: Date | string | null
    suspendedAt?: Date | string | null
    suspendedBy?: string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TweetCreateWithoutTenantInput = {
    id?: string
    tweetId: string
    authorName: string
    authorHandle: string
    content: string
    publishedAt: Date | string
    hashtags?: TweetCreatehashtagsInput | string[]
    mentions?: TweetCreatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaSource: MediaSourceCreateNestedOneWithoutTweetsInput
    news?: NewsCreateNestedManyWithoutTweetInput
    aiAnalysis?: AiAnalysisCreateNestedManyWithoutTweetInput
    tweetMedia?: TweetMediaCreateNestedManyWithoutTweetInput
  }

  export type TweetUncheckedCreateWithoutTenantInput = {
    id?: string
    tweetId: string
    mediaSourceId: string
    authorName: string
    authorHandle: string
    content: string
    publishedAt: Date | string
    hashtags?: TweetCreatehashtagsInput | string[]
    mentions?: TweetCreatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    news?: NewsUncheckedCreateNestedManyWithoutTweetInput
    aiAnalysis?: AiAnalysisUncheckedCreateNestedManyWithoutTweetInput
    tweetMedia?: TweetMediaUncheckedCreateNestedManyWithoutTweetInput
  }

  export type TweetCreateOrConnectWithoutTenantInput = {
    where: TweetWhereUniqueInput
    create: XOR<TweetCreateWithoutTenantInput, TweetUncheckedCreateWithoutTenantInput>
  }

  export type TweetCreateManyTenantInputEnvelope = {
    data: TweetCreateManyTenantInput | TweetCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type NewsCreateWithoutTenantInput = {
    id?: string
    title?: string | null
    content?: string | null
    url?: string | null
    extractedAt: Date | string
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tweet: TweetCreateNestedOneWithoutNewsInput
    mediaSource: MediaSourceCreateNestedOneWithoutNewsInput
    aiAnalysis?: AiAnalysisCreateNestedManyWithoutNewsInput
  }

  export type NewsUncheckedCreateWithoutTenantInput = {
    id?: string
    tweetId: string
    mediaSourceId: string
    title?: string | null
    content?: string | null
    url?: string | null
    extractedAt: Date | string
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    aiAnalysis?: AiAnalysisUncheckedCreateNestedManyWithoutNewsInput
  }

  export type NewsCreateOrConnectWithoutTenantInput = {
    where: NewsWhereUniqueInput
    create: XOR<NewsCreateWithoutTenantInput, NewsUncheckedCreateWithoutTenantInput>
  }

  export type NewsCreateManyTenantInputEnvelope = {
    data: NewsCreateManyTenantInput | NewsCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AiAnalysisCreateWithoutTenantInput = {
    id?: string
    type: $Enums.AnalysisType
    prompt: string
    response: JsonNullValueInput | InputJsonValue
    sentiment?: string | null
    relevance?: number | null
    threatLevel?: $Enums.ThreatLevel | null
    tags?: AiAnalysisCreatetagsInput | string[]
    processedAt?: Date | string
    createdAt?: Date | string
    tweet?: TweetCreateNestedOneWithoutAiAnalysisInput
    news?: NewsCreateNestedOneWithoutAiAnalysisInput
  }

  export type AiAnalysisUncheckedCreateWithoutTenantInput = {
    id?: string
    tweetId?: string | null
    newsId?: string | null
    type: $Enums.AnalysisType
    prompt: string
    response: JsonNullValueInput | InputJsonValue
    sentiment?: string | null
    relevance?: number | null
    threatLevel?: $Enums.ThreatLevel | null
    tags?: AiAnalysisCreatetagsInput | string[]
    processedAt?: Date | string
    createdAt?: Date | string
  }

  export type AiAnalysisCreateOrConnectWithoutTenantInput = {
    where: AiAnalysisWhereUniqueInput
    create: XOR<AiAnalysisCreateWithoutTenantInput, AiAnalysisUncheckedCreateWithoutTenantInput>
  }

  export type AiAnalysisCreateManyTenantInputEnvelope = {
    data: AiAnalysisCreateManyTenantInput | AiAnalysisCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AlertCreateWithoutTenantInput = {
    id?: string
    type: $Enums.AlertType
    title: string
    message: string
    severity: $Enums.AlertSeverity
    status?: $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: Date | string
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateWithoutTenantInput = {
    id?: string
    userId?: string | null
    type: $Enums.AlertType
    title: string
    message: string
    severity: $Enums.AlertSeverity
    status?: $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: Date | string
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertCreateOrConnectWithoutTenantInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutTenantInput, AlertUncheckedCreateWithoutTenantInput>
  }

  export type AlertCreateManyTenantInputEnvelope = {
    data: AlertCreateManyTenantInput | AlertCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AiProcessingQueueCreateWithoutTenantInput = {
    id?: string
    tweetId?: string | null
    newsId?: string | null
    queueType: $Enums.QueueType
    priority?: number
    status?: $Enums.QueueStatus
    attempts?: number
    maxAttempts?: number
    scheduledAt?: Date | string
    processedAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiProcessingQueueUncheckedCreateWithoutTenantInput = {
    id?: string
    tweetId?: string | null
    newsId?: string | null
    queueType: $Enums.QueueType
    priority?: number
    status?: $Enums.QueueStatus
    attempts?: number
    maxAttempts?: number
    scheduledAt?: Date | string
    processedAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiProcessingQueueCreateOrConnectWithoutTenantInput = {
    where: AiProcessingQueueWhereUniqueInput
    create: XOR<AiProcessingQueueCreateWithoutTenantInput, AiProcessingQueueUncheckedCreateWithoutTenantInput>
  }

  export type AiProcessingQueueCreateManyTenantInputEnvelope = {
    data: AiProcessingQueueCreateManyTenantInput | AiProcessingQueueCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutTenantInput = {
    id?: string
    action: $Enums.AuditAction
    entityType: $Enums.AuditEntityType
    entityId?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    sessionId?: string | null
    clientFingerprint?: string | null
    checksum: string
    digitalSignature?: string | null
    performedAt?: Date | string
    createdAt?: Date | string
    securityLevel?: $Enums.SecurityLevel
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutTenantInput = {
    id?: string
    userId?: string | null
    action: $Enums.AuditAction
    entityType: $Enums.AuditEntityType
    entityId?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    sessionId?: string | null
    clientFingerprint?: string | null
    checksum: string
    digitalSignature?: string | null
    performedAt?: Date | string
    createdAt?: Date | string
    securityLevel?: $Enums.SecurityLevel
  }

  export type AuditLogCreateOrConnectWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput>
  }

  export type AuditLogCreateManyTenantInputEnvelope = {
    data: AuditLogCreateManyTenantInput | AuditLogCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    settings?: JsonNullableFilter<"User">
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isTemporaryPassword?: BoolFilter<"User"> | boolean
    temporaryPasswordExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    suspendedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    suspendedBy?: StringNullableFilter<"User"> | string | null
    suspensionReason?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type TweetUpsertWithWhereUniqueWithoutTenantInput = {
    where: TweetWhereUniqueInput
    update: XOR<TweetUpdateWithoutTenantInput, TweetUncheckedUpdateWithoutTenantInput>
    create: XOR<TweetCreateWithoutTenantInput, TweetUncheckedCreateWithoutTenantInput>
  }

  export type TweetUpdateWithWhereUniqueWithoutTenantInput = {
    where: TweetWhereUniqueInput
    data: XOR<TweetUpdateWithoutTenantInput, TweetUncheckedUpdateWithoutTenantInput>
  }

  export type TweetUpdateManyWithWhereWithoutTenantInput = {
    where: TweetScalarWhereInput
    data: XOR<TweetUpdateManyMutationInput, TweetUncheckedUpdateManyWithoutTenantInput>
  }

  export type TweetScalarWhereInput = {
    AND?: TweetScalarWhereInput | TweetScalarWhereInput[]
    OR?: TweetScalarWhereInput[]
    NOT?: TweetScalarWhereInput | TweetScalarWhereInput[]
    id?: StringFilter<"Tweet"> | string
    tenantId?: StringFilter<"Tweet"> | string
    tweetId?: StringFilter<"Tweet"> | string
    mediaSourceId?: StringFilter<"Tweet"> | string
    authorName?: StringFilter<"Tweet"> | string
    authorHandle?: StringFilter<"Tweet"> | string
    content?: StringFilter<"Tweet"> | string
    publishedAt?: DateTimeFilter<"Tweet"> | Date | string
    hashtags?: StringNullableListFilter<"Tweet">
    mentions?: StringNullableListFilter<"Tweet">
    mediaUrls?: JsonNullableFilter<"Tweet">
    engagement?: JsonNullableFilter<"Tweet">
    contentHash?: StringFilter<"Tweet"> | string
    createdAt?: DateTimeFilter<"Tweet"> | Date | string
    updatedAt?: DateTimeFilter<"Tweet"> | Date | string
  }

  export type NewsUpsertWithWhereUniqueWithoutTenantInput = {
    where: NewsWhereUniqueInput
    update: XOR<NewsUpdateWithoutTenantInput, NewsUncheckedUpdateWithoutTenantInput>
    create: XOR<NewsCreateWithoutTenantInput, NewsUncheckedCreateWithoutTenantInput>
  }

  export type NewsUpdateWithWhereUniqueWithoutTenantInput = {
    where: NewsWhereUniqueInput
    data: XOR<NewsUpdateWithoutTenantInput, NewsUncheckedUpdateWithoutTenantInput>
  }

  export type NewsUpdateManyWithWhereWithoutTenantInput = {
    where: NewsScalarWhereInput
    data: XOR<NewsUpdateManyMutationInput, NewsUncheckedUpdateManyWithoutTenantInput>
  }

  export type NewsScalarWhereInput = {
    AND?: NewsScalarWhereInput | NewsScalarWhereInput[]
    OR?: NewsScalarWhereInput[]
    NOT?: NewsScalarWhereInput | NewsScalarWhereInput[]
    id?: StringFilter<"News"> | string
    tenantId?: StringFilter<"News"> | string
    tweetId?: StringFilter<"News"> | string
    mediaSourceId?: StringFilter<"News"> | string
    title?: StringNullableFilter<"News"> | string | null
    content?: StringNullableFilter<"News"> | string | null
    url?: StringNullableFilter<"News"> | string | null
    extractedAt?: DateTimeFilter<"News"> | Date | string
    contentHash?: StringFilter<"News"> | string
    createdAt?: DateTimeFilter<"News"> | Date | string
    updatedAt?: DateTimeFilter<"News"> | Date | string
  }

  export type AiAnalysisUpsertWithWhereUniqueWithoutTenantInput = {
    where: AiAnalysisWhereUniqueInput
    update: XOR<AiAnalysisUpdateWithoutTenantInput, AiAnalysisUncheckedUpdateWithoutTenantInput>
    create: XOR<AiAnalysisCreateWithoutTenantInput, AiAnalysisUncheckedCreateWithoutTenantInput>
  }

  export type AiAnalysisUpdateWithWhereUniqueWithoutTenantInput = {
    where: AiAnalysisWhereUniqueInput
    data: XOR<AiAnalysisUpdateWithoutTenantInput, AiAnalysisUncheckedUpdateWithoutTenantInput>
  }

  export type AiAnalysisUpdateManyWithWhereWithoutTenantInput = {
    where: AiAnalysisScalarWhereInput
    data: XOR<AiAnalysisUpdateManyMutationInput, AiAnalysisUncheckedUpdateManyWithoutTenantInput>
  }

  export type AiAnalysisScalarWhereInput = {
    AND?: AiAnalysisScalarWhereInput | AiAnalysisScalarWhereInput[]
    OR?: AiAnalysisScalarWhereInput[]
    NOT?: AiAnalysisScalarWhereInput | AiAnalysisScalarWhereInput[]
    id?: StringFilter<"AiAnalysis"> | string
    tenantId?: StringFilter<"AiAnalysis"> | string
    tweetId?: StringNullableFilter<"AiAnalysis"> | string | null
    newsId?: StringNullableFilter<"AiAnalysis"> | string | null
    type?: EnumAnalysisTypeFilter<"AiAnalysis"> | $Enums.AnalysisType
    prompt?: StringFilter<"AiAnalysis"> | string
    response?: JsonFilter<"AiAnalysis">
    sentiment?: StringNullableFilter<"AiAnalysis"> | string | null
    relevance?: FloatNullableFilter<"AiAnalysis"> | number | null
    threatLevel?: EnumThreatLevelNullableFilter<"AiAnalysis"> | $Enums.ThreatLevel | null
    tags?: StringNullableListFilter<"AiAnalysis">
    processedAt?: DateTimeFilter<"AiAnalysis"> | Date | string
    createdAt?: DateTimeFilter<"AiAnalysis"> | Date | string
  }

  export type AlertUpsertWithWhereUniqueWithoutTenantInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutTenantInput, AlertUncheckedUpdateWithoutTenantInput>
    create: XOR<AlertCreateWithoutTenantInput, AlertUncheckedCreateWithoutTenantInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutTenantInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutTenantInput, AlertUncheckedUpdateWithoutTenantInput>
  }

  export type AlertUpdateManyWithWhereWithoutTenantInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutTenantInput>
  }

  export type AlertScalarWhereInput = {
    AND?: AlertScalarWhereInput | AlertScalarWhereInput[]
    OR?: AlertScalarWhereInput[]
    NOT?: AlertScalarWhereInput | AlertScalarWhereInput[]
    id?: StringFilter<"Alert"> | string
    tenantId?: StringFilter<"Alert"> | string
    userId?: StringNullableFilter<"Alert"> | string | null
    type?: EnumAlertTypeFilter<"Alert"> | $Enums.AlertType
    title?: StringFilter<"Alert"> | string
    message?: StringFilter<"Alert"> | string
    severity?: EnumAlertSeverityFilter<"Alert"> | $Enums.AlertSeverity
    status?: EnumAlertStatusFilter<"Alert"> | $Enums.AlertStatus
    metadata?: JsonNullableFilter<"Alert">
    triggeredAt?: DateTimeFilter<"Alert"> | Date | string
    readAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
  }

  export type AiProcessingQueueUpsertWithWhereUniqueWithoutTenantInput = {
    where: AiProcessingQueueWhereUniqueInput
    update: XOR<AiProcessingQueueUpdateWithoutTenantInput, AiProcessingQueueUncheckedUpdateWithoutTenantInput>
    create: XOR<AiProcessingQueueCreateWithoutTenantInput, AiProcessingQueueUncheckedCreateWithoutTenantInput>
  }

  export type AiProcessingQueueUpdateWithWhereUniqueWithoutTenantInput = {
    where: AiProcessingQueueWhereUniqueInput
    data: XOR<AiProcessingQueueUpdateWithoutTenantInput, AiProcessingQueueUncheckedUpdateWithoutTenantInput>
  }

  export type AiProcessingQueueUpdateManyWithWhereWithoutTenantInput = {
    where: AiProcessingQueueScalarWhereInput
    data: XOR<AiProcessingQueueUpdateManyMutationInput, AiProcessingQueueUncheckedUpdateManyWithoutTenantInput>
  }

  export type AiProcessingQueueScalarWhereInput = {
    AND?: AiProcessingQueueScalarWhereInput | AiProcessingQueueScalarWhereInput[]
    OR?: AiProcessingQueueScalarWhereInput[]
    NOT?: AiProcessingQueueScalarWhereInput | AiProcessingQueueScalarWhereInput[]
    id?: StringFilter<"AiProcessingQueue"> | string
    tenantId?: StringFilter<"AiProcessingQueue"> | string
    tweetId?: StringNullableFilter<"AiProcessingQueue"> | string | null
    newsId?: StringNullableFilter<"AiProcessingQueue"> | string | null
    queueType?: EnumQueueTypeFilter<"AiProcessingQueue"> | $Enums.QueueType
    priority?: IntFilter<"AiProcessingQueue"> | number
    status?: EnumQueueStatusFilter<"AiProcessingQueue"> | $Enums.QueueStatus
    attempts?: IntFilter<"AiProcessingQueue"> | number
    maxAttempts?: IntFilter<"AiProcessingQueue"> | number
    scheduledAt?: DateTimeFilter<"AiProcessingQueue"> | Date | string
    processedAt?: DateTimeNullableFilter<"AiProcessingQueue"> | Date | string | null
    error?: StringNullableFilter<"AiProcessingQueue"> | string | null
    createdAt?: DateTimeFilter<"AiProcessingQueue"> | Date | string
    updatedAt?: DateTimeFilter<"AiProcessingQueue"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutTenantInput, AuditLogUncheckedUpdateWithoutTenantInput>
    create: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutTenantInput, AuditLogUncheckedUpdateWithoutTenantInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutTenantInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutTenantInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    tenantId?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    entityType?: EnumAuditEntityTypeFilter<"AuditLog"> | $Enums.AuditEntityType
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    metadata?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    sessionId?: StringNullableFilter<"AuditLog"> | string | null
    clientFingerprint?: StringNullableFilter<"AuditLog"> | string | null
    checksum?: StringFilter<"AuditLog"> | string
    digitalSignature?: StringNullableFilter<"AuditLog"> | string | null
    performedAt?: DateTimeFilter<"AuditLog"> | Date | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    securityLevel?: EnumSecurityLevelFilter<"AuditLog"> | $Enums.SecurityLevel
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tweets?: TweetCreateNestedManyWithoutTenantInput
    news?: NewsCreateNestedManyWithoutTenantInput
    aiAnalysis?: AiAnalysisCreateNestedManyWithoutTenantInput
    alerts?: AlertCreateNestedManyWithoutTenantInput
    aiProcessingQueue?: AiProcessingQueueCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tweets?: TweetUncheckedCreateNestedManyWithoutTenantInput
    news?: NewsUncheckedCreateNestedManyWithoutTenantInput
    aiAnalysis?: AiAnalysisUncheckedCreateNestedManyWithoutTenantInput
    alerts?: AlertUncheckedCreateNestedManyWithoutTenantInput
    aiProcessingQueue?: AiProcessingQueueUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type AlertCreateWithoutUserInput = {
    id?: string
    type: $Enums.AlertType
    title: string
    message: string
    severity: $Enums.AlertSeverity
    status?: $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: Date | string
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    type: $Enums.AlertType
    title: string
    message: string
    severity: $Enums.AlertSeverity
    status?: $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: Date | string
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertCreateOrConnectWithoutUserInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput>
  }

  export type AlertCreateManyUserInputEnvelope = {
    data: AlertCreateManyUserInput | AlertCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: $Enums.AuditAction
    entityType: $Enums.AuditEntityType
    entityId?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    sessionId?: string | null
    clientFingerprint?: string | null
    checksum: string
    digitalSignature?: string | null
    performedAt?: Date | string
    createdAt?: Date | string
    securityLevel?: $Enums.SecurityLevel
    tenant: TenantCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    action: $Enums.AuditAction
    entityType: $Enums.AuditEntityType
    entityId?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    sessionId?: string | null
    clientFingerprint?: string | null
    checksum: string
    digitalSignature?: string | null
    performedAt?: Date | string
    createdAt?: Date | string
    securityLevel?: $Enums.SecurityLevel
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tweets?: TweetUpdateManyWithoutTenantNestedInput
    news?: NewsUpdateManyWithoutTenantNestedInput
    aiAnalysis?: AiAnalysisUpdateManyWithoutTenantNestedInput
    alerts?: AlertUpdateManyWithoutTenantNestedInput
    aiProcessingQueue?: AiProcessingQueueUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tweets?: TweetUncheckedUpdateManyWithoutTenantNestedInput
    news?: NewsUncheckedUpdateManyWithoutTenantNestedInput
    aiAnalysis?: AiAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutTenantNestedInput
    aiProcessingQueue?: AiProcessingQueueUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type AlertUpsertWithWhereUniqueWithoutUserInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutUserInput, AlertUncheckedUpdateWithoutUserInput>
    create: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutUserInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutUserInput, AlertUncheckedUpdateWithoutUserInput>
  }

  export type AlertUpdateManyWithWhereWithoutUserInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type TweetCreateWithoutMediaSourceInput = {
    id?: string
    tweetId: string
    authorName: string
    authorHandle: string
    content: string
    publishedAt: Date | string
    hashtags?: TweetCreatehashtagsInput | string[]
    mentions?: TweetCreatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTweetsInput
    news?: NewsCreateNestedManyWithoutTweetInput
    aiAnalysis?: AiAnalysisCreateNestedManyWithoutTweetInput
    tweetMedia?: TweetMediaCreateNestedManyWithoutTweetInput
  }

  export type TweetUncheckedCreateWithoutMediaSourceInput = {
    id?: string
    tenantId: string
    tweetId: string
    authorName: string
    authorHandle: string
    content: string
    publishedAt: Date | string
    hashtags?: TweetCreatehashtagsInput | string[]
    mentions?: TweetCreatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    news?: NewsUncheckedCreateNestedManyWithoutTweetInput
    aiAnalysis?: AiAnalysisUncheckedCreateNestedManyWithoutTweetInput
    tweetMedia?: TweetMediaUncheckedCreateNestedManyWithoutTweetInput
  }

  export type TweetCreateOrConnectWithoutMediaSourceInput = {
    where: TweetWhereUniqueInput
    create: XOR<TweetCreateWithoutMediaSourceInput, TweetUncheckedCreateWithoutMediaSourceInput>
  }

  export type TweetCreateManyMediaSourceInputEnvelope = {
    data: TweetCreateManyMediaSourceInput | TweetCreateManyMediaSourceInput[]
    skipDuplicates?: boolean
  }

  export type NewsCreateWithoutMediaSourceInput = {
    id?: string
    title?: string | null
    content?: string | null
    url?: string | null
    extractedAt: Date | string
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutNewsInput
    tweet: TweetCreateNestedOneWithoutNewsInput
    aiAnalysis?: AiAnalysisCreateNestedManyWithoutNewsInput
  }

  export type NewsUncheckedCreateWithoutMediaSourceInput = {
    id?: string
    tenantId: string
    tweetId: string
    title?: string | null
    content?: string | null
    url?: string | null
    extractedAt: Date | string
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    aiAnalysis?: AiAnalysisUncheckedCreateNestedManyWithoutNewsInput
  }

  export type NewsCreateOrConnectWithoutMediaSourceInput = {
    where: NewsWhereUniqueInput
    create: XOR<NewsCreateWithoutMediaSourceInput, NewsUncheckedCreateWithoutMediaSourceInput>
  }

  export type NewsCreateManyMediaSourceInputEnvelope = {
    data: NewsCreateManyMediaSourceInput | NewsCreateManyMediaSourceInput[]
    skipDuplicates?: boolean
  }

  export type TweetUpsertWithWhereUniqueWithoutMediaSourceInput = {
    where: TweetWhereUniqueInput
    update: XOR<TweetUpdateWithoutMediaSourceInput, TweetUncheckedUpdateWithoutMediaSourceInput>
    create: XOR<TweetCreateWithoutMediaSourceInput, TweetUncheckedCreateWithoutMediaSourceInput>
  }

  export type TweetUpdateWithWhereUniqueWithoutMediaSourceInput = {
    where: TweetWhereUniqueInput
    data: XOR<TweetUpdateWithoutMediaSourceInput, TweetUncheckedUpdateWithoutMediaSourceInput>
  }

  export type TweetUpdateManyWithWhereWithoutMediaSourceInput = {
    where: TweetScalarWhereInput
    data: XOR<TweetUpdateManyMutationInput, TweetUncheckedUpdateManyWithoutMediaSourceInput>
  }

  export type NewsUpsertWithWhereUniqueWithoutMediaSourceInput = {
    where: NewsWhereUniqueInput
    update: XOR<NewsUpdateWithoutMediaSourceInput, NewsUncheckedUpdateWithoutMediaSourceInput>
    create: XOR<NewsCreateWithoutMediaSourceInput, NewsUncheckedCreateWithoutMediaSourceInput>
  }

  export type NewsUpdateWithWhereUniqueWithoutMediaSourceInput = {
    where: NewsWhereUniqueInput
    data: XOR<NewsUpdateWithoutMediaSourceInput, NewsUncheckedUpdateWithoutMediaSourceInput>
  }

  export type NewsUpdateManyWithWhereWithoutMediaSourceInput = {
    where: NewsScalarWhereInput
    data: XOR<NewsUpdateManyMutationInput, NewsUncheckedUpdateManyWithoutMediaSourceInput>
  }

  export type TenantCreateWithoutTweetsInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    news?: NewsCreateNestedManyWithoutTenantInput
    aiAnalysis?: AiAnalysisCreateNestedManyWithoutTenantInput
    alerts?: AlertCreateNestedManyWithoutTenantInput
    aiProcessingQueue?: AiProcessingQueueCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutTweetsInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    news?: NewsUncheckedCreateNestedManyWithoutTenantInput
    aiAnalysis?: AiAnalysisUncheckedCreateNestedManyWithoutTenantInput
    alerts?: AlertUncheckedCreateNestedManyWithoutTenantInput
    aiProcessingQueue?: AiProcessingQueueUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutTweetsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutTweetsInput, TenantUncheckedCreateWithoutTweetsInput>
  }

  export type MediaSourceCreateWithoutTweetsInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    baseUrl?: string | null
    twitterHandle?: string | null
    selectors?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    news?: NewsCreateNestedManyWithoutMediaSourceInput
  }

  export type MediaSourceUncheckedCreateWithoutTweetsInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    baseUrl?: string | null
    twitterHandle?: string | null
    selectors?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    news?: NewsUncheckedCreateNestedManyWithoutMediaSourceInput
  }

  export type MediaSourceCreateOrConnectWithoutTweetsInput = {
    where: MediaSourceWhereUniqueInput
    create: XOR<MediaSourceCreateWithoutTweetsInput, MediaSourceUncheckedCreateWithoutTweetsInput>
  }

  export type NewsCreateWithoutTweetInput = {
    id?: string
    title?: string | null
    content?: string | null
    url?: string | null
    extractedAt: Date | string
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutNewsInput
    mediaSource: MediaSourceCreateNestedOneWithoutNewsInput
    aiAnalysis?: AiAnalysisCreateNestedManyWithoutNewsInput
  }

  export type NewsUncheckedCreateWithoutTweetInput = {
    id?: string
    tenantId: string
    mediaSourceId: string
    title?: string | null
    content?: string | null
    url?: string | null
    extractedAt: Date | string
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    aiAnalysis?: AiAnalysisUncheckedCreateNestedManyWithoutNewsInput
  }

  export type NewsCreateOrConnectWithoutTweetInput = {
    where: NewsWhereUniqueInput
    create: XOR<NewsCreateWithoutTweetInput, NewsUncheckedCreateWithoutTweetInput>
  }

  export type NewsCreateManyTweetInputEnvelope = {
    data: NewsCreateManyTweetInput | NewsCreateManyTweetInput[]
    skipDuplicates?: boolean
  }

  export type AiAnalysisCreateWithoutTweetInput = {
    id?: string
    type: $Enums.AnalysisType
    prompt: string
    response: JsonNullValueInput | InputJsonValue
    sentiment?: string | null
    relevance?: number | null
    threatLevel?: $Enums.ThreatLevel | null
    tags?: AiAnalysisCreatetagsInput | string[]
    processedAt?: Date | string
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAiAnalysisInput
    news?: NewsCreateNestedOneWithoutAiAnalysisInput
  }

  export type AiAnalysisUncheckedCreateWithoutTweetInput = {
    id?: string
    tenantId: string
    newsId?: string | null
    type: $Enums.AnalysisType
    prompt: string
    response: JsonNullValueInput | InputJsonValue
    sentiment?: string | null
    relevance?: number | null
    threatLevel?: $Enums.ThreatLevel | null
    tags?: AiAnalysisCreatetagsInput | string[]
    processedAt?: Date | string
    createdAt?: Date | string
  }

  export type AiAnalysisCreateOrConnectWithoutTweetInput = {
    where: AiAnalysisWhereUniqueInput
    create: XOR<AiAnalysisCreateWithoutTweetInput, AiAnalysisUncheckedCreateWithoutTweetInput>
  }

  export type AiAnalysisCreateManyTweetInputEnvelope = {
    data: AiAnalysisCreateManyTweetInput | AiAnalysisCreateManyTweetInput[]
    skipDuplicates?: boolean
  }

  export type TweetMediaCreateWithoutTweetInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TweetMediaUncheckedCreateWithoutTweetInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TweetMediaCreateOrConnectWithoutTweetInput = {
    where: TweetMediaWhereUniqueInput
    create: XOR<TweetMediaCreateWithoutTweetInput, TweetMediaUncheckedCreateWithoutTweetInput>
  }

  export type TweetMediaCreateManyTweetInputEnvelope = {
    data: TweetMediaCreateManyTweetInput | TweetMediaCreateManyTweetInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutTweetsInput = {
    update: XOR<TenantUpdateWithoutTweetsInput, TenantUncheckedUpdateWithoutTweetsInput>
    create: XOR<TenantCreateWithoutTweetsInput, TenantUncheckedCreateWithoutTweetsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutTweetsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutTweetsInput, TenantUncheckedUpdateWithoutTweetsInput>
  }

  export type TenantUpdateWithoutTweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    news?: NewsUpdateManyWithoutTenantNestedInput
    aiAnalysis?: AiAnalysisUpdateManyWithoutTenantNestedInput
    alerts?: AlertUpdateManyWithoutTenantNestedInput
    aiProcessingQueue?: AiProcessingQueueUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutTweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    news?: NewsUncheckedUpdateManyWithoutTenantNestedInput
    aiAnalysis?: AiAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutTenantNestedInput
    aiProcessingQueue?: AiProcessingQueueUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type MediaSourceUpsertWithoutTweetsInput = {
    update: XOR<MediaSourceUpdateWithoutTweetsInput, MediaSourceUncheckedUpdateWithoutTweetsInput>
    create: XOR<MediaSourceCreateWithoutTweetsInput, MediaSourceUncheckedCreateWithoutTweetsInput>
    where?: MediaSourceWhereInput
  }

  export type MediaSourceUpdateToOneWithWhereWithoutTweetsInput = {
    where?: MediaSourceWhereInput
    data: XOR<MediaSourceUpdateWithoutTweetsInput, MediaSourceUncheckedUpdateWithoutTweetsInput>
  }

  export type MediaSourceUpdateWithoutTweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterHandle?: NullableStringFieldUpdateOperationsInput | string | null
    selectors?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    news?: NewsUpdateManyWithoutMediaSourceNestedInput
  }

  export type MediaSourceUncheckedUpdateWithoutTweetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterHandle?: NullableStringFieldUpdateOperationsInput | string | null
    selectors?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    news?: NewsUncheckedUpdateManyWithoutMediaSourceNestedInput
  }

  export type NewsUpsertWithWhereUniqueWithoutTweetInput = {
    where: NewsWhereUniqueInput
    update: XOR<NewsUpdateWithoutTweetInput, NewsUncheckedUpdateWithoutTweetInput>
    create: XOR<NewsCreateWithoutTweetInput, NewsUncheckedCreateWithoutTweetInput>
  }

  export type NewsUpdateWithWhereUniqueWithoutTweetInput = {
    where: NewsWhereUniqueInput
    data: XOR<NewsUpdateWithoutTweetInput, NewsUncheckedUpdateWithoutTweetInput>
  }

  export type NewsUpdateManyWithWhereWithoutTweetInput = {
    where: NewsScalarWhereInput
    data: XOR<NewsUpdateManyMutationInput, NewsUncheckedUpdateManyWithoutTweetInput>
  }

  export type AiAnalysisUpsertWithWhereUniqueWithoutTweetInput = {
    where: AiAnalysisWhereUniqueInput
    update: XOR<AiAnalysisUpdateWithoutTweetInput, AiAnalysisUncheckedUpdateWithoutTweetInput>
    create: XOR<AiAnalysisCreateWithoutTweetInput, AiAnalysisUncheckedCreateWithoutTweetInput>
  }

  export type AiAnalysisUpdateWithWhereUniqueWithoutTweetInput = {
    where: AiAnalysisWhereUniqueInput
    data: XOR<AiAnalysisUpdateWithoutTweetInput, AiAnalysisUncheckedUpdateWithoutTweetInput>
  }

  export type AiAnalysisUpdateManyWithWhereWithoutTweetInput = {
    where: AiAnalysisScalarWhereInput
    data: XOR<AiAnalysisUpdateManyMutationInput, AiAnalysisUncheckedUpdateManyWithoutTweetInput>
  }

  export type TweetMediaUpsertWithWhereUniqueWithoutTweetInput = {
    where: TweetMediaWhereUniqueInput
    update: XOR<TweetMediaUpdateWithoutTweetInput, TweetMediaUncheckedUpdateWithoutTweetInput>
    create: XOR<TweetMediaCreateWithoutTweetInput, TweetMediaUncheckedCreateWithoutTweetInput>
  }

  export type TweetMediaUpdateWithWhereUniqueWithoutTweetInput = {
    where: TweetMediaWhereUniqueInput
    data: XOR<TweetMediaUpdateWithoutTweetInput, TweetMediaUncheckedUpdateWithoutTweetInput>
  }

  export type TweetMediaUpdateManyWithWhereWithoutTweetInput = {
    where: TweetMediaScalarWhereInput
    data: XOR<TweetMediaUpdateManyMutationInput, TweetMediaUncheckedUpdateManyWithoutTweetInput>
  }

  export type TweetMediaScalarWhereInput = {
    AND?: TweetMediaScalarWhereInput | TweetMediaScalarWhereInput[]
    OR?: TweetMediaScalarWhereInput[]
    NOT?: TweetMediaScalarWhereInput | TweetMediaScalarWhereInput[]
    id?: StringFilter<"TweetMedia"> | string
    tweetId?: StringFilter<"TweetMedia"> | string
    type?: EnumMediaTypeFilter<"TweetMedia"> | $Enums.MediaType
    url?: StringFilter<"TweetMedia"> | string
    metadata?: JsonNullableFilter<"TweetMedia">
  }

  export type TweetCreateWithoutTweetMediaInput = {
    id?: string
    tweetId: string
    authorName: string
    authorHandle: string
    content: string
    publishedAt: Date | string
    hashtags?: TweetCreatehashtagsInput | string[]
    mentions?: TweetCreatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTweetsInput
    mediaSource: MediaSourceCreateNestedOneWithoutTweetsInput
    news?: NewsCreateNestedManyWithoutTweetInput
    aiAnalysis?: AiAnalysisCreateNestedManyWithoutTweetInput
  }

  export type TweetUncheckedCreateWithoutTweetMediaInput = {
    id?: string
    tenantId: string
    tweetId: string
    mediaSourceId: string
    authorName: string
    authorHandle: string
    content: string
    publishedAt: Date | string
    hashtags?: TweetCreatehashtagsInput | string[]
    mentions?: TweetCreatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    news?: NewsUncheckedCreateNestedManyWithoutTweetInput
    aiAnalysis?: AiAnalysisUncheckedCreateNestedManyWithoutTweetInput
  }

  export type TweetCreateOrConnectWithoutTweetMediaInput = {
    where: TweetWhereUniqueInput
    create: XOR<TweetCreateWithoutTweetMediaInput, TweetUncheckedCreateWithoutTweetMediaInput>
  }

  export type TweetUpsertWithoutTweetMediaInput = {
    update: XOR<TweetUpdateWithoutTweetMediaInput, TweetUncheckedUpdateWithoutTweetMediaInput>
    create: XOR<TweetCreateWithoutTweetMediaInput, TweetUncheckedCreateWithoutTweetMediaInput>
    where?: TweetWhereInput
  }

  export type TweetUpdateToOneWithWhereWithoutTweetMediaInput = {
    where?: TweetWhereInput
    data: XOR<TweetUpdateWithoutTweetMediaInput, TweetUncheckedUpdateWithoutTweetMediaInput>
  }

  export type TweetUpdateWithoutTweetMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorHandle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtags?: TweetUpdatehashtagsInput | string[]
    mentions?: TweetUpdatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTweetsNestedInput
    mediaSource?: MediaSourceUpdateOneRequiredWithoutTweetsNestedInput
    news?: NewsUpdateManyWithoutTweetNestedInput
    aiAnalysis?: AiAnalysisUpdateManyWithoutTweetNestedInput
  }

  export type TweetUncheckedUpdateWithoutTweetMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    mediaSourceId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorHandle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtags?: TweetUpdatehashtagsInput | string[]
    mentions?: TweetUpdatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    news?: NewsUncheckedUpdateManyWithoutTweetNestedInput
    aiAnalysis?: AiAnalysisUncheckedUpdateManyWithoutTweetNestedInput
  }

  export type TenantCreateWithoutNewsInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    tweets?: TweetCreateNestedManyWithoutTenantInput
    aiAnalysis?: AiAnalysisCreateNestedManyWithoutTenantInput
    alerts?: AlertCreateNestedManyWithoutTenantInput
    aiProcessingQueue?: AiProcessingQueueCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutNewsInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    tweets?: TweetUncheckedCreateNestedManyWithoutTenantInput
    aiAnalysis?: AiAnalysisUncheckedCreateNestedManyWithoutTenantInput
    alerts?: AlertUncheckedCreateNestedManyWithoutTenantInput
    aiProcessingQueue?: AiProcessingQueueUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutNewsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutNewsInput, TenantUncheckedCreateWithoutNewsInput>
  }

  export type TweetCreateWithoutNewsInput = {
    id?: string
    tweetId: string
    authorName: string
    authorHandle: string
    content: string
    publishedAt: Date | string
    hashtags?: TweetCreatehashtagsInput | string[]
    mentions?: TweetCreatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTweetsInput
    mediaSource: MediaSourceCreateNestedOneWithoutTweetsInput
    aiAnalysis?: AiAnalysisCreateNestedManyWithoutTweetInput
    tweetMedia?: TweetMediaCreateNestedManyWithoutTweetInput
  }

  export type TweetUncheckedCreateWithoutNewsInput = {
    id?: string
    tenantId: string
    tweetId: string
    mediaSourceId: string
    authorName: string
    authorHandle: string
    content: string
    publishedAt: Date | string
    hashtags?: TweetCreatehashtagsInput | string[]
    mentions?: TweetCreatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    aiAnalysis?: AiAnalysisUncheckedCreateNestedManyWithoutTweetInput
    tweetMedia?: TweetMediaUncheckedCreateNestedManyWithoutTweetInput
  }

  export type TweetCreateOrConnectWithoutNewsInput = {
    where: TweetWhereUniqueInput
    create: XOR<TweetCreateWithoutNewsInput, TweetUncheckedCreateWithoutNewsInput>
  }

  export type MediaSourceCreateWithoutNewsInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    baseUrl?: string | null
    twitterHandle?: string | null
    selectors?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tweets?: TweetCreateNestedManyWithoutMediaSourceInput
  }

  export type MediaSourceUncheckedCreateWithoutNewsInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    baseUrl?: string | null
    twitterHandle?: string | null
    selectors?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tweets?: TweetUncheckedCreateNestedManyWithoutMediaSourceInput
  }

  export type MediaSourceCreateOrConnectWithoutNewsInput = {
    where: MediaSourceWhereUniqueInput
    create: XOR<MediaSourceCreateWithoutNewsInput, MediaSourceUncheckedCreateWithoutNewsInput>
  }

  export type AiAnalysisCreateWithoutNewsInput = {
    id?: string
    type: $Enums.AnalysisType
    prompt: string
    response: JsonNullValueInput | InputJsonValue
    sentiment?: string | null
    relevance?: number | null
    threatLevel?: $Enums.ThreatLevel | null
    tags?: AiAnalysisCreatetagsInput | string[]
    processedAt?: Date | string
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAiAnalysisInput
    tweet?: TweetCreateNestedOneWithoutAiAnalysisInput
  }

  export type AiAnalysisUncheckedCreateWithoutNewsInput = {
    id?: string
    tenantId: string
    tweetId?: string | null
    type: $Enums.AnalysisType
    prompt: string
    response: JsonNullValueInput | InputJsonValue
    sentiment?: string | null
    relevance?: number | null
    threatLevel?: $Enums.ThreatLevel | null
    tags?: AiAnalysisCreatetagsInput | string[]
    processedAt?: Date | string
    createdAt?: Date | string
  }

  export type AiAnalysisCreateOrConnectWithoutNewsInput = {
    where: AiAnalysisWhereUniqueInput
    create: XOR<AiAnalysisCreateWithoutNewsInput, AiAnalysisUncheckedCreateWithoutNewsInput>
  }

  export type AiAnalysisCreateManyNewsInputEnvelope = {
    data: AiAnalysisCreateManyNewsInput | AiAnalysisCreateManyNewsInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutNewsInput = {
    update: XOR<TenantUpdateWithoutNewsInput, TenantUncheckedUpdateWithoutNewsInput>
    create: XOR<TenantCreateWithoutNewsInput, TenantUncheckedCreateWithoutNewsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutNewsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutNewsInput, TenantUncheckedUpdateWithoutNewsInput>
  }

  export type TenantUpdateWithoutNewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    tweets?: TweetUpdateManyWithoutTenantNestedInput
    aiAnalysis?: AiAnalysisUpdateManyWithoutTenantNestedInput
    alerts?: AlertUpdateManyWithoutTenantNestedInput
    aiProcessingQueue?: AiProcessingQueueUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutNewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    tweets?: TweetUncheckedUpdateManyWithoutTenantNestedInput
    aiAnalysis?: AiAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutTenantNestedInput
    aiProcessingQueue?: AiProcessingQueueUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TweetUpsertWithoutNewsInput = {
    update: XOR<TweetUpdateWithoutNewsInput, TweetUncheckedUpdateWithoutNewsInput>
    create: XOR<TweetCreateWithoutNewsInput, TweetUncheckedCreateWithoutNewsInput>
    where?: TweetWhereInput
  }

  export type TweetUpdateToOneWithWhereWithoutNewsInput = {
    where?: TweetWhereInput
    data: XOR<TweetUpdateWithoutNewsInput, TweetUncheckedUpdateWithoutNewsInput>
  }

  export type TweetUpdateWithoutNewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorHandle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtags?: TweetUpdatehashtagsInput | string[]
    mentions?: TweetUpdatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTweetsNestedInput
    mediaSource?: MediaSourceUpdateOneRequiredWithoutTweetsNestedInput
    aiAnalysis?: AiAnalysisUpdateManyWithoutTweetNestedInput
    tweetMedia?: TweetMediaUpdateManyWithoutTweetNestedInput
  }

  export type TweetUncheckedUpdateWithoutNewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    mediaSourceId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorHandle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtags?: TweetUpdatehashtagsInput | string[]
    mentions?: TweetUpdatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiAnalysis?: AiAnalysisUncheckedUpdateManyWithoutTweetNestedInput
    tweetMedia?: TweetMediaUncheckedUpdateManyWithoutTweetNestedInput
  }

  export type MediaSourceUpsertWithoutNewsInput = {
    update: XOR<MediaSourceUpdateWithoutNewsInput, MediaSourceUncheckedUpdateWithoutNewsInput>
    create: XOR<MediaSourceCreateWithoutNewsInput, MediaSourceUncheckedCreateWithoutNewsInput>
    where?: MediaSourceWhereInput
  }

  export type MediaSourceUpdateToOneWithWhereWithoutNewsInput = {
    where?: MediaSourceWhereInput
    data: XOR<MediaSourceUpdateWithoutNewsInput, MediaSourceUncheckedUpdateWithoutNewsInput>
  }

  export type MediaSourceUpdateWithoutNewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterHandle?: NullableStringFieldUpdateOperationsInput | string | null
    selectors?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tweets?: TweetUpdateManyWithoutMediaSourceNestedInput
  }

  export type MediaSourceUncheckedUpdateWithoutNewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterHandle?: NullableStringFieldUpdateOperationsInput | string | null
    selectors?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tweets?: TweetUncheckedUpdateManyWithoutMediaSourceNestedInput
  }

  export type AiAnalysisUpsertWithWhereUniqueWithoutNewsInput = {
    where: AiAnalysisWhereUniqueInput
    update: XOR<AiAnalysisUpdateWithoutNewsInput, AiAnalysisUncheckedUpdateWithoutNewsInput>
    create: XOR<AiAnalysisCreateWithoutNewsInput, AiAnalysisUncheckedCreateWithoutNewsInput>
  }

  export type AiAnalysisUpdateWithWhereUniqueWithoutNewsInput = {
    where: AiAnalysisWhereUniqueInput
    data: XOR<AiAnalysisUpdateWithoutNewsInput, AiAnalysisUncheckedUpdateWithoutNewsInput>
  }

  export type AiAnalysisUpdateManyWithWhereWithoutNewsInput = {
    where: AiAnalysisScalarWhereInput
    data: XOR<AiAnalysisUpdateManyMutationInput, AiAnalysisUncheckedUpdateManyWithoutNewsInput>
  }

  export type TenantCreateWithoutAiAnalysisInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    tweets?: TweetCreateNestedManyWithoutTenantInput
    news?: NewsCreateNestedManyWithoutTenantInput
    alerts?: AlertCreateNestedManyWithoutTenantInput
    aiProcessingQueue?: AiProcessingQueueCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAiAnalysisInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    tweets?: TweetUncheckedCreateNestedManyWithoutTenantInput
    news?: NewsUncheckedCreateNestedManyWithoutTenantInput
    alerts?: AlertUncheckedCreateNestedManyWithoutTenantInput
    aiProcessingQueue?: AiProcessingQueueUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAiAnalysisInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAiAnalysisInput, TenantUncheckedCreateWithoutAiAnalysisInput>
  }

  export type TweetCreateWithoutAiAnalysisInput = {
    id?: string
    tweetId: string
    authorName: string
    authorHandle: string
    content: string
    publishedAt: Date | string
    hashtags?: TweetCreatehashtagsInput | string[]
    mentions?: TweetCreatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTweetsInput
    mediaSource: MediaSourceCreateNestedOneWithoutTweetsInput
    news?: NewsCreateNestedManyWithoutTweetInput
    tweetMedia?: TweetMediaCreateNestedManyWithoutTweetInput
  }

  export type TweetUncheckedCreateWithoutAiAnalysisInput = {
    id?: string
    tenantId: string
    tweetId: string
    mediaSourceId: string
    authorName: string
    authorHandle: string
    content: string
    publishedAt: Date | string
    hashtags?: TweetCreatehashtagsInput | string[]
    mentions?: TweetCreatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    news?: NewsUncheckedCreateNestedManyWithoutTweetInput
    tweetMedia?: TweetMediaUncheckedCreateNestedManyWithoutTweetInput
  }

  export type TweetCreateOrConnectWithoutAiAnalysisInput = {
    where: TweetWhereUniqueInput
    create: XOR<TweetCreateWithoutAiAnalysisInput, TweetUncheckedCreateWithoutAiAnalysisInput>
  }

  export type NewsCreateWithoutAiAnalysisInput = {
    id?: string
    title?: string | null
    content?: string | null
    url?: string | null
    extractedAt: Date | string
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutNewsInput
    tweet: TweetCreateNestedOneWithoutNewsInput
    mediaSource: MediaSourceCreateNestedOneWithoutNewsInput
  }

  export type NewsUncheckedCreateWithoutAiAnalysisInput = {
    id?: string
    tenantId: string
    tweetId: string
    mediaSourceId: string
    title?: string | null
    content?: string | null
    url?: string | null
    extractedAt: Date | string
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsCreateOrConnectWithoutAiAnalysisInput = {
    where: NewsWhereUniqueInput
    create: XOR<NewsCreateWithoutAiAnalysisInput, NewsUncheckedCreateWithoutAiAnalysisInput>
  }

  export type TenantUpsertWithoutAiAnalysisInput = {
    update: XOR<TenantUpdateWithoutAiAnalysisInput, TenantUncheckedUpdateWithoutAiAnalysisInput>
    create: XOR<TenantCreateWithoutAiAnalysisInput, TenantUncheckedCreateWithoutAiAnalysisInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAiAnalysisInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAiAnalysisInput, TenantUncheckedUpdateWithoutAiAnalysisInput>
  }

  export type TenantUpdateWithoutAiAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    tweets?: TweetUpdateManyWithoutTenantNestedInput
    news?: NewsUpdateManyWithoutTenantNestedInput
    alerts?: AlertUpdateManyWithoutTenantNestedInput
    aiProcessingQueue?: AiProcessingQueueUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAiAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    tweets?: TweetUncheckedUpdateManyWithoutTenantNestedInput
    news?: NewsUncheckedUpdateManyWithoutTenantNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutTenantNestedInput
    aiProcessingQueue?: AiProcessingQueueUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TweetUpsertWithoutAiAnalysisInput = {
    update: XOR<TweetUpdateWithoutAiAnalysisInput, TweetUncheckedUpdateWithoutAiAnalysisInput>
    create: XOR<TweetCreateWithoutAiAnalysisInput, TweetUncheckedCreateWithoutAiAnalysisInput>
    where?: TweetWhereInput
  }

  export type TweetUpdateToOneWithWhereWithoutAiAnalysisInput = {
    where?: TweetWhereInput
    data: XOR<TweetUpdateWithoutAiAnalysisInput, TweetUncheckedUpdateWithoutAiAnalysisInput>
  }

  export type TweetUpdateWithoutAiAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorHandle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtags?: TweetUpdatehashtagsInput | string[]
    mentions?: TweetUpdatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTweetsNestedInput
    mediaSource?: MediaSourceUpdateOneRequiredWithoutTweetsNestedInput
    news?: NewsUpdateManyWithoutTweetNestedInput
    tweetMedia?: TweetMediaUpdateManyWithoutTweetNestedInput
  }

  export type TweetUncheckedUpdateWithoutAiAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    mediaSourceId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorHandle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtags?: TweetUpdatehashtagsInput | string[]
    mentions?: TweetUpdatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    news?: NewsUncheckedUpdateManyWithoutTweetNestedInput
    tweetMedia?: TweetMediaUncheckedUpdateManyWithoutTweetNestedInput
  }

  export type NewsUpsertWithoutAiAnalysisInput = {
    update: XOR<NewsUpdateWithoutAiAnalysisInput, NewsUncheckedUpdateWithoutAiAnalysisInput>
    create: XOR<NewsCreateWithoutAiAnalysisInput, NewsUncheckedCreateWithoutAiAnalysisInput>
    where?: NewsWhereInput
  }

  export type NewsUpdateToOneWithWhereWithoutAiAnalysisInput = {
    where?: NewsWhereInput
    data: XOR<NewsUpdateWithoutAiAnalysisInput, NewsUncheckedUpdateWithoutAiAnalysisInput>
  }

  export type NewsUpdateWithoutAiAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extractedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutNewsNestedInput
    tweet?: TweetUpdateOneRequiredWithoutNewsNestedInput
    mediaSource?: MediaSourceUpdateOneRequiredWithoutNewsNestedInput
  }

  export type NewsUncheckedUpdateWithoutAiAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    mediaSourceId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extractedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutAiProcessingQueueInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    tweets?: TweetCreateNestedManyWithoutTenantInput
    news?: NewsCreateNestedManyWithoutTenantInput
    aiAnalysis?: AiAnalysisCreateNestedManyWithoutTenantInput
    alerts?: AlertCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAiProcessingQueueInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    tweets?: TweetUncheckedCreateNestedManyWithoutTenantInput
    news?: NewsUncheckedCreateNestedManyWithoutTenantInput
    aiAnalysis?: AiAnalysisUncheckedCreateNestedManyWithoutTenantInput
    alerts?: AlertUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAiProcessingQueueInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAiProcessingQueueInput, TenantUncheckedCreateWithoutAiProcessingQueueInput>
  }

  export type TenantUpsertWithoutAiProcessingQueueInput = {
    update: XOR<TenantUpdateWithoutAiProcessingQueueInput, TenantUncheckedUpdateWithoutAiProcessingQueueInput>
    create: XOR<TenantCreateWithoutAiProcessingQueueInput, TenantUncheckedCreateWithoutAiProcessingQueueInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAiProcessingQueueInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAiProcessingQueueInput, TenantUncheckedUpdateWithoutAiProcessingQueueInput>
  }

  export type TenantUpdateWithoutAiProcessingQueueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    tweets?: TweetUpdateManyWithoutTenantNestedInput
    news?: NewsUpdateManyWithoutTenantNestedInput
    aiAnalysis?: AiAnalysisUpdateManyWithoutTenantNestedInput
    alerts?: AlertUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAiProcessingQueueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    tweets?: TweetUncheckedUpdateManyWithoutTenantNestedInput
    news?: NewsUncheckedUpdateManyWithoutTenantNestedInput
    aiAnalysis?: AiAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutAlertsInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    tweets?: TweetCreateNestedManyWithoutTenantInput
    news?: NewsCreateNestedManyWithoutTenantInput
    aiAnalysis?: AiAnalysisCreateNestedManyWithoutTenantInput
    aiProcessingQueue?: AiProcessingQueueCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAlertsInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    tweets?: TweetUncheckedCreateNestedManyWithoutTenantInput
    news?: NewsUncheckedCreateNestedManyWithoutTenantInput
    aiAnalysis?: AiAnalysisUncheckedCreateNestedManyWithoutTenantInput
    aiProcessingQueue?: AiProcessingQueueUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAlertsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAlertsInput, TenantUncheckedCreateWithoutAlertsInput>
  }

  export type UserCreateWithoutAlertsInput = {
    id?: string
    email: string
    username: string
    password: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    isTemporaryPassword?: boolean
    temporaryPasswordExpiresAt?: Date | string | null
    suspendedAt?: Date | string | null
    suspendedBy?: string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAlertsInput = {
    id?: string
    tenantId?: string | null
    email: string
    username: string
    password: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    isTemporaryPassword?: boolean
    temporaryPasswordExpiresAt?: Date | string | null
    suspendedAt?: Date | string | null
    suspendedBy?: string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAlertsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
  }

  export type TenantUpsertWithoutAlertsInput = {
    update: XOR<TenantUpdateWithoutAlertsInput, TenantUncheckedUpdateWithoutAlertsInput>
    create: XOR<TenantCreateWithoutAlertsInput, TenantUncheckedCreateWithoutAlertsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAlertsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAlertsInput, TenantUncheckedUpdateWithoutAlertsInput>
  }

  export type TenantUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    tweets?: TweetUpdateManyWithoutTenantNestedInput
    news?: NewsUpdateManyWithoutTenantNestedInput
    aiAnalysis?: AiAnalysisUpdateManyWithoutTenantNestedInput
    aiProcessingQueue?: AiProcessingQueueUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    tweets?: TweetUncheckedUpdateManyWithoutTenantNestedInput
    news?: NewsUncheckedUpdateManyWithoutTenantNestedInput
    aiAnalysis?: AiAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    aiProcessingQueue?: AiProcessingQueueUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutAlertsInput = {
    update: XOR<UserUpdateWithoutAlertsInput, UserUncheckedUpdateWithoutAlertsInput>
    create: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAlertsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAlertsInput, UserUncheckedUpdateWithoutAlertsInput>
  }

  export type UserUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTemporaryPassword?: BoolFieldUpdateOperationsInput | boolean
    temporaryPasswordExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendedBy?: NullableStringFieldUpdateOperationsInput | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTemporaryPassword?: BoolFieldUpdateOperationsInput | boolean
    temporaryPasswordExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendedBy?: NullableStringFieldUpdateOperationsInput | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    tweets?: TweetCreateNestedManyWithoutTenantInput
    news?: NewsCreateNestedManyWithoutTenantInput
    aiAnalysis?: AiAnalysisCreateNestedManyWithoutTenantInput
    alerts?: AlertCreateNestedManyWithoutTenantInput
    aiProcessingQueue?: AiProcessingQueueCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    type: $Enums.TenantType
    status?: $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    tweets?: TweetUncheckedCreateNestedManyWithoutTenantInput
    news?: NewsUncheckedCreateNestedManyWithoutTenantInput
    aiAnalysis?: AiAnalysisUncheckedCreateNestedManyWithoutTenantInput
    alerts?: AlertUncheckedCreateNestedManyWithoutTenantInput
    aiProcessingQueue?: AiProcessingQueueUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAuditLogsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    username: string
    password: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    isTemporaryPassword?: boolean
    temporaryPasswordExpiresAt?: Date | string | null
    suspendedAt?: Date | string | null
    suspendedBy?: string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    alerts?: AlertCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    tenantId?: string | null
    email: string
    username: string
    password: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    isTemporaryPassword?: boolean
    temporaryPasswordExpiresAt?: Date | string | null
    suspendedAt?: Date | string | null
    suspendedBy?: string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type TenantUpsertWithoutAuditLogsInput = {
    update: XOR<TenantUpdateWithoutAuditLogsInput, TenantUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAuditLogsInput, TenantUncheckedUpdateWithoutAuditLogsInput>
  }

  export type TenantUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    tweets?: TweetUpdateManyWithoutTenantNestedInput
    news?: NewsUpdateManyWithoutTenantNestedInput
    aiAnalysis?: AiAnalysisUpdateManyWithoutTenantNestedInput
    alerts?: AlertUpdateManyWithoutTenantNestedInput
    aiProcessingQueue?: AiProcessingQueueUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    tweets?: TweetUncheckedUpdateManyWithoutTenantNestedInput
    news?: NewsUncheckedUpdateManyWithoutTenantNestedInput
    aiAnalysis?: AiAnalysisUncheckedUpdateManyWithoutTenantNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutTenantNestedInput
    aiProcessingQueue?: AiProcessingQueueUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTemporaryPassword?: BoolFieldUpdateOperationsInput | boolean
    temporaryPasswordExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendedBy?: NullableStringFieldUpdateOperationsInput | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    alerts?: AlertUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTemporaryPassword?: BoolFieldUpdateOperationsInput | boolean
    temporaryPasswordExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendedBy?: NullableStringFieldUpdateOperationsInput | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyTenantInput = {
    id?: string
    email: string
    username: string
    password: string
    role: $Enums.UserRole
    status?: $Enums.UserStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    isTemporaryPassword?: boolean
    temporaryPasswordExpiresAt?: Date | string | null
    suspendedAt?: Date | string | null
    suspendedBy?: string | null
    suspensionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetCreateManyTenantInput = {
    id?: string
    tweetId: string
    mediaSourceId: string
    authorName: string
    authorHandle: string
    content: string
    publishedAt: Date | string
    hashtags?: TweetCreatehashtagsInput | string[]
    mentions?: TweetCreatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsCreateManyTenantInput = {
    id?: string
    tweetId: string
    mediaSourceId: string
    title?: string | null
    content?: string | null
    url?: string | null
    extractedAt: Date | string
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiAnalysisCreateManyTenantInput = {
    id?: string
    tweetId?: string | null
    newsId?: string | null
    type: $Enums.AnalysisType
    prompt: string
    response: JsonNullValueInput | InputJsonValue
    sentiment?: string | null
    relevance?: number | null
    threatLevel?: $Enums.ThreatLevel | null
    tags?: AiAnalysisCreatetagsInput | string[]
    processedAt?: Date | string
    createdAt?: Date | string
  }

  export type AlertCreateManyTenantInput = {
    id?: string
    userId?: string | null
    type: $Enums.AlertType
    title: string
    message: string
    severity: $Enums.AlertSeverity
    status?: $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: Date | string
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiProcessingQueueCreateManyTenantInput = {
    id?: string
    tweetId?: string | null
    newsId?: string | null
    queueType: $Enums.QueueType
    priority?: number
    status?: $Enums.QueueStatus
    attempts?: number
    maxAttempts?: number
    scheduledAt?: Date | string
    processedAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyTenantInput = {
    id?: string
    userId?: string | null
    action: $Enums.AuditAction
    entityType: $Enums.AuditEntityType
    entityId?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    sessionId?: string | null
    clientFingerprint?: string | null
    checksum: string
    digitalSignature?: string | null
    performedAt?: Date | string
    createdAt?: Date | string
    securityLevel?: $Enums.SecurityLevel
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTemporaryPassword?: BoolFieldUpdateOperationsInput | boolean
    temporaryPasswordExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendedBy?: NullableStringFieldUpdateOperationsInput | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTemporaryPassword?: BoolFieldUpdateOperationsInput | boolean
    temporaryPasswordExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendedBy?: NullableStringFieldUpdateOperationsInput | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTemporaryPassword?: BoolFieldUpdateOperationsInput | boolean
    temporaryPasswordExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendedBy?: NullableStringFieldUpdateOperationsInput | string | null
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorHandle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtags?: TweetUpdatehashtagsInput | string[]
    mentions?: TweetUpdatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaSource?: MediaSourceUpdateOneRequiredWithoutTweetsNestedInput
    news?: NewsUpdateManyWithoutTweetNestedInput
    aiAnalysis?: AiAnalysisUpdateManyWithoutTweetNestedInput
    tweetMedia?: TweetMediaUpdateManyWithoutTweetNestedInput
  }

  export type TweetUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    mediaSourceId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorHandle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtags?: TweetUpdatehashtagsInput | string[]
    mentions?: TweetUpdatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    news?: NewsUncheckedUpdateManyWithoutTweetNestedInput
    aiAnalysis?: AiAnalysisUncheckedUpdateManyWithoutTweetNestedInput
    tweetMedia?: TweetMediaUncheckedUpdateManyWithoutTweetNestedInput
  }

  export type TweetUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    mediaSourceId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorHandle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtags?: TweetUpdatehashtagsInput | string[]
    mentions?: TweetUpdatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extractedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tweet?: TweetUpdateOneRequiredWithoutNewsNestedInput
    mediaSource?: MediaSourceUpdateOneRequiredWithoutNewsNestedInput
    aiAnalysis?: AiAnalysisUpdateManyWithoutNewsNestedInput
  }

  export type NewsUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    mediaSourceId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extractedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiAnalysis?: AiAnalysisUncheckedUpdateManyWithoutNewsNestedInput
  }

  export type NewsUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    mediaSourceId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extractedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiAnalysisUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    prompt?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    relevance?: NullableFloatFieldUpdateOperationsInput | number | null
    threatLevel?: NullableEnumThreatLevelFieldUpdateOperationsInput | $Enums.ThreatLevel | null
    tags?: AiAnalysisUpdatetagsInput | string[]
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tweet?: TweetUpdateOneWithoutAiAnalysisNestedInput
    news?: NewsUpdateOneWithoutAiAnalysisNestedInput
  }

  export type AiAnalysisUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    newsId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    prompt?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    relevance?: NullableFloatFieldUpdateOperationsInput | number | null
    threatLevel?: NullableEnumThreatLevelFieldUpdateOperationsInput | $Enums.ThreatLevel | null
    tags?: AiAnalysisUpdatetagsInput | string[]
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiAnalysisUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    newsId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    prompt?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    relevance?: NullableFloatFieldUpdateOperationsInput | number | null
    threatLevel?: NullableEnumThreatLevelFieldUpdateOperationsInput | $Enums.ThreatLevel | null
    tags?: AiAnalysisUpdatetagsInput | string[]
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiProcessingQueueUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    newsId?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: EnumQueueTypeFieldUpdateOperationsInput | $Enums.QueueType
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiProcessingQueueUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    newsId?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: EnumQueueTypeFieldUpdateOperationsInput | $Enums.QueueType
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiProcessingQueueUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    newsId?: NullableStringFieldUpdateOperationsInput | string | null
    queueType?: EnumQueueTypeFieldUpdateOperationsInput | $Enums.QueueType
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: EnumAuditEntityTypeFieldUpdateOperationsInput | $Enums.AuditEntityType
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    clientFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    checksum?: StringFieldUpdateOperationsInput | string
    digitalSignature?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    securityLevel?: EnumSecurityLevelFieldUpdateOperationsInput | $Enums.SecurityLevel
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: EnumAuditEntityTypeFieldUpdateOperationsInput | $Enums.AuditEntityType
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    clientFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    checksum?: StringFieldUpdateOperationsInput | string
    digitalSignature?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    securityLevel?: EnumSecurityLevelFieldUpdateOperationsInput | $Enums.SecurityLevel
  }

  export type AuditLogUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: EnumAuditEntityTypeFieldUpdateOperationsInput | $Enums.AuditEntityType
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    clientFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    checksum?: StringFieldUpdateOperationsInput | string
    digitalSignature?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    securityLevel?: EnumSecurityLevelFieldUpdateOperationsInput | $Enums.SecurityLevel
  }

  export type AlertCreateManyUserInput = {
    id?: string
    tenantId: string
    type: $Enums.AlertType
    title: string
    message: string
    severity: $Enums.AlertSeverity
    status?: $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: Date | string
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    tenantId: string
    action: $Enums.AuditAction
    entityType: $Enums.AuditEntityType
    entityId?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    sessionId?: string | null
    clientFingerprint?: string | null
    checksum: string
    digitalSignature?: string | null
    performedAt?: Date | string
    createdAt?: Date | string
    securityLevel?: $Enums.SecurityLevel
  }

  export type AlertUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: EnumAuditEntityTypeFieldUpdateOperationsInput | $Enums.AuditEntityType
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    clientFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    checksum?: StringFieldUpdateOperationsInput | string
    digitalSignature?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    securityLevel?: EnumSecurityLevelFieldUpdateOperationsInput | $Enums.SecurityLevel
    tenant?: TenantUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: EnumAuditEntityTypeFieldUpdateOperationsInput | $Enums.AuditEntityType
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    clientFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    checksum?: StringFieldUpdateOperationsInput | string
    digitalSignature?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    securityLevel?: EnumSecurityLevelFieldUpdateOperationsInput | $Enums.SecurityLevel
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: EnumAuditEntityTypeFieldUpdateOperationsInput | $Enums.AuditEntityType
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    clientFingerprint?: NullableStringFieldUpdateOperationsInput | string | null
    checksum?: StringFieldUpdateOperationsInput | string
    digitalSignature?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    securityLevel?: EnumSecurityLevelFieldUpdateOperationsInput | $Enums.SecurityLevel
  }

  export type TweetCreateManyMediaSourceInput = {
    id?: string
    tenantId: string
    tweetId: string
    authorName: string
    authorHandle: string
    content: string
    publishedAt: Date | string
    hashtags?: TweetCreatehashtagsInput | string[]
    mentions?: TweetCreatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsCreateManyMediaSourceInput = {
    id?: string
    tenantId: string
    tweetId: string
    title?: string | null
    content?: string | null
    url?: string | null
    extractedAt: Date | string
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TweetUpdateWithoutMediaSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorHandle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtags?: TweetUpdatehashtagsInput | string[]
    mentions?: TweetUpdatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTweetsNestedInput
    news?: NewsUpdateManyWithoutTweetNestedInput
    aiAnalysis?: AiAnalysisUpdateManyWithoutTweetNestedInput
    tweetMedia?: TweetMediaUpdateManyWithoutTweetNestedInput
  }

  export type TweetUncheckedUpdateWithoutMediaSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorHandle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtags?: TweetUpdatehashtagsInput | string[]
    mentions?: TweetUpdatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    news?: NewsUncheckedUpdateManyWithoutTweetNestedInput
    aiAnalysis?: AiAnalysisUncheckedUpdateManyWithoutTweetNestedInput
    tweetMedia?: TweetMediaUncheckedUpdateManyWithoutTweetNestedInput
  }

  export type TweetUncheckedUpdateManyWithoutMediaSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorHandle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hashtags?: TweetUpdatehashtagsInput | string[]
    mentions?: TweetUpdatementionsInput | string[]
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    engagement?: NullableJsonNullValueInput | InputJsonValue
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsUpdateWithoutMediaSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extractedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutNewsNestedInput
    tweet?: TweetUpdateOneRequiredWithoutNewsNestedInput
    aiAnalysis?: AiAnalysisUpdateManyWithoutNewsNestedInput
  }

  export type NewsUncheckedUpdateWithoutMediaSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extractedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiAnalysis?: AiAnalysisUncheckedUpdateManyWithoutNewsNestedInput
  }

  export type NewsUncheckedUpdateManyWithoutMediaSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extractedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsCreateManyTweetInput = {
    id?: string
    tenantId: string
    mediaSourceId: string
    title?: string | null
    content?: string | null
    url?: string | null
    extractedAt: Date | string
    contentHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiAnalysisCreateManyTweetInput = {
    id?: string
    tenantId: string
    newsId?: string | null
    type: $Enums.AnalysisType
    prompt: string
    response: JsonNullValueInput | InputJsonValue
    sentiment?: string | null
    relevance?: number | null
    threatLevel?: $Enums.ThreatLevel | null
    tags?: AiAnalysisCreatetagsInput | string[]
    processedAt?: Date | string
    createdAt?: Date | string
  }

  export type TweetMediaCreateManyTweetInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NewsUpdateWithoutTweetInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extractedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutNewsNestedInput
    mediaSource?: MediaSourceUpdateOneRequiredWithoutNewsNestedInput
    aiAnalysis?: AiAnalysisUpdateManyWithoutNewsNestedInput
  }

  export type NewsUncheckedUpdateWithoutTweetInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    mediaSourceId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extractedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiAnalysis?: AiAnalysisUncheckedUpdateManyWithoutNewsNestedInput
  }

  export type NewsUncheckedUpdateManyWithoutTweetInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    mediaSourceId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    extractedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiAnalysisUpdateWithoutTweetInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    prompt?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    relevance?: NullableFloatFieldUpdateOperationsInput | number | null
    threatLevel?: NullableEnumThreatLevelFieldUpdateOperationsInput | $Enums.ThreatLevel | null
    tags?: AiAnalysisUpdatetagsInput | string[]
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAiAnalysisNestedInput
    news?: NewsUpdateOneWithoutAiAnalysisNestedInput
  }

  export type AiAnalysisUncheckedUpdateWithoutTweetInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    newsId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    prompt?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    relevance?: NullableFloatFieldUpdateOperationsInput | number | null
    threatLevel?: NullableEnumThreatLevelFieldUpdateOperationsInput | $Enums.ThreatLevel | null
    tags?: AiAnalysisUpdatetagsInput | string[]
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiAnalysisUncheckedUpdateManyWithoutTweetInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    newsId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    prompt?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    relevance?: NullableFloatFieldUpdateOperationsInput | number | null
    threatLevel?: NullableEnumThreatLevelFieldUpdateOperationsInput | $Enums.ThreatLevel | null
    tags?: AiAnalysisUpdatetagsInput | string[]
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TweetMediaUpdateWithoutTweetInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TweetMediaUncheckedUpdateWithoutTweetInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TweetMediaUncheckedUpdateManyWithoutTweetInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiAnalysisCreateManyNewsInput = {
    id?: string
    tenantId: string
    tweetId?: string | null
    type: $Enums.AnalysisType
    prompt: string
    response: JsonNullValueInput | InputJsonValue
    sentiment?: string | null
    relevance?: number | null
    threatLevel?: $Enums.ThreatLevel | null
    tags?: AiAnalysisCreatetagsInput | string[]
    processedAt?: Date | string
    createdAt?: Date | string
  }

  export type AiAnalysisUpdateWithoutNewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    prompt?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    relevance?: NullableFloatFieldUpdateOperationsInput | number | null
    threatLevel?: NullableEnumThreatLevelFieldUpdateOperationsInput | $Enums.ThreatLevel | null
    tags?: AiAnalysisUpdatetagsInput | string[]
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAiAnalysisNestedInput
    tweet?: TweetUpdateOneWithoutAiAnalysisNestedInput
  }

  export type AiAnalysisUncheckedUpdateWithoutNewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    prompt?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    relevance?: NullableFloatFieldUpdateOperationsInput | number | null
    threatLevel?: NullableEnumThreatLevelFieldUpdateOperationsInput | $Enums.ThreatLevel | null
    tags?: AiAnalysisUpdatetagsInput | string[]
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiAnalysisUncheckedUpdateManyWithoutNewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tweetId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType
    prompt?: StringFieldUpdateOperationsInput | string
    response?: JsonNullValueInput | InputJsonValue
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    relevance?: NullableFloatFieldUpdateOperationsInput | number | null
    threatLevel?: NullableEnumThreatLevelFieldUpdateOperationsInput | $Enums.ThreatLevel | null
    tags?: AiAnalysisUpdatetagsInput | string[]
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}